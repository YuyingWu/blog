<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小伍</title>
  
  <subtitle>小伍的自留地</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://wuyuying.com/"/>
  <updated>2019-02-08T09:18:45.460Z</updated>
  <id>http://wuyuying.com/</id>
  
  <author>
    <name>Yuying Wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>手机摄影-后期</title>
    <link href="http://wuyuying.com/archives/mobile-photography-lightroom/"/>
    <id>http://wuyuying.com/archives/mobile-photography-lightroom/</id>
    <published>2019-02-08T07:44:54.000Z</published>
    <updated>2019-02-08T09:18:45.460Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注：下面属于读书笔记，部分内容以及文中的照片和配图，部分摘自<a href="https://book.douban.com/subject/27186717/" target="_blank" rel="noopener">《手机摄影，凭什么比相机还酷》</a>（韩松、谭凌飞、张薇著）。</p></blockquote><h2 id="零、后期的误区"><a href="#零、后期的误区" class="headerlink" title="零、后期的误区"></a>零、后期的误区</h2><p>我们在日常的照片处理中，可能会出现“过度的特效和二次设计”。</p><p>这指的是过度的暗角、光晕、颗粒、花瓣等。这也是许多初学者容易出现的问题，即修图并没有解决照片的根本问题，而是不停地往上加许多层不合时宜的特效，画面显得轻浮而肮脏，背离了摄影的本质。</p><h2 id="一、后期正确的打开方式"><a href="#一、后期正确的打开方式" class="headerlink" title="一、后期正确的打开方式"></a>一、后期正确的打开方式</h2><p>这张是原图。</p><p><img src="http://sinacloud.net/blog-image/mobile-camera-lightroom-original-photo.jpeg" alt="&quot;后期-原图&quot;"></p><h3 id="第一层-——-原片到再构图"><a href="#第一层-——-原片到再构图" class="headerlink" title="第一层 —— 原片到再构图"></a>第一层 —— 原片到再构图</h3><p>通过后期的裁切、旋转、拉直等可以进行一次轻微的再构图过程，这是后期的第一层。</p><p><img src="http://sinacloud.net/blog-image/mobile-camera-lightroom-composition.jpeg" alt="&quot;后期-再构图&quot;"></p><p>经过裁切和矫正调整，想要表现的主体更突出。</p><h3 id="第二层-——-影调和色彩"><a href="#第二层-——-影调和色彩" class="headerlink" title="第二层 —— 影调和色彩"></a>第二层 —— 影调和色彩</h3><p>手机摄影者应该对影调和色彩的基本概念有了解，知道调整它们画面会出现什么样的效果：如亮度、对比度、高光、阴影、色温等（如Snapseed最基础调色选项）。对曲线、直方图等了解越多越好，熟练掌握这些参数的调整，才是后期处理的核心。</p><p><img src="http://sinacloud.net/blog-image/mobile-camera-lightroom-color.jpeg" alt="&quot;后期-影调和色彩&quot;"></p><p>经过影调和色彩调整后，曝光得到了补偿，VSCO的A6滤镜奠定了色彩基调。</p><h3 id="第三层-——-暗角、光影、颗粒等特效"><a href="#第三层-——-暗角、光影、颗粒等特效" class="headerlink" title="第三层 —— 暗角、光影、颗粒等特效"></a>第三层 —— 暗角、光影、颗粒等特效</h3><p><img src="http://sinacloud.net/blog-image/mobile-camera-lightroom-effects.jpeg" alt="&quot;后期-特效&quot;"></p><p>加了些许暗角和颗粒（不用很明显），让照片更有质感。</p><h2 id="二、手机摄影后期的技巧"><a href="#二、手机摄影后期的技巧" class="headerlink" title="二、手机摄影后期的技巧"></a>二、手机摄影后期的技巧</h2><h3 id="1-裁切-——-重构图"><a href="#1-裁切-——-重构图" class="headerlink" title="1. 裁切 —— 重构图"></a>1. 裁切 —— 重构图</h3><p>关键字：</p><ul><li>调整主体元素和画面的比例</li><li>调整主体元素在画面中的位置</li><li>调整元素和元素之间的平衡关系</li><li>裁掉影响表现主题的多余边角</li></ul><h3 id="2-矫正-——-修整画面"><a href="#2-矫正-——-修整画面" class="headerlink" title="2. 矫正 —— 修整画面"></a>2. 矫正 —— 修整画面</h3><h4 id="i-旋转"><a href="#i-旋转" class="headerlink" title="i. 旋转"></a>i. 旋转</h4><p>修正意图水平却差一点的情况。</p><h4 id="ii-自由变换"><a href="#ii-自由变换" class="headerlink" title="ii. 自由变换"></a>ii. 自由变换</h4><p>将照片用4个点来定位，可以在一定范围内任意拉扯，特别在表现一些方格网或其他几何感很强的场景时用到</p><blockquote><p>app：SKEW</p></blockquote><p><img src="http://sinacloud.net/blog-image/mobile-camera-lightroom-skew.jpeg" alt="&quot;后期-自由变换&quot;"></p><h4 id="iii-梯形校正"><a href="#iii-梯形校正" class="headerlink" title="iii. 梯形校正"></a>iii. 梯形校正</h4><p>调整透视关系。</p><ul><li>拍摄建筑和空间时，竖直线条会经常“倾斜”，产生三点透视</li><li>经过梯形矫正后，修直竖直线条</li></ul><p><img src="http://sinacloud.net/blog-image/mobile-camera-lightroom-tixing-1.jpeg" alt="&quot;后期-梯形校正-原图&quot;"></p><p><img src="http://sinacloud.net/blog-image/mobile-camera-lightroom-tixing-2.jpeg" alt="&quot;后期-梯形校正-校正后&quot;"></p><h3 id="3-影调——明暗、对比"><a href="#3-影调——明暗、对比" class="headerlink" title="3. 影调——明暗、对比"></a>3. 影调——明暗、对比</h3><p>每幅照片都会有最亮的地方（高光）、最暗的地方（阴影），以及处在他们之间的地方（中间调）。调整一张照片的最基础同时也是最重要的便是调整影调。</p><p>调整的参数：</p><ul><li>亮度</li><li>对比度</li><li>高光和阴影</li><li>局部：影调还可以自定义调整区域，以获得局部的影调调整</li></ul><p><img src="http://sinacloud.net/blog-image/mobile-camera-lightroom-1.jpeg" alt="&quot;手机摄影后期演示&quot;"></p><p><img src="http://sinacloud.net/blog-image/mobile-camera-lightroom-2.jpeg" alt="&quot;手机摄影后期演示&quot;"></p><p><img src="http://sinacloud.net/blog-image/mobile-camera-lightroom-3.jpeg" alt="&quot;手机摄影后期演示&quot;"></p><p><img src="http://sinacloud.net/blog-image/mobile-camera-lightroom-4.jpeg" alt="&quot;手机摄影后期演示&quot;"></p><p><img src="http://sinacloud.net/blog-image/mobile-camera-lightroom-5.jpeg" alt="&quot;手机摄影后期演示&quot;"></p><p><img src="http://sinacloud.net/blog-image/mobile-camera-lightroom-6.jpeg" alt="&quot;手机摄影后期演示&quot;"></p><h3 id="4-层次-——-简单的细节提升"><a href="#4-层次-——-简单的细节提升" class="headerlink" title="4. 层次 —— 简单的细节提升"></a>4. 层次 —— 简单的细节提升</h3><p>层次感，需要有更多细节。技术上来说，就是一张照片的高光、中间调、暗部都保有较多细节。尤其是中间调，让人觉得不会是“一笔带过”。</p><p><img src="http://sinacloud.net/blog-image/mobile-cam-layer-1.jpeg" alt="&quot;层次-原图&quot;"></p><h4 id="i-snapseed-“戏剧效果”"><a href="#i-snapseed-“戏剧效果”" class="headerlink" title="i. snapseed “戏剧效果”"></a>i. snapseed “戏剧效果”</h4><p>snapseed - 滤镜 - 戏剧效果</p><p>“戏剧效果”，可以直观地给我们带来层次感。</p><p><img src="http://sinacloud.net/blog-image/mobile-cam-layer-2-drama.jpeg" alt="&quot;层次-戏剧效果&quot;"></p><h4 id="ii-氛围"><a href="#ii-氛围" class="headerlink" title="ii. 氛围"></a>ii. 氛围</h4><p>snapseed - 调节图片 - 氛围</p><p><img src="http://sinacloud.net/blog-image/mobile-cam-layer-1-fenwei.jpeg" alt="&quot;层次-氛围&quot;"></p><h4 id="iii-质感"><a href="#iii-质感" class="headerlink" title="iii. 质感"></a>iii. 质感</h4><p><img src="http://sinacloud.net/blog-image/mobile-cam-layer-2.jpeg" alt="&quot;层次-质感-原图&quot;"></p><p>snapseed - 突出细节 - 结构</p><p>增加Snapseed“突出细节”菜单下的“结构”参数可以增加表面质感。</p><p><img src="http://sinacloud.net/blog-image/mobile-cam-layer-2-jiegou-plus.jpeg" alt="&quot;层次-质感-增强结构&quot;"></p><p>减小Snapseed“突出细节”菜单下的“结构” 参数，可以达到类似“磨皮”的效果。</p><p><img src="http://sinacloud.net/blog-image/mobile-cam-layer-2-jiegou-minus.jpeg" alt="&quot;层次-质感-减少结构&quot;"></p><h3 id="5-调色-——-开始有了情绪"><a href="#5-调色-——-开始有了情绪" class="headerlink" title="5. 调色 —— 开始有了情绪"></a>5. 调色 —— 开始有了情绪</h3><p>在Snapseed中，调色主要通过后期调整“白平衡”，以及“调整图片”中的“暖色调”完成。</p><p><img src="http://sinacloud.net/blog-image/mobile-cam-sediao-1.jpeg" alt="&quot;色调 - 原图&quot;"></p><p><img src="http://sinacloud.net/blog-image/mobile-cam-sediao-2.jpeg" alt="&quot;色调 - 冷色调&quot;"></p><h2 id="三、懂一点直方图和曲线"><a href="#三、懂一点直方图和曲线" class="headerlink" title="三、懂一点直方图和曲线"></a>三、懂一点直方图和曲线</h2><p>说到曲线调整前需要了解一下直方图，它像是照片的“仪表盘”一样，表现的是照片从暗部到中间调再到高光的像素分布。</p><p>曲线的调整逻辑并不复杂，左、中、右的曲线分别调整暗部、中间调、高光，往上拉是拉亮，往下拉是变暗。</p><p><img src="http://sinacloud.net/blog-image/mobile-cam-quxian.jpeg" alt="&quot;曲线调节&quot;"></p><h3 id="1-变亮（变暗）曲线"><a href="#1-变亮（变暗）曲线" class="headerlink" title="1. 变亮（变暗）曲线"></a>1. 变亮（变暗）曲线</h3><p>建立冇点，往上拉变亮，往下拉变暗。如果要局部调整，则需要建立更多的锚点。</p><h3 id="2-对比曲线"><a href="#2-对比曲线" class="headerlink" title="2. 对比曲线"></a>2. 对比曲线</h3><p>一种典型的曲线形式“S”型用以调整对比度。</p><p>把暗部调低，把亮部调高，增加对比度。反之，降低对比度。</p><h3 id="3-黑场和白场"><a href="#3-黑场和白场" class="headerlink" title="3. 黑场和白场"></a>3. 黑场和白场</h3><p>曲线的首末位置，我们分别称为黑场和白场，分别用来调整照片最暗和最亮的部分。</p><p>如果觉得一张照片太“硬”，看直方图发现是暗部太黑，而亮部又太亮，我们可以把黑场往上拉，画面不存在纯黑的地方，像加上了一层纱。</p><p>如果想让一张照片呈现出硬朗的风格，不妨将曲线黑场往右拉，这样画面暗部很大的区域就直接变成纯黑了，硬朗的风格就呈现了。</p><p>而白场同理。</p><h3 id="4-解构“风格”的曲线"><a href="#4-解构“风格”的曲线" class="headerlink" title="4. 解构“风格”的曲线"></a>4. 解构“风格”的曲线</h3><h4 id="i-日系风"><a href="#i-日系风" class="headerlink" title="i. 日系风"></a>i. 日系风</h4><ul><li>过曝</li><li>低饱和度</li><li>低对比度</li><li>背景虚化</li><li>逆光</li></ul><p><img src="http://sinacloud.net/blog-image/mobile-cam-lightroom-destructure.jpeg" alt="&quot;日系风格&quot;"></p><h4 id="ii-性冷淡风"><a href="#ii-性冷淡风" class="headerlink" title="ii. 性冷淡风"></a>ii. 性冷淡风</h4><ul><li>简练明朗的构图</li><li>明亮的影调</li><li>明快的亮度</li><li>合适的色调</li></ul><p><img src="http://sinacloud.net/blog-image/mobile-cam-lightroom-destructure-2.jpeg" alt="&quot;性冷淡风&quot;"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>《手机摄影，凭什么比相机还酷》 by 韩松、谭凌飞、张薇</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;注：下面属于读书笔记，部分内容以及文中的照片和配图，部分摘自&lt;a href=&quot;https://book.douban.com/subject/27186717/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《手机摄影，凭什么比相
      
    
    </summary>
    
    
      <category term="reading" scheme="http://wuyuying.com/tags/reading/"/>
    
      <category term="photography" scheme="http://wuyuying.com/tags/photography/"/>
    
  </entry>
  
  <entry>
    <title>手机摄影-构图</title>
    <link href="http://wuyuying.com/archives/mobile-photography-composition/"/>
    <id>http://wuyuying.com/archives/mobile-photography-composition/</id>
    <published>2019-02-08T04:21:55.000Z</published>
    <updated>2019-02-08T07:46:34.790Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注：下面属于读书笔记，部分内容以及文中的照片和配图，部分摘自<a href="https://book.douban.com/subject/27186717/" target="_blank" rel="noopener">《手机摄影，凭什么比相机还酷》</a>（韩松、谭凌飞、张薇著）。</p></blockquote><h2 id="1-构图是什么"><a href="#1-构图是什么" class="headerlink" title="1. 构图是什么"></a>1. 构图是什么</h2><p>构图主要是研究这些问题的。</p><ul><li>一幅照片中有什么东西？</li><li>这些东西是以怎样的形式呈现的？</li><li>这些东西表达了什么意思？</li></ul><h2 id="2-江湖中的一些简易构图方式"><a href="#2-江湖中的一些简易构图方式" class="headerlink" title="2. 江湖中的一些简易构图方式"></a>2. 江湖中的一些简易构图方式</h2><blockquote><p>优点：好操作，用法简单、常见<br>缺点：下面的构图方式都只关注照片中各个元素的“位置关系”，而位置关系只是构图中的一部分，甚至只是摄影的开始。</p></blockquote><h3 id="i-三分法"><a href="#i-三分法" class="headerlink" title="i. 三分法"></a>i. 三分法</h3><p>在相机的九宫格，有4条线和4个交点，把主体放在这些地方得到比较好的照片。</p><p><img src="http://sinacloud.net/blog-image/mobile-camera-goutu-sanfen.jpeg" alt="&quot;构图-三分法&quot;"></p><h3 id="ii-引导线构图"><a href="#ii-引导线构图" class="headerlink" title="ii. 引导线构图"></a>ii. 引导线构图</h3><p>引导线构图让我们寻找线条，并试图让这些线条的方向指向要表达的重点。</p><p><img src="http://sinacloud.net/blog-image/mobile-camera-goutu-guideline.jpeg" alt="&quot;构图-引导线&quot;"></p><h3 id="iii-框景式构图"><a href="#iii-框景式构图" class="headerlink" title="iii. 框景式构图"></a>iii. 框景式构图</h3><p>寻找各种“景框”来强化主题。</p><p><img src="http://sinacloud.net/blog-image/mobile-camera-goutu-framework.jpeg" alt="&quot;构图-框景式&quot;"></p><h3 id="iv-中心式构图"><a href="#iv-中心式构图" class="headerlink" title="iv. 中心式构图"></a>iv. 中心式构图</h3><p>将想要表达的主体放在画面正中央，以达到主体突出、平衡感强的效果。</p><p><img src="http://sinacloud.net/blog-image/mobile-camera-goutu-center.jpeg" alt="&quot;构图-中心式&quot;"></p><h3 id="v-对称式构图"><a href="#v-对称式构图" class="headerlink" title="v. 对称式构图"></a>v. 对称式构图</h3><p>用强烈的中心感和仪式感来抓人眼球。</p><p><img src="http://sinacloud.net/blog-image/mobile-camera-goutu-duichen.jpeg" alt="&quot;构图-对称式&quot;"></p><h3 id="vi-对角线构图"><a href="#vi-对角线构图" class="headerlink" title="vi. 对角线构图"></a>vi. 对角线构图</h3><p>让元素结构呈对角线分布，以获得更有动态的照片。</p><p><img src="http://sinacloud.net/blog-image/mobile-camera-goutu-duijiaoxian.jpeg" alt="&quot;构图-对角线&quot;"></p><h2 id="3-经营画面"><a href="#3-经营画面" class="headerlink" title="3. 经营画面"></a>3. 经营画面</h2><h3 id="i-关注画面里的“位置关系”"><a href="#i-关注画面里的“位置关系”" class="headerlink" title="i. 关注画面里的“位置关系”"></a>i. 关注画面里的“位置关系”</h3><p>对称轴、水平线、中心点，当然也包括三分点等位置，都在画面的几何重心，控制住一些结构，自然容易被关注，把主体放在这些位置很容易强调出来。江湖上的构图法则并非一无是处，这些法则还是很好地整理了一些“关键位置”。</p><p><img src="http://sinacloud.net/blog-image/mobile-camera-rules-center.jpeg" alt="&quot;构图-位置关系-中心点&quot;"></p><p><img src="http://sinacloud.net/blog-image/mobile-camera-rules-duichen.jpeg" alt="&quot;构图-位置关系-对称轴&quot;"></p><h3 id="ii-视觉平衡"><a href="#ii-视觉平衡" class="headerlink" title="ii. 视觉平衡"></a>ii. 视觉平衡</h3><p>“重量平衡”并不是一个构图的目的，而是经营画面需要体会的一种感觉，要尽量对这种感觉做到可控。</p><p><img src="http://sinacloud.net/blog-image/mobile-camera-balance.jpeg" alt="&quot;构图-视觉平衡&quot;"></p><h3 id="iii-联系原则"><a href="#iii-联系原则" class="headerlink" title="iii. 联系原则"></a>iii. 联系原则</h3><p>大多数摄影场景，不止一个元素，经营画面很重要的是表现元素之间的某些联系。</p><p><img src="http://sinacloud.net/blog-image/mobile-camera-link.jpeg" alt="&quot;构图-联系原则&quot;"></p><h3 id="iv-意图原则"><a href="#iv-意图原则" class="headerlink" title="iv. 意图原则"></a>iv. 意图原则</h3><p>经营画面还是要从自己的表达意图出发，找到画面的兴趣中心，用合适的方式表达出来。</p><p><img src="http://sinacloud.net/blog-image/mobile-camera-topic.jpeg" alt="&quot;构图-意图原则&quot;"></p><p>这张照片的意图是表达下雨天玻璃上的雨点，人物和景成为的背景。</p><h3 id="v-要有一个主题"><a href="#v-要有一个主题" class="headerlink" title="v. 要有一个主题"></a>v. 要有一个主题</h3><p>其实主题并不是什么高深的东西，要突出的人物事物，要表现的主要情节，要明示暗示的意思，都是主题。</p><p><img src="http://sinacloud.net/blog-image/mobile-camera-need-a-topic.jpeg" alt="&quot;构图-要有一个主题&quot;"></p><p><img src="http://sinacloud.net/blog-image/mobile-camera-photo-with-a-topic.jpeg" alt="&quot;构图-要有一个主题-demo&quot;"></p><p>上图的画面里，有一个突出的主体，其他的元素共同构成了整个画面。</p><h3 id="vi-要有合适的方法将观众的视线引向主题"><a href="#vi-要有合适的方法将观众的视线引向主题" class="headerlink" title="vi. 要有合适的方法将观众的视线引向主题"></a>vi. 要有合适的方法将观众的视线引向主题</h3><p><img src="http://sinacloud.net/blog-image/mobile-camera-guideline-to-topic.jpeg" alt="&quot;构图-视线引导&quot;"></p><p><img src="http://sinacloud.net/blog-image/mobile-camera-guideline-photo.jpeg" alt="&quot;构图-视线引导-照片&quot;"></p><h3 id="vii-画面要简洁"><a href="#vii-画面要简洁" class="headerlink" title="vii. 画面要简洁"></a>vii. 画面要简洁</h3><p>让画面简洁，尽量减少干扰主题表达或分散观众注意力的元素。</p><p>下面是处理前后的两张图。</p><p>第一张图，整个画面比较大，元素多一些，地面部分有点大，画面不够简洁。</p><p>第二张图，主体展现风车，突出主体，把一部分地面裁掉了。调高了对比度，风车的剪影更突出，画面更简洁。</p><p><img src="http://sinacloud.net/blog-image/mobile-camera-keep-the-photo-simple-1.jpeg" alt="&quot;构图-画面要简洁-处理前&quot;"></p><p><img src="http://sinacloud.net/blog-image/mobile-camera-keep-the-photo-simple-2.jpeg" alt="&quot;构图-画面要简洁-处理后&quot;"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>《摄影的艺术》 by Bruce Barnbaum</li><li>《纽约摄影学院摄影教材》</li><li>《手机摄影，凭什么比相机还酷》 by 韩松、谭凌飞、张薇</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;注：下面属于读书笔记，部分内容以及文中的照片和配图，部分摘自&lt;a href=&quot;https://book.douban.com/subject/27186717/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《手机摄影，凭什么比相
      
    
    </summary>
    
    
      <category term="reading" scheme="http://wuyuying.com/tags/reading/"/>
    
      <category term="photography" scheme="http://wuyuying.com/tags/photography/"/>
    
  </entry>
  
  <entry>
    <title>我的2018</title>
    <link href="http://wuyuying.com/archives/year-2018/"/>
    <id>http://wuyuying.com/archives/year-2018/</id>
    <published>2019-02-04T11:00:00.000Z</published>
    <updated>2019-02-04T12:10:57.958Z</updated>
    
    <content type="html"><![CDATA[<p>2018年，一些事一些情一些决定。Everything is changing.<br>2019年，学会爱自己、爱人、爱生活、爱工作。</p><p><img src="http://sinacloud.net/blog-image/IMG_20181229_164315.jpg" alt="&quot;绍兴&quot;"></p><h2 id="一、工作"><a href="#一、工作" class="headerlink" title="一、工作"></a>一、工作</h2><p>业务上的东西不能在这里讲哈，聊聊我有感受到自己需要成长的地方，关键字：沟通与协同、产品思维、团队作战。</p><h3 id="1-沟通与协同"><a href="#1-沟通与协同" class="headerlink" title="1. 沟通与协同"></a>1. 沟通与协同</h3><p>今年，我和小伙伴们搞了个跟业务结合的A/B Testing解决方案，助力数据驱动的业务增长。</p><p>这个事情我一开始想得很简单，只想到要做基础的A/B实验和分流能力，并且想靠一己之力，在前端实现所有的功能（至少大部分功能）。</p><p>后来跟老板和很多小伙伴聊，发现自己看的面还是太窄了。</p><ul><li>这个方案的定位是什么？</li><li>用户是谁？</li><li>业务落地的应用场景在哪？</li><li>跟已有的技术/方案的联动如何？</li><li>集团有什么方案？要不要造轮子？和集团方案有没有合作的空间？</li><li>项目的规划如何？涉及哪些团队和人？整体节奏如何？</li></ul><p>从这个事情的过程中，我发现自身的一些短板，譬如不太喜欢跟人沟通，没有定期输出规划、进度和文档等。</p><p>及时沟通对焦和阶段的规划总结，有助于快速地推动事情的落地~ 19年会更好的！在这里感谢和我沟通、给我建议和支持我的小伙伴们。</p><h3 id="2-产品思维"><a href="#2-产品思维" class="headerlink" title="2. 产品思维"></a>2. 产品思维</h3><p>对于技术同学来说，这个东西被说得有点烂了。新同学刚入职的时候，前辈们经常会说：</p><p>“在接到项目需求时，要有自己的思考和见解，不要沦为资源。”</p><p>工作前三年，在度厂经过“严格”的训练，感觉自己来到阿里的时候，就可以做到了。</p><p>但在2018年，跟同事有更深入地交流，以及跟合作方有更紧密的沟通，对这句话似乎有了新的理解。</p><p>以前更多的是在接到项目后，根据这个项目背后的业务或产品思路到实现的这条链路上，技术能不更快更好地支持。</p><p>而现在则是更希望从源头出发，业务或产品的全年或者半年规划是怎样的？整体要实现怎样的目标？我们做的项目有没有帮助到目标的提升？或者，知道规划和目标后，合作方没有想好具体实施的action，我们能不能在技术视角，提供一些靠谱的方向或者建议。</p><p>两个关键：</p><ul><li>做有效率的资源，工作流、工作思路</li><li>从源头出发，了解业务真正要什么，技术视角的建议</li></ul><p><img src="http://sinacloud.net/blog-image/328-2018.jpeg" alt="&quot;2018 328&quot;"></p><h3 id="3-团队合作"><a href="#3-团队合作" class="headerlink" title="3. 团队合作"></a>3. 团队合作</h3><p>19年，我遇到另一个挑战 —— 团队合作。以前的老板有说过我，我自己也知道的短板 —— 习惯单兵作战。</p><p>团队分工，之前的做法是，项目先排着，中间有别的项目，再看优先级来排。</p><p>嗯，看起来没毛病，实际上很被动。</p><p>关注的点跟上一part有点像。对接的业务线，规划和节奏是什么？今年想要实现怎样的结果，需要多少人？今年我们的人员安排规划是怎样的？（谁做什么？互相怎么backup？人员时间充足时，怎么排？人员在不足的情况下，怎么排？）</p><p>拥抱变化，2018到2019的改变，还有从原本对接一条业务线，变成现在的四条，阔怕……还好，我并不是一个人，还有一个靠谱的和我并肩作战的小伙伴！Fighting!!!</p><p><img src="http://sinacloud.net/blog-image/2018-qiandaohu.jpeg" alt="&quot;千岛湖的淘货源小分队&quot;"></p><h3 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a>4. 其他</h3><p>和鱼总一起去深圳参加ICBU的前端艺术家沙龙，客串主持~</p><p><img src="http://sinacloud.net/blog-image/2018-fe-artist-1.jpeg" alt="&quot;可乐罐&quot;"></p><p><img src="http://sinacloud.net/blog-image/2018-fe-artist-2.jpeg" alt="&quot;主持&quot;"></p><h2 id="二、读书"><a href="#二、读书" class="headerlink" title="二、读书"></a>二、读书</h2><p>2018年，读书18本，18年目标是40本，不达标。</p><p>在这不分享书单了，我浏览了一下，然后问自己，我看过这些书吗？！（逃）</p><p>读到棒棒的书包括：</p><p><a href="https://book.douban.com/subject/1084336/" target="_blank" rel="noopener">《小王子》</a><br><a href="https://book.douban.com/subject/30155720/" target="_blank" rel="noopener">《小小小小的火》</a>  </p><p><img src="http://sinacloud.net/blog-image/le_petit_prince.jpeg" alt="&quot;Le Petit Prince&quot;"></p><p>其中我还想说像《增长黑客》和《Designing with Data》这两本也很长知识，哈哈，但放两本专业书在这里总觉得哪里不对，你们自己去看我的读书笔记吧~</p><ul><li><a href="http://wuyuying.com/blog/archives/improve-ue-with-ab-testing/">AB Testing是如何提升用户体验的</a> from 《Designing with Data》</li><li><a href="http://wuyuying.com/blog/archives/growth-hacker/">书摘-增长黑客</a> from 《增长黑客》</li></ul><p>今年看书的时间少了一些，看完后没印象，这样不太好，说明没有把书里的东西变成我自己的东西，没消化过程。</p><p>前几天看到得到一篇讲“拆书”的软文，里面有一女孩1年能读200本书，但她回看书单时，竟发现仅有少数能想起书中内容是什么。文章的后面当然有分享下拆书的过程和卖课，但里面的一些方法可以参考和实践一下。</p><ul><li>I：用自己的语言复述知识</li><li>A1：描述自己的相关经验</li><li>A2：规划未来的应用</li></ul><h2 id="三、电影"><a href="#三、电影" class="headerlink" title="三、电影"></a>三、电影</h2><p>今年看的电影很少，就不作总结了，去翻翻票圈的年度电影总结，挑几部想看的剧或者电影。看电影和看书一样，可以带我们去看世界~</p><p>最近在看的一部英剧，推给你们哟，很有趣。</p><p><a href="https://movie.douban.com/subject/27594217/" target="_blank" rel="noopener">性爱自修室 第一季 Sex Education Season 1 (2019)</a></p><p><img src="http://sinacloud.net/blog-image/sex-education.png" alt="&quot;sex education&quot;"></p><h2 id="四、博客"><a href="#四、博客" class="headerlink" title="四、博客"></a>四、博客</h2><p>今年写的日志里，技术日志会稍微多一些，哈哈，说明有一直在输入，明年继续加油~<br>在19年，除了技术文章或读书笔记保持外，还希望多一些摄影、咖啡、生活、兴趣等话题的记录和思考。</p><h3 id="1-技术"><a href="#1-技术" class="headerlink" title="1. 技术"></a>1. 技术</h3><h4 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h4><ul><li><a href="http://wuyuying.com/blog/archives/css-var/">CSS Variables学习笔记</a></li></ul><h4 id="GraphQL"><a href="#GraphQL" class="headerlink" title="GraphQL"></a>GraphQL</h4><ul><li><a href="http://wuyuying.com/blog/archives/graphql/">GraphQL小记</a></li><li><a href="http://wuyuying.com/blog/archives/graphql-in-action/">GraphQL in Action</a></li></ul><h4 id="别说你懂CSS相对单位（系列）"><a href="#别说你懂CSS相对单位（系列）" class="headerlink" title="别说你懂CSS相对单位（系列）"></a>别说你懂CSS相对单位（系列）</h4><ul><li><a href="http://wuyuying.com/blog/archives/css-in-depth-relative-units/">如何更愉快地使用em —— 别说你懂CSS相对单位</a></li><li><a href="http://wuyuying.com/blog/archives/css-in-depth-stop-thinking-in-px/">如何更愉快地使用rem —— 别说你懂CSS相对单位</a></li><li><a href="http://wuyuying.com/blog/archives/css-in-depth-viewport-relative-units/">视口相关单位的应用 —— 别说你懂CSS相对单位</a></li><li><a href="http://wuyuying.com/blog/archives/css-in-depth-unitless-number/">无单位数字和行高 —— 别说你懂CSS相对单位</a></li><li><a href="http://wuyuying.com/blog/archives/css-in-depth-css-variables/">CSS自定义属性 —— 别说你懂CSS相对单位</a></li></ul><h4 id="前端测试相关"><a href="#前端测试相关" class="headerlink" title="前端测试相关"></a>前端测试相关</h4><ul><li><a href="http://wuyuying.com/blog/archives/bdd-in-reactjs/">Behavior Driven Development in ReactJS</a></li><li><a href="http://wuyuying.com/blog/archives/puppeteer/">puppeteer调研</a></li></ul><h4 id="增长黑客-amp-A-B-Testing"><a href="#增长黑客-amp-A-B-Testing" class="headerlink" title="增长黑客 &amp; A/B Testing"></a>增长黑客 &amp; A/B Testing</h4><ul><li><a href="http://wuyuying.com/blog/archives/improve-ue-with-ab-testing/">AB Testing是如何提升用户体验的</a></li><li><a href="http://wuyuying.com/blog/archives/growth-hacker/">书摘-增长黑客</a></li></ul><h4 id="技术杂记"><a href="#技术杂记" class="headerlink" title="技术杂记"></a>技术杂记</h4><ul><li><a href="http://wuyuying.com/blog/archives/optimizing-react-virtual-dom-explained/">[译] React性能优化-虚拟Dom原理浅析</a></li><li><a href="http://wuyuying.com/blog/archives/hexo-travis/">开箱即用，Hexo博客的github+server自动部署</a></li></ul><h3 id="2-书摘"><a href="#2-书摘" class="headerlink" title="2. 书摘"></a>2. 书摘</h3><ul><li><a href="http://wuyuying.com/blog/archives/slash/">关于「自由态职业」</a></li><li><a href="http://wuyuying.com/blog/archives/as-a-loser-at-investing/">韭菜的自我修养</a></li></ul><h2 id="五、理财"><a href="#五、理财" class="headerlink" title="五、理财"></a>五、理财</h2><p><img src="http://sinacloud.net/blog-image/屏幕快照%202019-02-04%2016.59.25.png" alt="&quot;2018 A股 大盘&quot;"></p><p>咳咳，2018年，A股大盘大概跌了25%，每一年的目标是跑赢大盘……然而，现在我有点不敢看我的账户了，这里先留白，等心情好的时候再更吧。</p><p>To be continued.</p><p>有时看一些投资的书，知识面会很薄，19年要开始看一些基础的经济学的书，补充一点基本面的知识，譬如桌上薛教授的《薛兆丰经济学讲义》。</p><h2 id="六、兴趣爱好"><a href="#六、兴趣爱好" class="headerlink" title="六、兴趣爱好"></a>六、兴趣爱好</h2><p>最近和几个小伙伴都聊起“兴趣爱好”这个话题。</p><p>如果一个人的业余生活有自己的兴趣爱好，那ta的状态会充沛而饱满，人也会开心很多。</p><p>反之，长期处于一个静止的状态，既没输入，也没输出，可能就会稍微枯燥一些，也容易陷入现状。</p><blockquote><p>也许世界上也有五千朵和你一模一样的花，但只有你是我独一无二的玫瑰。 —— 《小王子》</p></blockquote><p>花费了时间和爱，让玫瑰变成小王子的珍贵的玫瑰，我有在自己身上放了多少时间和爱？</p><p>反思一下，过去对自己的投入，或者在兴趣爱好的开发和坚持上，花的时间太少，在19年，要多尝试，找到自己感兴趣的东西并持之以恒。而现在自己感兴趣的东西，譬如咖啡，要更系统地去输入和输出。</p><p>/<strong> 我是一条分割线 </strong>/</p><p>我平时喜欢喝咖啡，大家应该都是知道的，哈哈，今年有人问我：</p><blockquote><p>你为什么喜欢咖啡？<br>怎么喜欢上的？<br>是什么吸引你？<br>为什么你每天都要喝？<br>为什么还经常花时间花钱去探店？</p></blockquote><p>这个问题好难。我认真地想了跟咖啡的故事。</p><ul><li>一开始，喝雀巢速溶、星巴克；[喝咖啡是件很酷炫的事情，但很难喝]</li><li>后来，为了提神，开始喝一口就能醒、苦到掉渣的越南G7；[咖啡是功能饮品，苦]</li><li>在百度，有一段时间，天天跑到楼下咖啡厅喝咖啡；[咖啡厅很香，整个空间弥漫着咖啡的香气，也代表自由的空间，因为我不想工作被打扰，去咖啡厅办公]</li><li>去了新西兰，Flat White的起源地，每天早上一杯咖啡，像喝牛奶一样；[咖啡代表生活、放松]</li><li>此前我喝的都是花式咖啡，美式、flat white、拿铁</li><li>到了杭州，无意间去了间精品咖啡馆，斋啡（黑咖啡）也可以有丰富层次的味道，入坑精品咖啡，开始研究产地和冲泡方式，也买了一些新玩具。[咖啡开始好玩]</li></ul><p>我很认真地想了以上，对方跟我说：</p><blockquote><p>找到背后的原因和记住那种感觉，以同样的方式，工作中找到你的“咖啡”</p></blockquote><p>有这样的同事，伴我成长每一天，灵魂拷问，好极了~ 哈哈。</p><h2 id="七、小结-amp-未来展望"><a href="#七、小结-amp-未来展望" class="headerlink" title="七、小结 &amp; 未来展望"></a>七、小结 &amp; 未来展望</h2><p>2018年，感觉没有抓住的太多。<br>2019年，扬帆起航，注定是要起飞的一年！</p><p>我现在就要开始预告，2019年的总结，肯定很精彩，请期待~~~</p><p><img src="http://sinacloud.net/blog-image/fly-2019.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2018年，一些事一些情一些决定。Everything is changing.&lt;br&gt;2019年，学会爱自己、爱人、爱生活、爱工作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://sinacloud.net/blog-image/IMG_20181229_164315.
      
    
    </summary>
    
    
      <category term="总结" scheme="http://wuyuying.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>和团队谈个人成长 - 克军</title>
    <link href="http://wuyuying.com/archives/how-to-grow-to-be-an-excellent-frontend-developer/"/>
    <id>http://wuyuying.com/archives/how-to-grow-to-be-an-excellent-frontend-developer/</id>
    <published>2018-10-29T13:26:18.000Z</published>
    <updated>2019-02-04T10:43:04.741Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转自<a href="https://weibo.com/kejunz" target="_blank" rel="noopener">克军</a>的<a href="https://weibo.com/ttarticle/p/show?id=2309404300456787613157" target="_blank" rel="noopener">《[内部分享]和团队谈个人成长》</a>。干货十足，备份留着review自己。</p></blockquote><p><img src="https://r.sinaimg.cn/large/article/011f65a8cc93a1a6a80a7b9c40bd581e" alt=""></p><p><img src="https://r.sinaimg.cn/large/article/862ad46cbf579f89e1f1317b24ee3eba" alt=""></p><p><img src="https://r.sinaimg.cn/large/article/d043f0d78476db20d38d73a25e78d713" alt=""></p><p><img src="https://r.sinaimg.cn/large/article/5bbd2769178ee502073b39447e4ebec2" alt=""></p><p><img src="https://r.sinaimg.cn/large/article/33ffcfb2efb98468d31c4b75a0faf84d" alt=""></p><p><img src="https://r.sinaimg.cn/large/article/5f21ea42a876524f209dc82e2f503241" alt=""></p><p><img src="https://r.sinaimg.cn/large/article/7c01a284af4525535a2d0baf89ea7673" alt=""></p><p><img src="https://r.sinaimg.cn/large/article/5535dffa63e43388150471b8dcc77405" alt=""></p><p><img src="https://r.sinaimg.cn/large/article/215adf173d52e4b769a2f877bfa08d58" alt=""></p><p><img src="https://r.sinaimg.cn/large/article/7d362681f9ab38a50e4ed7f022dd1a96" alt=""></p><p><img src="https://r.sinaimg.cn/large/article/ce380011976dc9e90518822f68d4d6b7" alt=""></p><p><img src="https://r.sinaimg.cn/large/article/8960414620b32d2a280c58d8c25ba3c5" alt=""></p><p><img src="https://r.sinaimg.cn/large/article/ed5b8339adfd7e92979712b455b93248" alt=""></p><p><img src="https://r.sinaimg.cn/large/article/5e2efcb70d2d70e1a1777cfd171fcc29" alt=""></p><p>定位自己，关注自己当前阶断的积累，聚焦拐点，均衡发展。有些能力必须要有历经时间和反复历练形成的成熟度。不要试图跳跃、不要急于求成、不要忽视全面均衡的发展。不要成为职场“豆芽菜”。</p><p><img src="https://r.sinaimg.cn/large/article/53ac1ac8fbb07f7fc8ac0a1acdaa5e85" alt=""></p><p>浮躁就是只关注解决问题的手段，没有真正提高解决问题能力。修炼自己的元能力。</p><p><img src="https://r.sinaimg.cn/large/article/3006c39f383ee0065fd39715ac3e524c" alt=""></p><p><img src="https://r.sinaimg.cn/large/article/c55aac0f3bd77b98408e8f35dced2be6" alt=""></p><p><img src="https://r.sinaimg.cn/large/article/3818d4739931bf12ae8c7eae483cbbce" alt=""></p><p>电影《天才捕手》。在工作中，要积累真实的感受。看再多的书和文章，没有实践，没有在实际的应用场景中应用，都不算有效的经验。</p><p><img src="https://r.sinaimg.cn/large/article/8482e7b6abb3e3729bab0aeb3acf503c" alt=""></p><p>工作中保持痛感，感受快乐是最好的工作状态！</p><p><img src="https://r.sinaimg.cn/large/article/d151d83aa7d7c3edfc4c34f839474d95" alt=""></p><p><img src="https://r.sinaimg.cn/large/article/5e36034d0182dbcbe69963a8f7ec3402" alt=""></p><p>做不同的事情，内心感受是不同的。当你觉得无感时，说明你对技术细节的认知还不够，只是简单的重复。需要通过学习其中所有的技术点来提高技巧。同时，需要不断深入理解，感受实践中用到的技术和工具所发挥的作用。形象的说就是知识的“分辨率”怎么样，是模模糊糊的，还是”精度”很高，了解每一个细微的技术点。你会发现，有太多东西值得探索。只有在具体实践中才有体感，脱离应用场景啃一本书没有用的。进一步，你才能准确定义和抽象出开发中的普便问题。这是提高纵轴挑战水平的方式。所以，不必刻意寻找有挑战、有难度的工作做。重要的是，你能不能潜的更深，积累下更多的有价值的感受。</p><p>如果你正在做一件本身挑战很大的事，这时无须再增加挑战水平（纵轴）而是通过发现和学习已知的未知（对应问题域的知识域）技术来解决问题（横轴）。这时候需要拆解目标，降低挑战，耐心从基础开始学习。内心需要克服浮躁和自我怀疑的情绪。没有银弹能解决所有问题。关注前端技术发展，保持学习是十分重要的。</p><p>任何一种心理状态都不是一成不变的。比如一些能力不错的同学，对于常规需求，处于完全“掌控”的状态。但干的久了，一直做类似的事情挑战水平自然会衰减，通常会进入“无聊”的状态。然后常常会说工作太无聊，缺乏挑战，一成不变。其实是你主观意识上没有加深工作的感受，只是被动的被支配做一些事。经常反省自己所处的状态，每一件事努力做到心流（同时提高纵轴和横轴）</p><p><img src="https://r.sinaimg.cn/large/article/05e8c1bcc2dfbcb6d71f9764ab09e962" alt=""></p><p><img src="https://r.sinaimg.cn/large/article/077b5e1641644e21895c71bd326612fd" alt=""></p><p>心态管理很重要，尤其是底部状态管理。面对工作中的挫败、不爽、消极、想放弃的情绪，这些都是很正常的起起伏伏。人在做一件事的中途是最敏感、脆弱，最容易自我怀疑的，很容易怀疑目标和方向，半途而废，前功尽弃，这就是所谓的半途效应。在做一些挑战很大、路径很长的事情时，动机不要太强。急躁、焦虑会干扰正常的思维水平（多德森法则）。</p><p><img src="https://r.sinaimg.cn/large/article/8b2a18f547e8e4af9198d060f5a19414" alt=""></p><p><img src="https://r.sinaimg.cn/large/article/a4d1df48104a7d4bda7de2e958005d05" alt=""></p><p><img src="https://r.sinaimg.cn/large/article/b01be7a1c700716ef0c1a8887df6b8cc" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;转自&lt;a href=&quot;https://weibo.com/kejunz&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;克军&lt;/a&gt;的&lt;a href=&quot;https://weibo.com/ttarticle/p/show?id=23
      
    
    </summary>
    
    
      <category term="reading" scheme="http://wuyuying.com/tags/reading/"/>
    
      <category term="tech" scheme="http://wuyuying.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>韭菜的自我修养</title>
    <link href="http://wuyuying.com/archives/as-a-loser-at-investing/"/>
    <id>http://wuyuying.com/archives/as-a-loser-at-investing/</id>
    <published>2018-10-17T14:47:30.000Z</published>
    <updated>2019-02-04T10:43:04.739Z</updated>
    
    <content type="html"><![CDATA[<p>现在的A股上证指数2485点，看本文最下方的图，正处于“人心惶惶”的阶段。</p><p>在《韭菜的自我修养》这本书里，我觉得非常好的一个点是“周期”。</p><p>我们一开始进场，都会像书中描述的那样“进场就买买买”，只考虑短期未来的趋势是怎样（涨或跌）。我买股票的时间不算特别长，大学毕业到现在大概4年，经历过14年底到15年中的牛市，也经历过15年下半年的股灾，就是上半年赚的70%（对的，当我这样的菜鸟也能赚70%的时候，说明牛市真的到尽头了，当时应该收手的。）全都吐出来，还不止，倒贴被套至今。深深感受到“买买买”的坑，买的时候我甚至不知道目前处于周期的什么阶段。</p><blockquote><p>一个股市周期大致经历以下四个阶段：牛市阶段──高位盘整市阶段──熊市阶段──低位牛皮市阶段。</p></blockquote><p>关于“减少交易频次”，这也是我白玩了几年后才懂得的道理。刚入场时，总觉得交易次数越多，参与感越强，但很多时候买的是什么我根本不知道，大神之所以有“长期持有”的底气，真的是因为前期做的调研足够多，对自己买的东西有足够的了解，知道边界在哪。交易很频繁，说到底是没底气没安全感。</p><blockquote><p>进场之后，不要动，看上一年之后再动手买。</p></blockquote><p>这句话真的很有道理，但说起来容易做起来难，你可能明白这个道理，但控制住自己才是王道。<br>共勉。</p><hr><p>下面是书摘：</p><h2 id="3-亡羊补牢的“韭菜”才有前途"><a href="#3-亡羊补牢的“韭菜”才有前途" class="headerlink" title="3 亡羊补牢的“韭菜”才有前途"></a>3 亡羊补牢的“韭菜”才有前途</h2><blockquote><p>更可怕的，就是“一进场就连借来的钱都花光了”！人越穷，赚钱的欲望就越强烈，所以常常不惜铤而走险。</p></blockquote><h2 id="5-摆脱“韭菜”宿命的一个观念"><a href="#5-摆脱“韭菜”宿命的一个观念" class="headerlink" title="5 摆脱“韭菜”宿命的一个观念"></a>5 摆脱“韭菜”宿命的一个观念</h2><blockquote><p>他们全然忽视了交易市场里最大的一个作用力：经济周期。或者通俗点讲，就是牛熊交接。</p></blockquote><h2 id="7-谁说“韭菜”不在乎寻找价值"><a href="#7-谁说“韭菜”不在乎寻找价值" class="headerlink" title="7 谁说“韭菜”不在乎寻找价值"></a>7 谁说“韭菜”不在乎寻找价值</h2><blockquote><p>等待下一个正确的时机！</p></blockquote><h2 id="8-“韭菜”不缺耐心缺的是实力"><a href="#8-“韭菜”不缺耐心缺的是实力" class="headerlink" title="8 “韭菜”不缺耐心缺的是实力"></a>8 “韭菜”不缺耐心缺的是实力</h2><blockquote><p><strong>在交易市场里，实力指的究竟是什么？</strong><br>有一个清楚的定义：长期稳定的低成本现金流。<br>与此同时，还有另外一个重要的原则：控制仓位。永远要保留一定比例或者起码一定数量的现金 —— 这就好像潜海需要一个氧气罐一样，没得商量。至于比例是多少，数量是多少，没有定理，完全靠你自己琢磨。</p></blockquote><h2 id="9-喜欢冒险的最终都是“韭菜”"><a href="#9-喜欢冒险的最终都是“韭菜”" class="headerlink" title="9 喜欢冒险的最终都是“韭菜”"></a>9 喜欢冒险的最终都是“韭菜”</h2><blockquote><p>能不冒险绝不冒险；<br>即便是必须冒险的时候，也要让傻瓜们冒险，自己在一旁通过观察获得经验。</p></blockquote><h2 id="11-止损线究竟如何制定才合理"><a href="#11-止损线究竟如何制定才合理" class="headerlink" title="11 止损线究竟如何制定才合理"></a>11 止损线究竟如何制定才合理</h2><blockquote><p>“做更坏的打算”永远比“盲目乐观”更靠谱。<br>设定止损线之前，你要知道“交易标的日常波动幅度”。</p></blockquote><h2 id="12-频次才是决定一切的根本因素"><a href="#12-频次才是决定一切的根本因素" class="headerlink" title="12 频次才是决定一切的根本因素"></a>12 频次才是决定一切的根本因素</h2><blockquote><p>降低交易频……降低降低再降低。<br>涨到10倍之前，就当它不存在。（比特币）<br>降低交易频次的本质，是拒绝抛硬币，坚持逻辑推断。</p></blockquote><h2 id="16-正确地提升收益风险比的方法"><a href="#16-正确地提升收益风险比的方法" class="headerlink" title="16 正确地提升收益风险比的方法"></a>16 正确地提升收益风险比的方法</h2><blockquote><p>回报风险比 = 可能的回报 / 可能的风险  </p></blockquote><p>减小分母：</p><ul><li>调整止损线，降低自己的风险承担</li><li>降低每次的交易金额在总资金的占比</li><li>提高自己在场外的赚钱能力（或者募资能力）</li></ul><p>加大分子：</p><ul><li>选择更为优质的交易标</li><li>选择最佳的交易时机（比如，若干次暴跌之后再买）</li><li>放长持有时间（比如，穿越一次以上的牛熊）</li></ul><h2 id="18-你要学的真不是项目分析能力"><a href="#18-你要学的真不是项目分析能力" class="headerlink" title="18 你要学的真不是项目分析能力"></a>18 你要学的真不是项目分析能力</h2><blockquote><p>进场之后，不要动，看上一年之后再动手买。因为这样的话，你已经更聪明了。<br>只买交易量最大的那么一两个或者两三个标。</p></blockquote><h2 id="19-韭菜没有生活甚至没有性生活"><a href="#19-韭菜没有生活甚至没有性生活" class="headerlink" title="19 韭菜没有生活甚至没有性生活"></a>19 韭菜没有生活甚至没有性生活</h2><blockquote><p>记住，你要有生活，并且，生活最重要！<br>降低交易频率<br>从今天开始，更加努力更加认真地生活！</p></blockquote><blockquote><p><strong>FOMO</strong><br>Fear of Missing Out，或者Fear of Missing Opportunity，对丧失机会的极度恐惧。</p></blockquote><h2 id="20-孤独是成功交易者最宝贵的品质"><a href="#20-孤独是成功交易者最宝贵的品质" class="headerlink" title="20 孤独是成功交易者最宝贵的品质"></a>20 孤独是成功交易者最宝贵的品质</h2><blockquote><p>孤独地交易<br>听大多数人的话，参考少数人的意见，自己做决定。<br>事实上，在任何领域里，想要把手中的事情做到机制，都要学会独处。<br>你最终的收益和你的孤独程度一定会同比增加，高度一致。</p></blockquote><h2 id="21-生活之外还必须有工作和学习"><a href="#21-生活之外还必须有工作和学习" class="headerlink" title="21 生活之外还必须有工作和学习"></a>21 生活之外还必须有工作和学习</h2><blockquote><p>成功交易者的一个基本素质就是：<br>在任何时候都持有一定比例的现金。</p></blockquote><blockquote><p>在交易市场里，无论是现金、时间还是生活，都绝对不可以all in。</p></blockquote><blockquote><p>成功的交易者都知道，自己最需要的，除了现金之外，就是自身的成长。</p></blockquote><h2 id="22-认识周期、识别周期和把握周期"><a href="#22-认识周期、识别周期和把握周期" class="headerlink" title="22 认识周期、识别周期和把握周期"></a>22 认识周期、识别周期和把握周期</h2><blockquote><p>关注周期，以及多个周期背后显现出来的真正趋势，会给你一个全新且更为可靠的世界和视界。</p></blockquote><blockquote><p><strong>如何把握周期呢？</strong><br>有很多种理论，最终，在我眼里只有一个东西简单靠谱容易上手不太可能出错：仔细观察体会绝大多数交易者的情绪。<br>牛市里，FOMO情绪达到顶峰，各种投资者开始ALL-IN的时候，上升趋势渐渐到头了；<br>熊市里，大多数“韭菜”经过失望谩骂而后竟然平静了的时候，下跌趋势渐渐到底了……</p></blockquote><blockquote><p>两张图表可以帮助你更深地理解。一个是“库伯勒—罗丝改变曲线”（Kübler-Ross change curve），一个是“新生事物的发展过程”（Transition Curve）。</p></blockquote><p><img src="http://sinacloud.net/blog-image/change-curve.jpeg" alt="&quot;库伯勒—罗丝改变曲线&quot;">  </p><p><img src="http://sinacloud.net/blog-image/transition-curve.jpeg" alt="&quot;新生事物的发展过程&quot;"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在的A股上证指数2485点，看本文最下方的图，正处于“人心惶惶”的阶段。&lt;/p&gt;
&lt;p&gt;在《韭菜的自我修养》这本书里，我觉得非常好的一个点是“周期”。&lt;/p&gt;
&lt;p&gt;我们一开始进场，都会像书中描述的那样“进场就买买买”，只考虑短期未来的趋势是怎样（涨或跌）。我买股票的时间
      
    
    </summary>
    
    
      <category term="reading" scheme="http://wuyuying.com/tags/reading/"/>
    
      <category term="investing" scheme="http://wuyuying.com/tags/investing/"/>
    
      <category term="李笑来" scheme="http://wuyuying.com/tags/%E6%9D%8E%E7%AC%91%E6%9D%A5/"/>
    
      <category term="区块链" scheme="http://wuyuying.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="比特币" scheme="http://wuyuying.com/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>AB Testing是如何提升用户体验的</title>
    <link href="http://wuyuying.com/archives/improve-ue-with-ab-testing/"/>
    <id>http://wuyuying.com/archives/improve-ue-with-ab-testing/</id>
    <published>2018-09-16T09:06:07.000Z</published>
    <updated>2019-02-04T10:43:04.743Z</updated>
    
    <content type="html"><![CDATA[<h2 id="三种基于数据的决策模式"><a href="#三种基于数据的决策模式" class="headerlink" title="三种基于数据的决策模式"></a>三种基于数据的决策模式</h2><ul><li>data driven</li><li>data informed</li><li>data aware（本书提出）</li></ul><p><img src="http://sinacloud.net/blog-image/data-driven-types.png" alt="&quot;三种数据决策模式&quot;"></p><h3 id="Data-driven-Design"><a href="#Data-driven-Design" class="headerlink" title="Data-driven Design"></a>Data-driven Design</h3><p><strong>数据驱动</strong>（data-driven）意味着收集到的数据决定（驱动）了设计的决策。在某些场景下，这是非常对的方式。而有些时候，团队提出的问题可以被通过实验得到的数据回答，这些数据集可以得出一个清晰的设计的最佳实践。</p><p>如果你清楚知道你要解决什么问题，目标是什么，确切知道自己想了解的问题是什么，那么数据驱动是合适的方式。还有另外一个前提，你的方法论和衡量方式是正确的，而你想要解决的问题是对应的数据能驱动做出决策的。这要求你对数据有可能带来的隐患有清晰的认知，然后采取相应的对策去解决它们。</p><blockquote><p>对于data driven模式，比较恰当的比喻是一辆在轨道上的火车。你知道自己离目的地越来越近，这段旅程是可靠的，你想要追寻的东西是明确的、直接的、可预判的以及可复制的。</p></blockquote><p><img src="http://sinacloud.net/blog-image/data-driven.jpg" alt="&quot;data driven&quot;"></p><h3 id="Data-informed-Design"><a href="#Data-informed-Design" class="headerlink" title="Data-informed Design"></a>Data-informed Design</h3><p>然而，在一些情况下，你的设计觉有可能有各种各样的细微差异，以及数据带来的答案，有可能不能覆盖所有的情况（not cut-and-dried）。这就是<strong>数据启示</strong>（data-informed）设计模式，团队只把数据作为决策过程的其中一项输入源。在这种设计模式下，输出也许不是一个明确的决策，但这也许会影响到下一个迭代和投入的立项。这样的方式适用的场景包括，需要做很多的资料搜集、需要结合不同类型的数据来源，以及在做一次跳跃性的项目创新。</p><blockquote><p>对于data-informed模式，比较恰当的比喻是一个火车站。你知道有各种各样的火车，它们是去不同的地方的。你知道自己可以有很多的选择，有一些途径可以帮助你找到想上哪一辆车。在最后你有可能去到不同的目的地，有着更少的确定性和更多探索的可能性。</p></blockquote><p><img src="http://sinacloud.net/blog-image/data-informed.jpg" alt="&quot;data informed&quot;"></p><h3 id="Data-aware-Design"><a href="#Data-aware-Design" class="headerlink" title="Data-aware Design"></a>Data-aware Design</h3><p>数据洞察（data-aware）设计模式，是一种创新的设计模式，设计的决策不仅仅来源于数据，而是回到数据收集方式的实践（系统是怎么产生的？数据类型是怎么捕获？数据是怎么合成的？），这才是设计本身要关注的问题。</p><p>在数据洞察设计模式的观念中，你要了解一些现实，不同类型的数据可以是很多不同的问题的答案。如果你意识到，多种类型的解决方案可以回答你的大目标，那么你也会意识到所有不同类型的数据可以为你所用。你在持续地提问怎么样你才能最好的实现目标。这是一种更有策略的思考方式，数据可以怎么样启发你想要解决的问题。再次说明，在你没有做好数据洞察之前，你是没法直接到达“数据启示”阶段的。</p><blockquote><p>地图（mapping）、运输系统（transportation）、导航（navigation）可能会更接近data-aware模式。火车只是在大陆上跑的一种方式，而你拥有整个世界去探索。</p></blockquote><p><img src="http://sinacloud.net/blog-image/data-aware.jpg" alt="&quot;data aware&quot;"></p><h2 id="书摘"><a href="#书摘" class="headerlink" title="书摘"></a>书摘</h2><h3 id="1-数据可以帮助设计与商业对焦"><a href="#1-数据可以帮助设计与商业对焦" class="headerlink" title="1.数据可以帮助设计与商业对焦"></a>1.数据可以帮助设计与商业对焦</h3><blockquote><p>设计与商业目标间的碰撞，如果可以建立基准对齐两者的目标，那是个非常棒的主意，聚焦在各类商业模型的核心部分：给你的客户提供最优质的服务，了解他们的目标和关注点，帮助解决他们的难题。</p></blockquote><h3 id="2-关于数据的质量"><a href="#2-关于数据的质量" class="headerlink" title="2. 关于数据的质量"></a>2. 关于数据的质量</h3><p>什么样的数据才可以指导我们的决策？</p><ul><li>问题关联性（我们在问对的问题吗？）</li><li>数据的合适度（它们可以回答我们的问题吗？）</li><li>数据的质量（数据可靠吗？我们在数据收集时有漏掉什么吗？我们对数据的认知有偏差吗？）</li></ul><p>做到上述的点，还需要我们回答下面的问题：</p><ul><li>另外不同的数据集或者不同的分析方法会更合适吗？</li><li>我们在做最方便的事情，还是在做对的事情？</li></ul><h3 id="3-做数据收集-分析时，我们需要谁的帮助"><a href="#3-做数据收集-分析时，我们需要谁的帮助" class="headerlink" title="3. 做数据收集/分析时，我们需要谁的帮助"></a>3. 做数据收集/分析时，我们需要谁的帮助</h3><p>在数据收集/分析的过程中，有两个关键的角色。</p><ul><li>第一，捕获、管理和分析数据，让它变得“可解释”（interpretable）；</li><li>第二，通过多种方式分析和使用数据，展现你的洞察力，找到其中与商业相关的信息。</li></ul><p>前者负责收集数据的，我们称之为“生产者”（producer）。后者依赖数据启发他们的思考的，我们称之为“消费者”(consumer)。</p><p><strong>谁是数据的生产者？</strong></p><p>数据分析师（data analysts）和数据科学家（data scientists），从产品中捕获大量的数据，对数据进行清洗、加工、转换、建模和验证。而数据科学家还会负责商业或用户的模型和计量方式。另外，他们也会做A/B测试的结果分析，你会惊讶于他们对历史做过的实践了如指掌，可以在如何建立A/B测试给你提供很有帮助的建议。</p><p>用户研究员（user researcher），专注于了解你的用户是谁以及他们需要什么。</p><p>设计师（Designer），设计师会在设计时，把自己代入到用户的角色，收集尽量多的信息去完成他们的设计。</p><p>市场营销人员（Marketer）。如果你想得到用户画像和目标人群的专业意见，可以问问做市场营销的同学，他们是离用户最近的人。</p><p><strong>谁是数据的消费者？</strong></p><p>数据的消费者包括商业经理、产品经理，、设计师等等。</p><p>商业经理（business manager）和产品经理（product manager），通过数据了解商业是如何运作的，得到更强的商业洞察力。</p><h3 id="4-数据的多样性"><a href="#4-数据的多样性" class="headerlink" title="4. 数据的多样性"></a>4. 数据的多样性</h3><p>最好的数据，就是对你想问的问题或者话题，提供最有用和最相关的信息。</p><h4 id="为什么你在收集数据？"><a href="#为什么你在收集数据？" class="headerlink" title="为什么你在收集数据？"></a>为什么你在收集数据？</h4><p>只观察用户的行为并不能告诉你用户做过些什么或者他们有怎样的感受。</p><p>你也应该关注用户的态度和期望。</p><h4 id="什么时候收集数据？"><a href="#什么时候收集数据？" class="headerlink" title="什么时候收集数据？"></a>什么时候收集数据？</h4><p>如果纵向的数据像一段影片，那么快照数据就像一张照片。</p><p>独立地收集数据可以帮助控制中间可能影响到用户和网站交互的因子。而场景化的数据则可以知道你的设计是如何“野蛮生长”的，你的设计有可能感受到来自这个世界的混乱、困难的挑战以及不符合常规的交互路径。</p><h4 id="数据是怎么收集的？"><a href="#数据是怎么收集的？" class="headerlink" title="数据是怎么收集的？"></a>数据是怎么收集的？</h4><p>在设计过程中，定性的数据帮助建立用户的同理心，能让你知道用户的态度、信仰、价值观和需求。相对地，定量的数据通过数字和度量来表现你的观察。</p><h4 id="收集多少数据？"><a href="#收集多少数据？" class="headerlink" title="收集多少数据？"></a>收集多少数据？</h4><p>超过85%的可用性问题只需要5位候选人。</p><p>而从很多候选人收集到的数据（通常叫“大样本采集”）可以给你更精确的数量和频率信息：有多少人的行为模式类似，多少百分比的用户会做这个操作，等等。</p><h3 id="5-为什么要做实验"><a href="#5-为什么要做实验" class="headerlink" title="5. 为什么要做实验"></a>5. 为什么要做实验</h3><p>做实验可以帮助我们了解因果关系（causality），以一种有数据支撑的而不是道听途说的，这具有“统计意义”。</p><p>A/B测试和实验的力量，在于这提供了一种可以控制环境的方式，让我们知道为什么某些事情会发生。换言之，它给我们提供了证明因果关系的能力。</p><p>这也让我们自信和清楚地知道，我们的决策是如何影响到用户的行为的。</p><p>更重要的是，我们可以以此保护自己，不要被人的天性，以一定的模式分析数据和行为，验证我们之前的猜想。（心理学家称之为“确认偏误”（confirmation bias）[确认偏误或称肯证偏误、验证性偏见，是个人无论合乎事实与否，偏好支持自己的成见、猜想的倾向。]）。在一个未被证明的假设上，还可以降低投入大量的时间和公司资源的风险。</p><p>我们鼓励大家思考那些道听途说的消息的限制，去问一些问题可以帮助你对听到的消息进行一些思想碰撞（反例）。</p><p>A/B测试是一项基于观察和行为科学的方法，需要大量收集用户的上下文数据。这意味着，只要我们把测试设计得很棒，我们就可以非常有自信地认为，A/B测试的验证结果会大流量的现实结果形成镜面效应，在A/B测试中更好的效果，假如我们把产品推向更多的用户，结果也是一致的。</p><p>这样的能力对于data aware决策/预测“什么会发生”是非常有价值的。你的公司会节省更多的时间和资源，放到效果好的项目上，同时会把那些效果不好或者没有引出目标用户行为的项目重新设计、重新思考甚至干掉。</p><h3 id="实验基础"><a href="#实验基础" class="headerlink" title="实验基础"></a>实验基础</h3><p>实验，就是一种通过收集信息对想法和现实进行对比的手段。</p><p>实验组一般是一个对照组（可控组）加上一些变化。</p><p>在设计一个实验时，你会对这个改变可能会造成什么效果做一个假设或者一个可测试的预测。基于你的观察结果，你会决定这证实了还是推翻了原先的假设。</p><p>跟一般我们使用数据的目标是类似的，每个实验的目标是从中学到些什么（得到些什么经验）。</p><blockquote><p>变量（variable）<br>自变量（independent variable）指的是你直接造成的改变，为了观察因变量（dependent variable）的变化。</p></blockquote><blockquote><p>混淆（confounds）<br>之所以实验中会有混淆，是我们在设计实验时没有考虑到某些因子会造成实验组和对照组的差异。</p></blockquote><h3 id="A-B测试：线上实验"><a href="#A-B测试：线上实验" class="headerlink" title="A/B测试：线上实验"></a>A/B测试：线上实验</h3><h4 id="用户划分"><a href="#用户划分" class="headerlink" title="用户划分"></a>用户划分</h4><p>一个cohort（cohort analysis，阵列分析，又称“世代分析”）指一群有相似经验的用户。这里的经验一般是基于时间的（如他们都是同一时间注册你的产品或者服务），或者他们有另外一个因素可以让他们有一样的经历（如学生是从2015年毕业的）。</p><p>另外一种方式，用户区隔（segment），基于更稳定的特性如人口统计因子（性别、年龄、国籍等）或者也可以通过他们的行为（新用户、核心用户等）。</p><h4 id="新用户-VS-老用户"><a href="#新用户-VS-老用户" class="headerlink" title="新用户 VS 老用户"></a>新用户 VS 老用户</h4><p>当你给用户介绍一些新的产品或服务时，老用户已有的习惯和行为会影响他们的思考方式和期望值。当我们对老用户测试一项新的设计方案时，以上是需要重点考虑的。</p><p>而新用户则没有各种各样的老习惯，他们也许会绕过各种既定的流程，希望直接去到他们想去的地方。</p><p>除了用户习惯，你也需要考虑老用户和未来会成为用户的那些人的用户画像有何异同。</p><blockquote><p>小结，在这一节里，介绍了在A/B取样时需要考虑的3个点。</p><ol><li>如何划分用户群，世代（cohorts）还是区隔（segment）</li><li>哪些用户信息是相关的</li><li>更偏向研究老用户还是新用户</li></ol></blockquote><h3 id="指标：A-B-Testing中的因变量"><a href="#指标：A-B-Testing中的因变量" class="headerlink" title="指标：A/B Testing中的因变量"></a>指标：A/B Testing中的因变量</h3><p><strong>测量（measure）</strong>，指的是你观察、捕获和计算的所有东西。<br><strong>指标（metrics）</strong>，指的是事先设定的、可评估的基准，同时这些指标会有一定的商业价值。</p><p>在A/B测试的设计中，认真思考选择测量什么指标是非常重要的一个环节 —— 追踪什么数据、测试什么时候结束。</p><p>测量计划的设定是主观的。有人决定了测试什么指标，怎么样去测试以及如何建立模型。因此，所有数据是受人们主观的认知偏误影响的。</p><p>A/B测试设计的另外一个环节是确定你对测试结果的容错程度。假如你的测试结果5%会出错？10%呢？20%又如何？只有你和你的同事能决定多大的风险你们愿意承担。</p><h3 id="你的假设和为什么它很重要"><a href="#你的假设和为什么它很重要" class="headerlink" title="你的假设和为什么它很重要"></a>你的假设和为什么它很重要</h3><p>假设，指的是你对实验结果的想象的预测，而它是可测试的。</p><p>设定一个假设，决定了你会从测试中学到什么。</p><p>你永远不能证明一个假设是正确的，你只能证明（什么情况下）它是错误的。</p><blockquote><p>No matter how numerous; for any conclusion drawn in this way may always turn out to be false: no matter how many instances of white swans we may have observed, this does not justify the conclusion that all swans are white… but it can be shown false by a single authentic sighting of a black swan. - Karl Popper</p></blockquote><p>你的假设应该是一个声明，在一个特定的环境下，你相信什么会发生。它往往是这样的，<code>如果我们做X，因为Z，用户会做Y，这会影响到指标A。</code></p><p>为了强调学习是我们做A/B实验的重点，我们鼓励你想清楚自己会从每一个测试中学习到什么。</p><p>在起草一个假设前，你应该明确两点：</p><ul><li>一个假设，在这个假设中本质上的改变是什么，你认为效果是怎样的？</li><li>一个明确的认知和计划，说明你会在测试这个假设时学到了什么。</li></ul><h4 id="知道你想学习什么"><a href="#知道你想学习什么" class="headerlink" title="知道你想学习什么"></a>知道你想学习什么</h4><ul><li>如果你失败了，对于未来的设计，你会学习到什么？</li><li>如果你成功了，对于未来的设计，你会学习到什么？</li><li>你愿意付出多少努力，去学习到这些东西？</li></ul><h3 id="创造性的A-B测试跑起来"><a href="#创造性的A-B测试跑起来" class="headerlink" title="创造性的A/B测试跑起来"></a>创造性的A/B测试跑起来</h3><h4 id="资料三角测定（data-triangulation）：混合方法的力量"><a href="#资料三角测定（data-triangulation）：混合方法的力量" class="headerlink" title="资料三角测定（data triangulation）：混合方法的力量"></a>资料三角测定（data triangulation）：混合方法的力量</h4><p>我们坚信，做A/B实验最好的方式，就是同时做A/B实验以外的事情。多种混合的方法，是获取更全面的用户画像以及知道你的设计是如何影响他们的唯一途径。况且，使用不同种类的数据可以启发出更多新的实现或者A/B测试的假设。使用其他形式的数据，换句话说，是一种能启发出更具创造性A/B实验的方式。</p><p>资料三角测定，可以使用多种方法去形成针对你的用户和数据更全面的大图。解释说明为什么你从很多用户中的A/B测试结果发现假设是正确的，从一个小样本的发现的重要性，中等量级的调研行为更像是可用性测试，这些都可以帮助你提升对用户行为的理解。</p><h4 id="探索和评估你的创意"><a href="#探索和评估你的创意" class="headerlink" title="探索和评估你的创意"></a>探索和评估你的创意</h4><p>A/B实验不仅仅为了那些很小的优化问题，它也能帮助你在从来没有涉足过的领域有全新的理解。</p><p>在探索阶段，A/B实验的结果不能决定最终谁是最好的设计，继续往前走。此外，你应该从实验中学习到什么，并应用到未来的设计中，继续迭代，做更多的A/B实验。</p><p>在评估阶段，你应该离一个“希望推送给用户的完成的作品”越来越近，在这个时候，你和你的团队应该对焦过，针对你的产品做一些细调（tweaks）和打磨（polishing）。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://book.douban.com/subject/26588592/" target="_blank" rel="noopener">《Designing with Data》</a></li><li>业内A/B Test的产品：Skycanner的Dr Jekyll、LinkedIn的XCLNT、Esty的Catapult</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;三种基于数据的决策模式&quot;&gt;&lt;a href=&quot;#三种基于数据的决策模式&quot; class=&quot;headerlink&quot; title=&quot;三种基于数据的决策模式&quot;&gt;&lt;/a&gt;三种基于数据的决策模式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;data driven&lt;/li&gt;
&lt;li&gt;data in
      
    
    </summary>
    
    
      <category term="reading" scheme="http://wuyuying.com/tags/reading/"/>
    
      <category term="ab testing" scheme="http://wuyuying.com/tags/ab-testing/"/>
    
  </entry>
  
  <entry>
    <title>书摘-增长黑客</title>
    <link href="http://wuyuying.com/archives/growth-hacker/"/>
    <id>http://wuyuying.com/archives/growth-hacker/</id>
    <published>2018-08-26T12:55:09.000Z</published>
    <updated>2019-02-04T10:43:04.741Z</updated>
    
    <content type="html"><![CDATA[<p>增长黑客们试图用更聪明的方式解答产品得以增长的奥秘，并使之成为助力产品增长的长效机制。他们通常采用的手段包括A/B测试、搜索引擎优化、电子邮件召回、病毒营销等，而页面加载速度、注册转化率、E-mail到达水平、病毒因子这些指标成为他们日常关注的对象。</p><p>换句话说，<strong>增长黑客就是一群以数据驱动营销、以市场指导产品，通过技术化手段贯彻增长目标的人</strong>。</p><div class="hexo-tag-douban" style="position:relative;width:60%;border:1px solid #666;border-radius: 4px;margin:10px auto;padding: 10px;"><a href="https://book.douban.com/subject/26541801/" target="_blank" style="color: #666;display:block;"><img src="https://img1.doubanio.com/view/subject/m/public/s28369197.jpg?apikey=0e13da30b101d57c2a3b8e9213058074" alt="增长黑客" style="width: 135px; height: 192px; display:inline-block; margin-right: 14px;" referrerpolicy="no-referrer"><div class="info" style="display:inline-block; vertical-align: top;"><p style="margin:0; font-size: 14px;">书名：增长黑客</p><p style="margin:0; font-size: 14px;width:200px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;" title="电子工业出版社">出版社：电子工业出版社</p><p style="margin:0; font-size: 14px;">出版日期：2015-7-1</p><p style="margin:0; font-size: 14px;">作者：范冰</p><p style="margin:0; font-size: 14px;">出版年：2015-7-1</p><p style="margin:0; font-size: 14px;">定价：CNY 59.00</p></div></a><div style="background: url(https://img3.doubanio.com/pics/douban-icons/favicon_24x24.png);width: 24px;height: 24px;position: absolute;right: 10px;bottom: 10px;"></div><a href="https://github.com/YuyingWu/hexo-tag-douban" title="hexo-tag-douban" target="_blank" style="display:block;width:24px;height:24px;position: absolute; bottom:10px;right: 39px;"><img src="https://github.com/fluidicon.png" alt="" style="display:block;width:24px;height:24px;"></a></div><a id="more"></a><blockquote><p>在每一封用Hotmail发出的邮件末尾签名处，增加了一行附言：“我爱你。快来Hotmail申请你的免费邮箱。”（PS:I love you.Get your free E-mail at Hotmail.）这一改动在仅仅几个小时之后，使Hotmail的用户注册曲线发生了戏剧性的变化，原本无人问津的服务，开始以每天3000个新用户的速度增长。</p></blockquote><p>作为企业发展的助推者，增长黑客必须真正懂得产品的核心价值，能用最简单的语言描述这个产品是什么、解决什么问题，在此基础上清晰定位有关增长的问题，并寻求解答。</p><h2 id="一、增长黑客的崛起"><a href="#一、增长黑客的崛起" class="headerlink" title="一、增长黑客的崛起"></a>一、增长黑客的崛起</h2><p>为什么直到最近，“增长黑客”的概念才开始流行呢？</p><p>一方面，越来越多的第三方工具降低了初创团队的开发门槛，Google Analytics、Mixpanel等“即插即用”的服务只需开发者在程序/网页内嵌入几行代码，就能一条龙式地以低成本实现数据采集、渠道统计、设备追踪、用户使用行为分析等功能。初创企业再也无须抽调专门人力“重复发明轮子”，就能用最小的代价快速搭建和测试产品，获取影响产品性能的各项指标。配套工具的唾手可得，让初创团队得以着眼于产品增长本身。</p><p>另一方面，越来越多的行业巨头出于扩大市场份额、构建生态系统、完善配套服务、探索盈利途径等需要，建立了属于自己的开放生态，并发布了配套的API供开发者调用。开发者通过接入平台，能够直接调用平台的身份授权、用户关系、内容数据，以及计算能力。产业的融合为初创企业带来更多变革和创新机会，也为富于寻找增长点的增长黑客们提供了闪转腾挪的全新舞台。</p><h3 id="增长黑客与市场营销"><a href="#增长黑客与市场营销" class="headerlink" title="增长黑客与市场营销"></a>增长黑客与市场营销</h3><p>首次接触“增长黑客”概念的人，可能会将它与市场营销混淆。</p><h4 id="市场营销"><a href="#市场营销" class="headerlink" title="市场营销"></a>市场营销</h4><p>市场部的设立更适合有一定资源优势的企业，尤其是那些商业模式已得到验证、正在或已经建立了持久稳定的用户获取渠道，且能将成本压缩在合理范围内的较成熟企业。</p><h4 id="低成本的增长"><a href="#低成本的增长" class="headerlink" title="低成本的增长"></a>低成本的增长</h4><p>尚未建立起对市场足够了解的初创公司，一上来就狠狠砸钱并非明智之举。当务之急是引入增长黑客，通过测试取样、建模修正和无数的试验，去发现更多被低估的低成本的有效增长途径。任何一个关键环节都存在不断优化的可能性。</p><h3 id="谁更适合做增长黑客"><a href="#谁更适合做增长黑客" class="headerlink" title="谁更适合做增长黑客"></a>谁更适合做增长黑客</h3><p>从现有的发展情况看，<strong>工程师可能是最接近和容易成为增长黑客的一群人</strong>。因为从能力角度看，增长黑客不仅需要想法，更需要将想法落实到行动的能力，包括自研工具、采集样本、分析数据、大规模推广，光会纸上谈兵是行不通的。懂技术，未必能变成好的增长黑客，而倘若不懂技术，无异于刘姥姥进大观园。</p><p><strong>增长黑客的价值</strong>就是通过数据分析快速找到机会和问题，并迅速地设置各种规模的试验去验证，找到可持续的方法来增长。</p><h2 id="二、AARRR转化漏洞模型"><a href="#二、AARRR转化漏洞模型" class="headerlink" title="二、AARRR转化漏洞模型"></a>二、AARRR转化漏洞模型</h2><p><img src="http://sinacloud.net/woodysblog/img/AARRR.png" alt="&quot;AARRR model&quot;"></p><p>增长的对象不仅包含用户量的累加，更囊括了产品生命周期中各个阶段的重要指标。根据不同阶段用户参与行为的深度和类型，我们可以将增长目标拆分并概括为“AARRR”转化漏洞模型。</p><p>增长黑客的价值正是通过不断地“头脑风暴-排定优先级-测试-分析-常态化部署”来优化产品策略，减少这当中每个环节的不必要损耗，提高转化效率，从而不断扩大自己用户群体的数量和质量。</p><h3 id="1-Acquisition（获取用户）"><a href="#1-Acquisition（获取用户）" class="headerlink" title="1. Acquisition（获取用户）"></a>1. Acquisition（获取用户）</h3><p>获取用户，指让潜在用户首次接触到产品，或者可以更宽泛地理解为“吸引流量”、“用户量增长”。</p><h3 id="2-Activation（激发活跃）"><a href="#2-Activation（激发活跃）" class="headerlink" title="2. Activation（激发活跃）"></a>2. Activation（激发活跃）</h3><p>激发活跃，获取到用户后下一步是引导用户完成某些“指定动作”，使之成为长期活跃的忠实用户。</p><h3 id="3-Retention（提高留存）"><a href="#3-Retention（提高留存）" class="headerlink" title="3. Retention（提高留存）"></a>3. Retention（提高留存）</h3><p>提高留存，在解决了用户的活跃度问题后，另一个问题又冒了出来。用户来得快，走得也快。提高用户留存，是维持产品价值、延长生命周期的重要手段。</p><h3 id="4-Revenue（增加收入）"><a href="#4-Revenue（增加收入）" class="headerlink" title="4. Revenue（增加收入）"></a>4. Revenue（增加收入）</h3><p>在互联网行业，除了直接向用户收费，还可以通过广告展示、业务分成等方式向其他利益方收取费用。</p><h3 id="5-Referral（传播推荐）"><a href="#5-Referral（传播推荐）" class="headerlink" title="5. Referral（传播推荐）"></a>5. Referral（传播推荐）</h3><p>社交网络的兴起促成了基于用户关系的病毒传播，这是低成本推广产品的全新方式，运用妥当将可能引发奇妙的链式增长。</p><h2 id="三、Facebook用户增长的经验"><a href="#三、Facebook用户增长的经验" class="headerlink" title="三、Facebook用户增长的经验"></a>三、Facebook用户增长的经验</h2><p>安迪对于自己一手组建起来的Facebook用户增长团队所肩负的职责，总结为以下五点。</p><ul><li><strong>用户获取</strong> —— 用户增长团队内有一部分人负责互联网营销渠道，如SEO（Search Engine Optimization，搜索引擎优化）、PPC（Pay Per Click，点击付费广告）或是电子邮件广告等，每一项都包括一套极为缜密的优化流程；</li><li><strong>产品研发</strong> —— 用户增长团队的意见将指导产品研发的各个关键部分，例如登录页面、新用户引导流程、评论互动功能和支付系统等。基本上你能想到的任何地方都留下了用户增长团队的智慧成果；</li><li><strong>文化建设</strong> —— 团队文化对凝聚整个公司至关重要。用户增长团队协助树立数据驱动的理念，确保所有人目标一致地快速执行，并随时准备迎战风险；</li><li><strong>人才招聘</strong> —— 初创公司招募团队成员是一项困难的工作，并非人人都愿意冒险加入一家前途未卜的小公司。但在用户增长团队的帮助下，如果公司的用户量达到五千万甚至五亿，那么情况就大为不同了。</li></ul><p><strong>数据分析</strong> —— 用户增长团队建立在对大数据的分析衡量基础之上。</p><p>大部分时候，用户增长的工作就是在进行测试、调整并重复这个流程。他们需要与数据科学团队紧密协作，通过内部工具研究驱使数据提升或下降的因素。</p><p>进行数据分析的首要环节是<strong>明确分析的目的</strong>。脱离具体目标的单纯数据查看没有任何价值。其次是要<strong>了解数据来源的相关信息</strong>，包括各项指标的定义、采集点和上报机制。</p><blockquote><p>上报机制，数据上报的时机、内容和技术实现形式。<br>定性分析，就是对事物的性质作出判断，究竟它“是什么”。<br>定量分析，是指对事物的数量作出统计，衡量它“有多少”。</p></blockquote><p>数据分析就是定性分析与定量分析相互结合，不断验证的过程。提出假设、设计方案、分析数据、验证或推翻假设，最终抽丝剥茧，逐渐接近真相。数据是相互验证的，彼此之间有如通过无形的网络纵横连接，只需轻轻按动其中一个，就会驱使另外一个或一组产生变化。通过数据分析得出的结论，应当能反推出其他数据，或是与其他数据分析得出的结果相一致。</p><h2 id="四、创造正确的产品"><a href="#四、创造正确的产品" class="headerlink" title="四、创造正确的产品"></a>四、创造正确的产品</h2><h3 id="如何判断需求是否足够大"><a href="#如何判断需求是否足够大" class="headerlink" title="如何判断需求是否足够大"></a>如何判断需求是否足够大</h3><p>通常可采用两种方式。</p><p>一种是先估计目标用户的基数、消费能力、意愿预算，再把这些数字通过相乘等方式得出一个大概的数字，并与该行业或近似行业的公开报告进行比对验证；</p><p>另一种则是评估打算进入的市场，原本具有多少产值，而你的产品通过提供更低的价格、更长的使用周期等，能提升多少效率、节省多少成本，从而折算出相对于原产值的全新规模。</p><h3 id="最小化可行产品-MVP"><a href="#最小化可行产品-MVP" class="headerlink" title="最小化可行产品 MVP"></a>最小化可行产品 MVP</h3><p>《精益创业》中提出的“最小化可行产品（Minimum Viable Product，简称MVP）”概念。</p><h4 id="MVP三要素"><a href="#MVP三要素" class="headerlink" title="MVP三要素"></a>MVP三要素</h4><p>精益创业是指开发团队通过提供最小化可行产品获取用户反馈，在此基础上持续快速迭代（或谋求转型），直至产品达到PMF阶段。它包含如下三个要素。</p><ol><li>最小化可行产品：即所谓的MVP（Minimum Viable Product）是指将产品原型用最简洁的实现方式开发出来，过滤掉冗余杂音和高级特性，快速投放市场让目标用户上手使用，然后通过不断地听取反馈掌握有价值的信息，由此对产品原型迭代优化，尽早达到PMF状态；</li><li>用户反馈：指通过直接或间接方式，从产品的最终用户那里获得针对该产品的意见；</li><li>快速迭代：“天下武功，唯快不破”。</li></ol><h4 id="MVP的三大必备模块"><a href="#MVP的三大必备模块" class="headerlink" title="MVP的三大必备模块"></a>MVP的三大必备模块</h4><p>如果问开发一个MVP必须具备哪些模块，那么我会不假思索地告诉你：除了待验证的基本功能外，反馈渠道、公告看板、自动升级和使用行为统计这四件事必须纳入考量。</p><h2 id="五、获取用户"><a href="#五、获取用户" class="headerlink" title="五、获取用户"></a>五、获取用户</h2><h3 id="种子用户"><a href="#种子用户" class="headerlink" title="种子用户"></a>种子用户</h3><p><strong>“冷启动”</strong>原本是数据挖掘领域的一个专业术语，运用到产品运营中，指在产品之初尚未形成完善的生态体系并能提供足够多可消费内容的情况下，从零开始导入第一批用户和制造内容的过程。选择高质量的早期用户加入和建立充足的数据沉淀，将可作为引燃产品持续增长的燎原之火，为日后发展奠定良好基础。</p><p>种子用户的三层含义：</p><ol><li>这批人数量少，获取不易；</li><li>他们进入产品的阶段较早；</li><li>种子用户如同种子一样孕育着希望，具有成长为参天大树的可能性。</li></ol><h3 id="走访和了解用户"><a href="#走访和了解用户" class="headerlink" title="走访和了解用户"></a>走访和了解用户</h3><p>走访和了解用户，掌握真实需求，是一件复杂困难的事情。就像1000个人心中有1000个哈姆雷特一样，不同人对产品的需求和评判标准不尽相同。从最笨的事情做起的过程，同时也是走进用户内心的过程。将用户视作活生生的个体，通过面对面的沟通，吸纳意见并获得鼓舞，帮助许多初创公司走过了从零开始举步维艰的阶段。</p><h3 id="内容营销"><a href="#内容营销" class="headerlink" title="内容营销"></a>内容营销</h3><p>内容营销的作用主要分为三方面：</p><ul><li>吸引流量</li><li>培养潜在用户</li><li>劝诱转化</li></ul><p>内容营销的注意事项：</p><ol><li>知道你的目标受众是谁</li><li>打造一台内容持续输出的引擎</li><li>撰写耸动的标题</li><li>保证文章长度</li><li>鼓励受众参与互动</li><li>选择合适的发布渠道</li></ol><p>有了足够可写的内容素材后，文章的谋篇布局可以遵循以下顺序：简要概述→话题事件→核心特色→主要功能→团队访谈→未来计划→有奖活动→转化引导。</p><h2 id="六、A-B测试"><a href="#六、A-B测试" class="headerlink" title="六、A/B测试"></a>六、A/B测试</h2><h3 id="A-B测试的基本思想"><a href="#A-B测试的基本思想" class="headerlink" title="A/B测试的基本思想"></a>A/B测试的基本思想</h3><ul><li>提供两个方案并行测试；</li><li>不同方案之间只存在一个变量，排除其他干扰因素；</li><li>以某种标准判定结果优劣，筛出最优方案。</li></ul><blockquote><p>Airbnb曾测试过把“保存到心愿单”的收藏图标由星形改为爱心，结果仅凭这一改动就让心愿列表的使用率提升了30%。</p></blockquote><h3 id="A-B的成本"><a href="#A-B的成本" class="headerlink" title="A/B的成本"></a>A/B的成本</h3><p>谷歌为了找出在两种蓝色方案中哪一种更好，索性测试了41种不同的蓝色来做比较。对与时间赛跑的创业团队而言，这样的精力付出简直太过奢侈。如果你的产品还没达到零点几个百分比的下降都意味着几百万美元损失的地步的话，还是多花些时间在那些真正有跃进式提升的地方吧。</p><h2 id="七、留存"><a href="#七、留存" class="headerlink" title="七、留存"></a>七、留存</h2><blockquote><p>“当陪你的人要下车时，即使不舍，也该心存感激，然后挥手道别。”——《千与千寻》，宫崎骏</p></blockquote><p>根据美国贝恩公司的调查，在商业社会中5%的客户留存率增长意味着公司利润30%的增长，而把产品卖给老客户的概率是卖给新客户的3倍。所以在“增长黑客”圈内有一句名言：留住已有的用户胜过拓展新的客户。也就是俗称的“一鸟在手，胜过双鸟在林”。</p><h3 id="留存率低的原因"><a href="#留存率低的原因" class="headerlink" title="留存率低的原因"></a>留存率低的原因</h3><ol><li>存在程序漏洞、性能瓶颈</li><li>用户被频繁骚扰</li><li>话题产品的热度减退</li><li>有更好的替代品</li><li>其他因素如游戏通关、设备遗失、需求不再存在、产品生命周期终结等，都可能成为用户流失的因素</li></ol><blockquote><p>Pinterest也采取了与Twitter类似的做法，先让新用户有事可做。很快，这些测试用户发现他们的账号被安排订阅了一批系统推荐的账号，页面中顿时充满了令人赏心悦目的花卉文玩、服装穿搭、艺术家居和风景摄影。</p></blockquote><h3 id="留存率衡量指标"><a href="#留存率衡量指标" class="headerlink" title="留存率衡量指标"></a>留存率衡量指标</h3><p>留存率的衡量衡量产品留存率的常用指标包括<strong>次日留存率、7日留存（周留存）率、30日留存（月留存）率</strong>，其计算公式为：第1天的新增用户中，在往后的第N天依然在使用的用户数/第1天的新增用户数。其中的N对应的就是留存指标中代表天数的2、7或30。</p><ul><li>次日留存率：关注产品的次日留存率，可于第一时间发现产品新版本的品质变动和渠道优劣；</li><li>7日留存：可反映出用户完成一个完整体验周期后的去留状况；</li><li>30日留存，更能反映出一次版本迭代后的稳定性，辅助判断产品的演进方向是否合理。</li></ul><p>除了按照不同天数周期来比较留存率外，<strong>渠道留存</strong>也是一项值得钻研玩味的指标。由于渠道来源不一，用户质量也千差万别，所以有必要针对渠道用户单独剥离进行留存率分析，选择留存率较高的优质渠道进行重点投放。</p><h3 id="有损服务"><a href="#有损服务" class="headerlink" title="有损服务"></a>有损服务</h3><p>有损服务，顾名思义是指刻意输出在品质上存在某些损失的服务，目的是以此牺牲换取其他方面（速度、稳定性、成功执行的几率）的优化。</p><p>在实施有损服务的方案时，有两条基本原则：1）发生问题时，优先保证核心功能的运转，非核心功能不可以影响核心功能；2）在条件允许的情况下，牺牲的特性越少越好。</p><h3 id="唤醒机制"><a href="#唤醒机制" class="headerlink" title="唤醒机制"></a>唤醒机制</h3><p>唤醒机制是指互联网产品中专为召回流失用户而设计的产品机制。</p><p>常用的唤醒机制包括：</p><ul><li>电子邮件唤醒</li><li>消息推送通知</li><li>移动网页唤醒应用</li><li>其他</li></ul><p>推送通知的通常用法，考验的是运营人员的基本功，即如何筛选合适的推送人群、根据使用场景和时间段制定推送内容、制作和优化推送到达的着陆页。根据目标人群的使用场景，推送符合其兴趣和需要的优质内容，就能带来更高的黏性。</p><h2 id="八、增加收入"><a href="#八、增加收入" class="headerlink" title="八、增加收入"></a>八、增加收入</h2><p>免费模式如何赚钱？</p><ol><li>基本功能免费，高级功能收费的Freemium策略；</li><li>交叉补贴交叉补贴策略，思路是通过有意识地以优惠甚至亏本的价格出售一种产品（称为“优惠产品”），从而达到促进销售另一种盈利更多的产品（称为“盈利产品”）；</li><li>三方市场的流量变现“当你在使用免费服务时，你自己就是商品。” 的确，免费的流量本身不会凭空变出钱来，但如果将这批流量导入另一项服务，或许就能麻雀变凤凰，攫取出更大价值；</li></ol><h2 id="九、病毒传播"><a href="#九、病毒传播" class="headerlink" title="九、病毒传播"></a>九、病毒传播</h2><p>《引爆点》的作者马尔科姆将引爆流行的要素总结为个别人物法则、附着力法则和环境威力法则。他认为，本身就认识很多人且对他人有一定影响力的那些人，在传播中充当了关键性节点的角色，在他们的助力下，原本容易被注意、感知和记忆的信息更容易抵达受众的面前，并在一定的外部环境催化下，成为一股流行趋势。</p><h3 id="衡量指标"><a href="#衡量指标" class="headerlink" title="衡量指标"></a>衡量指标</h3><p>衡量病毒传播的两大核心指标是K因子（K Factor）和病毒循环周期（Virial Cycle Time）。</p><ol><li><strong>K因子</strong>，用于评判病毒传播的覆盖面。其公式为：K因子=感染率X转化率；</li><li><strong>病毒循环周期</strong>，是指从用户发出病毒邀请，到新用户完成转化（如点击阅读、注册、消费的行为）所花费的时间。</li></ol><h3 id="传播心理学"><a href="#传播心理学" class="headerlink" title="传播心理学"></a>传播心理学</h3><p>互联网是人性的试炼场，互联网产品的病毒传播策略如果能把握群体心理中的一些特征共性，就能从深层次激发人们的传播动力。</p><ol><li>喜爱。人们总是比较愿意答应自己认识和喜欢的人提出的请求，还乐意主动传播自己喜爱的事物，借以表达一种倾向，阐发一种观点，寻求志同道合的伙伴，融入有归属感的圈子。</li><li>逐利：天下熙熙皆为利来，天下攘攘皆为利往。有时候，简单粗暴的利益交换，能换来立竿见影的传播效果。</li><li>互惠：基于理性经济人假说的传统经济学认为，经济行为主体是单纯追求个人利益最大化的，人们的复杂行为和社会参与，都是基于成本收益的计算。互惠是逐利的一种变体，是人类社会日常交际的基础。</li><li>求助</li><li>炫耀：爱炫耀是人的内心渴求被关注被肯定的表现，人们喜欢通过炫耀来展示自己最好的一面，或是借以表达自己理想中的状态。从深层次讲，人类之所以对炫耀乐此不疲，是因为它在某种程度上能够产生权利的幻觉，让身处竞争压力中的个体感觉更好一些，以及在择偶中占据优势。</li><li>稀缺：稀缺资源引发人们的好奇争抢，而邀请机制则将病毒传播的效果成倍放大。</li><li>害怕失去或错过</li><li>懒惰：人天生是懒惰的。当产生分享传播的冲动时，如果需要用户费事打开操作网页、编写一套原创说辞，操作成本过高，无形之中会将一部分人阻拦在外。作为产品开发者，应当充分利用人们懒惰的心理，提供便利的分享方式，如一键分享按钮、跳转手机客户端直接获取身份认证等。</li></ol><blockquote><h2 id="移动导购社区产品规律。"><a href="#移动导购社区产品规律。" class="headerlink" title="移动导购社区产品规律。"></a>移动导购社区产品规律。</h2><ol><li>几种平台的终端用户中，使用手机网页版访问的小白用户居多，看到便宜东西容易冲动消费；iPhone用户消费能力强，对价格不太敏感；安卓用户最抠门，消费不多，但广告的点击率却是iPhone用户的几倍，呈现出一种“啥都好奇，啥都试试，但就是不买单”的状况。</li><li>女性导购类社区需要立足高端机型。iPad用户的购买力最强，低端机型碍于屏幕尺寸限制，导购体验很难做好。</li><li>在用户构成上，使用2000元以上机型的用户占据80%, iOS用户和安卓整体接近，但前者的总收入是后者的2至2.5倍。</li><li>在用户的行为数据中，最喜欢的动作是“喜欢”，收藏起来自己欣赏，日均点击数达到百万次。对比之下利他的“分享”则点击比较少。</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;增长黑客们试图用更聪明的方式解答产品得以增长的奥秘，并使之成为助力产品增长的长效机制。他们通常采用的手段包括A/B测试、搜索引擎优化、电子邮件召回、病毒营销等，而页面加载速度、注册转化率、E-mail到达水平、病毒因子这些指标成为他们日常关注的对象。&lt;/p&gt;
&lt;p&gt;换句话说，&lt;strong&gt;增长黑客就是一群以数据驱动营销、以市场指导产品，通过技术化手段贯彻增长目标的人&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&quot;hexo-tag-douban&quot; style=&quot;position:relative;width:60%;border:1px solid #666;border-radius: 4px;margin:10px auto;padding: 10px;&quot;&gt;&lt;a href=&quot;https://book.douban.com/subject/26541801/&quot; target=&quot;_blank&quot; style=&quot;color: #666;display:block;&quot;&gt;&lt;img src=&quot;https://img1.doubanio.com/view/subject/m/public/s28369197.jpg?apikey=0e13da30b101d57c2a3b8e9213058074&quot; alt=&quot;增长黑客&quot; style=&quot;width: 135px; height: 192px; display:inline-block; margin-right: 14px;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;div class=&quot;info&quot; style=&quot;display:inline-block; vertical-align: top;&quot;&gt;&lt;p style=&quot;margin:0; font-size: 14px;&quot;&gt;书名：增长黑客&lt;/p&gt;&lt;p style=&quot;margin:0; font-size: 14px;width:200px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;&quot; title=&quot;电子工业出版社&quot;&gt;出版社：电子工业出版社&lt;/p&gt;&lt;p style=&quot;margin:0; font-size: 14px;&quot;&gt;出版日期：2015-7-1&lt;/p&gt;&lt;p style=&quot;margin:0; font-size: 14px;&quot;&gt;作者：范冰&lt;/p&gt;&lt;p style=&quot;margin:0; font-size: 14px;&quot;&gt;出版年：2015-7-1&lt;/p&gt;&lt;p style=&quot;margin:0; font-size: 14px;&quot;&gt;定价：CNY 59.00&lt;/p&gt;&lt;/div&gt;&lt;/a&gt;&lt;div style=&quot;background: url(https://img3.doubanio.com/pics/douban-icons/favicon_24x24.png);width: 24px;height: 24px;position: absolute;right: 10px;bottom: 10px;&quot;&gt;&lt;/div&gt;&lt;a href=&quot;https://github.com/YuyingWu/hexo-tag-douban&quot; title=&quot;hexo-tag-douban&quot; target=&quot;_blank&quot; style=&quot;display:block;width:24px;height:24px;position: absolute; bottom:10px;right: 39px;&quot;&gt;&lt;img src=&quot;https://github.com/fluidicon.png&quot; alt=&quot;&quot; style=&quot;display:block;width:24px;height:24px;&quot;&gt;&lt;/a&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="reading" scheme="http://wuyuying.com/tags/reading/"/>
    
      <category term="growth hacker" scheme="http://wuyuying.com/tags/growth-hacker/"/>
    
  </entry>
  
  <entry>
    <title>GraphQL in Action</title>
    <link href="http://wuyuying.com/archives/graphql-in-action/"/>
    <id>http://wuyuying.com/archives/graphql-in-action/</id>
    <published>2018-08-15T15:11:24.000Z</published>
    <updated>2018-09-24T10:26:46.510Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GraphQL解决什么问题"><a href="#GraphQL解决什么问题" class="headerlink" title="GraphQL解决什么问题"></a>GraphQL解决什么问题</h2><h3 id="REST-ful-Routing"><a href="#REST-ful-Routing" class="headerlink" title="REST-ful Routing"></a>REST-ful Routing</h3><p>Given a collection of records on a server, there should be a uniform URL and HTTP request method to utilize that collection of records.</p><p><img src="http://sinacloud.net/woodysblog/img/restful-api.png" alt=""></p><h3 id="GraphQL是如何解决问题的"><a href="#GraphQL是如何解决问题的" class="headerlink" title="GraphQL是如何解决问题的"></a>GraphQL是如何解决问题的</h3><p><img src="http://sinacloud.net/woodysblog/img/what-problem-GraphQL-solve.png" alt=""></p><p>在REST-ful API中，我们会一层一层地定义路由，但假如出现上图的多层结构，我们希望：</p><ul><li>查询“当前用户的所有朋友的公司名” <ul><li>利用当前用户查询朋友的userId，再用每个人的userId查询company <code>users/currentUserID/friends</code> -&gt; <code>users/friendUserID/company</code></li><li><code>users/currentUserID/friends/companies</code> </li></ul></li><li>获取”当前用户的所有朋友的公司名+位置“<ul><li><code>users/currentUserID/friends_with_position_and_company</code></li></ul></li></ul><p>有可能需要提供3个或更多不同的路由。</p><p>若是层级嵌套或组合更多，REST-ful的路由规则会越来越多和复杂，GraphQL就是解决这类问题的利器。</p><p><img src="http://sinacloud.net/woodysblog/img/graph.png" alt=""></p><p>Graph（图）表达了节点和节点间的Edges（路径）。</p><p>同样地要实现”获取当前用户的所有朋友的公司名+位置“，我们会这样告诉GraphQL：</p><ol><li>查询<code>userID</code>为<code>N</code>的当前用户<code>WYY</code></li><li>查询所有朋友为<code>WYY</code>的用户数组<code>X</code></li><li>查询每个<code>X</code>下的<code>company</code>和<code>position</code></li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">query&#123;</span><br><span class="line">  user(id: <span class="string">"N"</span>) &#123;</span><br><span class="line">    friends &#123;</span><br><span class="line">      company &#123;</span><br><span class="line">        name</span><br><span class="line">      &#125;</span><br><span class="line">      position &#123;</span><br><span class="line">        address</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GraphQL服务器作为代理层"><a href="#GraphQL服务器作为代理层" class="headerlink" title="GraphQL服务器作为代理层"></a>GraphQL服务器作为代理层</h2><h3 id="当数据库在自己的服务器"><a href="#当数据库在自己的服务器" class="headerlink" title="当数据库在自己的服务器"></a>当数据库在自己的服务器</h3><p><img src="http://sinacloud.net/woodysblog/img/graphql-as-proxy-1.png" alt=""></p><h3 id="当我们使用第三方数据源"><a href="#当我们使用第三方数据源" class="headerlink" title="当我们使用第三方数据源"></a>当我们使用第三方数据源</h3><p><img src="http://sinacloud.net/woodysblog/img/graphql-as-proxy-2.png" alt=""></p><h3 id="中间层：Express-GraphQL-Server"><a href="#中间层：Express-GraphQL-Server" class="headerlink" title="中间层：Express/GraphQL Server"></a>中间层：Express/GraphQL Server</h3><p>当我们的服务需要结合本地数据源和第三方数据源时，可以通过Express/GraphQL服务器统一处理数据源的聚合和结构抹平，再把api提供给前端应用使用。</p><h2 id="什么情况下，我们需要Resolver"><a href="#什么情况下，我们需要Resolver" class="headerlink" title="什么情况下，我们需要Resolver"></a>什么情况下，我们需要Resolver</h2><p><img src="http://sinacloud.net/woodysblog/img/what-resolver-does.png" alt=""></p><p>如上图，当数据库的model设计的字段<code>companyId</code>，和GraphQL的query需要获取的字段<code>companyName</code>不一致时，需要在GraphQLType定义字段<code>companyName</code>中添加对应的resolver，以入参<code>companyId</code>查询数据库中对应的项，再return对应<code>companyName</code>。</p><p>也就是说，当数据库model和GraphQL对象的字段对应不上，返回数据和入参需要特别处理时，<code>resolver</code>来完成这样的工作。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const <span class="type">UserType</span> = <span class="keyword">new</span> <span class="type">GraphQLObjectType</span>(&#123;</span><br><span class="line">  name: <span class="symbol">'Use</span>r',</span><br><span class="line">  fields: () =&gt; (&#123;</span><br><span class="line">    id: &#123; <span class="class"><span class="keyword">type</span></span>: <span class="type">GraphQLID</span> &#125;,</span><br><span class="line">    firstName: &#123; <span class="class"><span class="keyword">type</span></span>: <span class="type">GraphQLString</span> &#125;,</span><br><span class="line">    age: &#123; <span class="class"><span class="keyword">type</span></span>: <span class="type">GraphQLInt</span> &#125;,</span><br><span class="line">    company: &#123;</span><br><span class="line">      <span class="class"><span class="keyword">type</span></span>: <span class="keyword">new</span> <span class="type">GraphQLList</span>(<span class="type">CompanyType</span>),</span><br><span class="line">      resolve(parent, args) &#123;</span><br><span class="line">        <span class="comment">// code to get data from db / other source</span></span><br><span class="line">        <span class="comment">// args.id</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">CompanyDBModel</span>.find(&#123;</span><br><span class="line">          companyId: parent.companyId</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="DB-model和GraphQL的设计差异"><a href="#DB-model和GraphQL的设计差异" class="headerlink" title="DB model和GraphQL的设计差异"></a>DB model和GraphQL的设计差异</h2><p><img src="http://sinacloud.net/woodysblog/img/model-in-reality.png" alt=""></p><p>数据库中的表结构：<br><code>User</code>的属性<code>companyId</code>，关联着<code>Company</code>的<code>id</code>属性。</p><p><img src="http://sinacloud.net/woodysblog/img/query-in-graphql.png" alt=""></p><p>Graph（图）结构：  </p><ul><li>0级：RootQueryType，属性<code>user</code>类型为<code>UserType</code></li><li>1级：<code>UserType</code>通过数据库中的<code>companyId</code>查询到<code>company</code>的数据，再返回到<code>UserType.company</code></li></ul><h2 id="Query语法"><a href="#Query语法" class="headerlink" title="Query语法"></a>Query语法</h2><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  apple: company(<span class="name">id:</span> <span class="string">"1"</span>) &#123;</span><br><span class="line">    id</span><br><span class="line">  &#125;</span><br><span class="line">  google: compnay(<span class="name">id:</span> <span class="string">"2"</span>) &#123;</span><br><span class="line">    id</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求了两次company，入参id分别为1和2，返回结果是：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attribute">data</span>: &#123;</span><br><span class="line">    apple: &#123;</span><br><span class="line">      id: <span class="string">"1"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="selector-tag">google</span>: &#123;</span><br><span class="line">      <span class="attribute">id</span>: <span class="string">"2"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="query-fragment-查询片段"><a href="#query-fragment-查询片段" class="headerlink" title="query fragment 查询片段"></a>query fragment 查询片段</h3><p>有时候多个query会共享一些查询属性，如：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  apple: company(<span class="name">id:</span> <span class="string">"1"</span>) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    description</span><br><span class="line">  &#125;</span><br><span class="line">  google: compnay(<span class="name">id:</span> <span class="string">"2"</span>) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    description</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个query查询一致的字段（<code>id</code>、<code>name</code>、<code>desciption</code>），加入需要修改，需要多处修改。这个时候，我们可以声明一段query fragment，维护这份公用的query字段。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  apple: company(<span class="built_in">id</span>: <span class="string">"1"</span>) &#123;</span><br><span class="line">    ...companyFields</span><br><span class="line">  &#125;</span><br><span class="line">  google: compnay(<span class="built_in">id</span>: <span class="string">"2"</span>) &#123;</span><br><span class="line">    ...companyFields</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fragment companyFields <span class="keyword">on</span> Company &#123;</span><br><span class="line">  <span class="built_in">id</span></span><br><span class="line">  <span class="built_in">name</span></span><br><span class="line">  description</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>划重点：</p><ol><li>用关键字<code>fragment</code>声明查询片段<code>companyFields</code>；</li><li>关键字<code>on</code>后是GraphQLType<code>Company</code>，表明以下字段属于类型<code>Company</code>，GraphQL也会对这些字段作类型和是否存在的检查；</li><li>在query语句中，使用<code>...companyFields</code>。</li></ol><h2 id="当GraphQL遇到前端"><a href="#当GraphQL遇到前端" class="headerlink" title="当GraphQL遇到前端"></a>当GraphQL遇到前端</h2><p><img src="http://sinacloud.net/woodysblog/img/graph-come-across-frontend.png" alt=""></p><blockquote><p>DB -&gt; Express/GraphQL Server -&gt; GraphQL Client -&gt; ReactJS</p></blockquote><p>其中，GraphQL Client担当了类似GraphiQL的角色，把query转化为HTTP请求。</p><p>以下是几个GraphQL Client框架的介绍和对比。</p><p><img src="http://sinacloud.net/woodysblog/img/graphql-client.png" alt=""></p><p>下面的demo以Apollo为例。</p><h3 id="React应用接入Apollo"><a href="#React应用接入Apollo" class="headerlink" title="React应用接入Apollo"></a>React应用接入Apollo</h3><ol><li>创建一个<code>Apollo Client</code>对象（与server端相关GraphQL配置关联）；</li><li>引入<code>react-apollo</code>，类似Redux，把从服务器端获取的GraphQL相关请求的返回数据打进react组件的props中。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> ApolloClient <span class="keyword">from</span> <span class="string">'apollo-client'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ApolloProvider &#125; <span class="keyword">from</span> <span class="string">'react-apollo'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./compenents/App'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> client = <span class="keyword">new</span> ApolloClient(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Root = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ApolloProvider client=&#123;client&#125;&gt;</span><br><span class="line">      &lt;App /&gt;</span><br><span class="line">    &lt;<span class="regexp">/ApolloProvider&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;Root /</span>&gt;,</span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'#root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="在React组件中利用GraphQL查询数据"><a href="#在React组件中利用GraphQL查询数据" class="headerlink" title="在React组件中利用GraphQL查询数据"></a>在React组件中利用GraphQL查询数据</h3><blockquote><h4 id="graphql-tag"><a href="#graphql-tag" class="headerlink" title="graphql-tag"></a><a href="https://www.npmjs.com/package/graphql-tag" target="_blank" rel="noopener">graphql-tag</a></h4><p>把GraphQL的query字符串转化成GraphQL的AST。  </p><h4 id="React-Apollo"><a href="#React-Apollo" class="headerlink" title="React Apollo"></a><a href="https://s3.amazonaws.com/apollo-docs-1.x/index.html" target="_blank" rel="noopener">React Apollo</a></h4><p>基于Apollo Client，在react应用中管理服务器端GraphQL的数据。</p></blockquote><h4 id="数据请求"><a href="#数据请求" class="headerlink" title="数据请求"></a>数据请求</h4><ul><li>步骤一、引入了<code>graphql-tag</code>和<code>react-apollo</code>的<code>graphql</code></li><li>步骤二、查询songList数据的GraphQL query，在GraphiQL面板中调试query</li><li>步骤三、给组件打入基于这段query的数据管理，<code>graphql(query)(SongList)</code></li></ul><h4 id="数据返回（query）"><a href="#数据返回（query）" class="headerlink" title="数据返回（query）"></a>数据返回（query）</h4><p>Apollo帮我们做了请求和返回数据的事情，通过以上的连接，组件在加载时会基于那段query发一个请求，组件props的变化会有以下2个阶段。</p><ul><li>阶段一、请求发送开始。此时<code>this.props</code>的<code>data</code>就是Apollo更新的状态，其中有个<code>loading</code>字段，值为<code>true</code>，用于标记请求在发送中，但返回数据还没有回来。</li><li>阶段二、接收到请求数据。此时<code>loading</code>的值是<code>false</code>，且多了<code>songs</code>字段（我们在query中定义的结构），我们就可以根据返回值做我们想做的事情。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> gql <span class="keyword">from</span> <span class="string">'graphql-tag'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; graphql &#125; <span class="keyword">from</span> <span class="string">'react-apollo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SongList</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; data = &#123;&#125; &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">const</span> &#123; loading, songs &#125; = data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;song List&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        &lt;ul className="collection"&gt;</span></span><br><span class="line"><span class="regexp">          &#123; !loading &amp;&amp; songs.length ? songs.map(song =&gt; (</span></span><br><span class="line"><span class="regexp">            &lt;li className="collection-item" key=&#123;`song-$&#123;song.id&#125;`&#125;&gt;&#123; song.title &#125;&lt;/</span>li&gt;</span><br><span class="line">          )) : <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span> &#125;</span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> query = gql<span class="string">`</span></span><br><span class="line"><span class="string">  query &#123;</span></span><br><span class="line"><span class="string">    songs &#123;</span></span><br><span class="line"><span class="string">      title</span></span><br><span class="line"><span class="string">      id</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> graphql(query)(SongList);</span><br></pre></td></tr></table></figure><p>若query需要接收动态传入的参数，Apollo Clien支持对<code>query</code>传入<code>options</code>参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> graphql(query, &#123;</span><br><span class="line">  options: <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      variables: &#123;</span><br><span class="line">        songId: props.params.songId,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(Song);</span><br></pre></td></tr></table></figure><h3 id="当React遇上GraphQL-mutation"><a href="#当React遇上GraphQL-mutation" class="headerlink" title="当React遇上GraphQL mutation"></a>当React遇上GraphQL mutation</h3><p>query可以跟着组件的生命周期走，但是mutation很多时候是在用户跟页面有交互时才触发的，应该怎么在事件的回调函数中加入GraphQL mutation呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件中的click提交函数</span></span><br><span class="line">onSubmit() &#123;</span><br><span class="line">  <span class="keyword">const</span> value = <span class="keyword">this</span>.element.value;</span><br><span class="line">  <span class="keyword">const</span> &#123; mutate &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">  mutate(&#123;</span><br><span class="line">    variables: &#123; <span class="comment">// 传给mutation的参数</span></span><br><span class="line">      title: value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// blah blah</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mutation = gql<span class="string">`</span></span><br><span class="line"><span class="string">  mutation addSong($title: String) &#123;</span></span><br><span class="line"><span class="string">    addSong(title: $title) &#123;</span></span><br><span class="line"><span class="string">      title</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p>同样的，Apollo会在组件初始化时，把mutation函数传入this.props，以供后续的调用。</p><p>值得注意的是，mutation一般是需要传入参数的，我们可以在声明mutation的字符串语句中，支持传入一个String类型的$</p><blockquote><p>Warm Cache in Apollo<br>列表页中，query执行一次后，返回了当前的数据（共3条）到Apollo Store存储在<code>List</code>中。<br>操作页中，当在别的component中对数据进行mutation后，服务器端的list数据多了一条（共4条）；<br>回到列表页，Apollo不会re-fetch，在Apollo Store的<code>List</code>绑定的是前3条数据（已经请求过了），并不会重新发请求把服务器中新增的第4条更新到列表中。<br>解决方式：在mutation后，refetch希望更新到最新数据的query。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mutate(&#123;</span><br><span class="line">  variables: &#123;</span><br><span class="line">    title: value</span><br><span class="line">  &#125;,</span><br><span class="line">  refetchQueries: [&#123;</span><br><span class="line">    query: fetchSongQuery, <span class="comment">// refetch指定的query</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// callback</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;GraphQL解决什么问题&quot;&gt;&lt;a href=&quot;#GraphQL解决什么问题&quot; class=&quot;headerlink&quot; title=&quot;GraphQL解决什么问题&quot;&gt;&lt;/a&gt;GraphQL解决什么问题&lt;/h2&gt;&lt;h3 id=&quot;REST-ful-Routing&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="GraphQL" scheme="http://wuyuying.com/tags/GraphQL/"/>
    
  </entry>
  
  <entry>
    <title>puppeteer调研</title>
    <link href="http://wuyuying.com/archives/puppeteer/"/>
    <id>http://wuyuying.com/archives/puppeteer/</id>
    <published>2018-07-10T14:37:18.000Z</published>
    <updated>2018-08-17T12:47:37.603Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Puppeteer-Intro"><a href="#Puppeteer-Intro" class="headerlink" title="Puppeteer Intro"></a>Puppeteer Intro</h2><p>Puppeteer金字塔</p><p><img src="http://sinacloud.net/woodysblog/img/puppeteer-pyramid.png" alt="&quot;Puppeteer Pyramid&quot;"></p><p>无需再通过Chrome的开发协议，写冗长复杂的代码，轻松调用Chrome API。</p><p><img src="http://sinacloud.net/woodysblog/img/puppeteer-devtools-protocol.png" alt="&quot;puppeteer-devtools-protocol&quot;"></p><p>Puppeteer的使用场景。</p><p><img src="http://sinacloud.net/woodysblog/img/puppeteer-use-cases.png" alt="&quot;Puppeteer use case&quot;"></p><h2 id="Demo-screenshot"><a href="#Demo-screenshot" class="headerlink" title="Demo - screenshot"></a>Demo - screenshot</h2><h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="selector-tag">i</span> puppeteer --save</span><br></pre></td></tr></table></figure><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><p>打开<code>example.com</code>，截屏，生成文件<code>example.png</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// screenshot.js</span></span><br><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"></span><br><span class="line">puppeteer.launch(&#123;</span><br><span class="line">  headless: <span class="literal">false</span></span><br><span class="line">&#125;).then(<span class="keyword">async</span> browser =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  <span class="keyword">await</span> page.goto(<span class="string">'https://example.com'</span>);</span><br><span class="line">  <span class="keyword">await</span> page.screenshot(&#123;<span class="attr">path</span>: <span class="string">'example.png'</span>&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// run the demo</span></span><br><span class="line"><span class="comment">// node screenshot.js</span></span><br></pre></td></tr></table></figure><p><img src="http://sinacloud.net/woodysblog/img/screenshot-puppeteer.gif" alt="&quot;screenshot-puppeteer&quot;"></p><h2 id="Links"><a href="#Links" class="headerlink" title="Links"></a>Links</h2><ul><li><a href="https://developers.google.com/web/updates/2017/04/headless-chrome" target="_blank" rel="noopener">Getting Started with Headless Chrome</a></li><li><a href="https://try-puppeteer.appspot.com/" target="_blank" rel="noopener">Try Puppeteer</a></li><li><a href="https://pptraas.com/" target="_blank" rel="noopener">Puppeteer as a service</a></li><li><a href="https://github.com/GoogleChromeLabs/puppeteer-examples" target="_blank" rel="noopener">puppeteer-examples</a></li><li><a href="https://developers.google.com/web/tools/puppeteer/" target="_blank" rel="noopener">Puppeteer Docs</a></li></ul><p>Youtube Video:<br><a href="https://youtu.be/7-XnEMrQnn4?t=986" target="_blank" rel="noopener">“Intro of Puppeteer - Chrome Dev Summit 2017”</a><br><a href="https://www.youtube.com/watch?v=lhZOFUY1weo" target="_blank" rel="noopener">“The power of Headless Chrome and browser automation (Google I/O ‘18)”</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Puppeteer-Intro&quot;&gt;&lt;a href=&quot;#Puppeteer-Intro&quot; class=&quot;headerlink&quot; title=&quot;Puppeteer Intro&quot;&gt;&lt;/a&gt;Puppeteer Intro&lt;/h2&gt;&lt;p&gt;Puppeteer金字塔&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="front-end" scheme="http://wuyuying.com/tags/front-end/"/>
    
      <category term="testing" scheme="http://wuyuying.com/tags/testing/"/>
    
  </entry>
  
  <entry>
    <title>CSS自定义属性 —— 别说你懂CSS相对单位</title>
    <link href="http://wuyuying.com/archives/css-in-depth-css-variables/"/>
    <id>http://wuyuying.com/archives/css-in-depth-css-variables/</id>
    <published>2018-07-05T05:28:04.000Z</published>
    <updated>2018-08-17T12:47:37.598Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间试译了Keith J.Grant的CSS好书《CSS in Depth》，其中的第二章<a href="https://livebook.manning.com/#!/book/css-in-depth/chapter-2" target="_blank" rel="noopener">《Working with relative units》</a>，书中对relative units的讲解和举例可以说相当全面，看完之后发现自己并不太懂CSS相对单位，也希望分享给大家，所以有了这个译文系列。（若有勘误或翻译建议，欢迎 <a href="https://github.com/YuyingWu/blog/tree/dev/source/_posts" target="_blank" rel="noopener">Github PR</a> ^_^）</p><p>《别说你懂CSS相对单位》系列译文：</p><ul><li><a href="/blog/archives/css-in-depth-relative-units/">如何更愉快地使用em</a></li><li><a href="/blog/archives/css-in-depth-stop-thinking-in-px/">如何更愉快地使用rem</a></li><li><a href="/blog/archives/css-in-depth-viewport-relative-units/">视口相关单位的应用</a></li><li><a href="/blog/archives/css-in-depth-unitless-number/">无单位数字和行高</a></li><li><a href="/blog/archives/css-in-depth-css-variables/">CSS自定义属性</a> [本文]</li></ul><p>本文对应的章节目录：</p><ul><li>2.6 自定义属性（也叫“CSS变量”）<ul><li>2.6.1 动态改变自定义属性的值</li><li>2.6.2 通过JavaScript改变自定义属性的值</li><li>2.6.3 初探自定义属性</li></ul></li><li>总结</li></ul><blockquote><p>在今年年初，译者也写过一篇<a href="http://www.wuyuying.com/blog/archives/css-var/" target="_blank" rel="noopener">《CSS Variables学习笔记》</a>，里面有更多的CSS Variables的语法解释和实例demo，感兴趣的朋友可以看看 ：）</p></blockquote><hr><h2 id="2-6-自定义属性（也叫“CSS变量”）"><a href="#2-6-自定义属性（也叫“CSS变量”）" class="headerlink" title="2.6 自定义属性（也叫“CSS变量”）"></a>2.6 自定义属性（也叫“CSS变量”）</h2><p>在2015年，一个大家期待已久的名为“用作层叠式变量的自定义属性”（Custom Properties for Cascading Variables）的CSS规范终于发布为“候选推荐标准”（Candidate Recommendation）。这套规范引入了CSS中“变量”的概念，支持一种新的基于上下文的动态样式定义方式。你可以声明一个变量，再给它赋值，然后就可以在样式表的任何地方引用它。你可以通过这样的方式，减少样式表中的重复代码，以及后续你会看到的一些有用的应用场景。</p><p>在写这本书的时候，自定义属性已经被大多数主流浏览器支持了，除了IE。查看最新的浏览器支持情况，可以查看Can I Use的<a href="http://caniuse.com/#feat=css-variables" target="_blank" rel="noopener">http://caniuse.com/#feat=css-variables</a>。</p><blockquote><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><p>如果你刚好在用支持自定义变量的CSS预处理器，如Sass（syntactically awesome stylesheets）或Less，你可能会下意识拒绝CSS变量。千万别这么做。因为原生的CSS变量比任何一个预处理器能实现的功能都要强大和灵活。为了强调它们之间（原生CSS变量和预处理器自定义变量）的差异，我会把它叫作“自定义属性”，而不用“CSS变量”。</p></blockquote><p>声明一个自定义属性，跟声明其他属性类似。代码片段2.23是自定义属性声明的例子。新建一个页面和样式表吧，然后添加以下的CSS代码。</p><p>[ 代码片段 2.23 声明一个自定义属性 ]</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attribute">--main-font</span>: Helvetica, Arial, sans-serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码片段中，定义了一个名叫<code>--main-font</code>的变量，然后把它的值设定为普通的字体sans-serif。为了和其他属性区分开，命名的前缀必须是两道横杠（<code>--</code>），然后写上你想要的名字。</p><p>变量一定要声明在一个声明区块内。在这里，我使用了<code>:root</code>选择器，那么这个变量就可以在整个页面的样式里使用 —— 后面我会简单解释这个问题。</p><p>变量的声明，就它本身而言，不会做任何事情，直到我们在代码里引用它。我们在一个段落中使用它吧，做成像图2.13那样的效果。</p><p>[ 图 2.13 对一个简单段落使用用变量声明的字体sans-serif ]</p><p><img src="http://sinacloud.net/woodysblog/css-in-depth/02fig13_alt.jpg" alt="&quot;图 2.13&quot;"></p><p>我们可以用一个叫作<code>var()</code>的函数去引用自定义属性的值。现在，你可以利用这个函数去引用我们刚才声明的变量<code>--main-font</code>。把下面展示的代码片段添加到你的样式表中吧，把变量用起来。</p><p>[ 代码片段 2.24 使用一个自定义属性 ]</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">:root &#123;</span><br><span class="line">  --main-<span class="attribute">font</span>: Helvetica, Arial, sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;                                    1</span><br><span class="line">  <span class="attribute">font-family</span>: var(--main-font);       1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1 把段落的字体定义为 Helvetica, Arial, sans-serif</li></ul><p>自定义属性可以让你在一个地方声明它的值，作为一个“单一数据源”（single source of truth），然后在样式表的任意一个地方引用。这一点对一些反复出现的值特别有用，譬如颜色。下一个代码片段添加了一个名叫<code>brand-color</code>的自定义属性。你可以在样式表中多次使用这个变量，但假如你需要（全局）修改它的值，只需要在一行代码中编辑它的值就可以了。</p><p>[ 代码片段 2.25 对color使用自定义属性 ]</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">:root &#123;</span><br><span class="line">  --main-<span class="attribute">font</span>: Helvetica, Arial, sans-serif;</span><br><span class="line">  --brand-<span class="attribute">color</span>: <span class="number">#369</span>;                           1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: var(--main-font);</span><br><span class="line">  <span class="attribute">color</span>: var(--brand-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1 声明一个蓝色的<code>brand-color</code>变量</li></ul><p><code>var()</code>函数支持第二个参数，代表一个默认值。假如一个变量被声明的时候，第一个参数没有被声明，那么第二个参数值就会被引用。</p><p>[ 代码片段 2.26 提供回退默认值 ]</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">:root &#123;</span><br><span class="line">  --main-<span class="attribute">font</span>: Helvetica, Arial, sans-serif;</span><br><span class="line">  --brand-<span class="attribute">color</span>: <span class="number">#369</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: var(--main-font, sans-serif);         1</span><br><span class="line">  <span class="attribute">color</span>: var(--secondary-color, blue);               2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1 声明一个默认值 sans-serif</li><li>2 变量 secondary-color 没有被声明，于是默认值 blue 会被使用</li></ul><p>这段代码在两个不同的声明中，定义了默认值。第一个声明里，<code>--main-font</code>被声明，值为<code>Helvetica, Arial,sans-serif</code>，于是这个值就会被用到了。第二个声明里，<code>--secondary-color</code>是一个没有声明过的变量，所以默认值 blue 被用到了。</p><blockquote><p>笔记<br>如果<code>var()</code>被定义为一个无效值，这个属性会被定义为它的初始值。举个例子，如果在<code>padding: var(--brand-color)</code>中，变量是一个色号，那对于padding来说这就是一个无效值。在这个情况下，padding的值会被定义为0。</p></blockquote><h3 id="2-6-1-动态改变自定义属性的值"><a href="#2-6-1-动态改变自定义属性的值" class="headerlink" title="2.6.1 动态改变自定义属性的值"></a>2.6.1 动态改变自定义属性的值</h3><p>从这些例子可以看到，自定义属性只是更方便了一点，也可以帮助你减少很多的重复代码。但让自定义属性更有意思的是，自定义属性的声明是可以层叠和继承的。你可以在多个选择器中声明同一个变量，这些变量在页面的不同部分可以有着不一样的值。</p><p>你可以声明一个变量是黑色的，举个例子，然后在一个特定的容器里把它重新定义为白色的。于是，在这个容器以外的所有依赖这个变量的颜色是黑色，而在容器内的就是白色。通过这样的方式，我们来实现一个像图2.14这样的效果。</p><p>[ 图 2.14 自定义属性基于不同域下的值，生成两个颜色不一样的面板 ]</p><p><img src="http://sinacloud.net/woodysblog/css-in-depth/02fig14_alt.jpg" alt="&quot;图 2.14&quot;"></p><p>这个面板类似你之前看到的那个（图2.7），HTML在代码片段2.27。这个面板有两个实例，一个在body下，另一个在一个深色的区块。来，更新下你的代码。</p><p>[ 代码片段 2.27 页面上不同上下文的两个面板 ]</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"panel"</span>&gt;                               <span class="number">1</span></span><br><span class="line">    &lt;h2&gt;Single-origin&lt;/h2&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"body"</span>&gt;</span><br><span class="line">      We have built partnerships <span class="keyword">with</span> small farms</span><br><span class="line">      <span class="keyword">around</span> <span class="keyword">the</span> world <span class="keyword">to</span> hand-select beans <span class="keyword">at</span> <span class="keyword">the</span></span><br><span class="line">      peak <span class="keyword">of</span> season. We <span class="keyword">then</span> careful roast <span class="keyword">in</span></span><br><span class="line">      small batches <span class="keyword">to</span> maximize their potential.</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">  &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line"></span><br><span class="line">  &lt;aside <span class="built_in">class</span>=<span class="string">"dark"</span>&gt;                              <span class="number">2</span></span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"panel"</span>&gt;                             <span class="number">2</span></span><br><span class="line">      &lt;h2&gt;Single-origin&lt;/h2&gt;</span><br><span class="line">      &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"body"</span>&gt;</span><br><span class="line">        We have built partnerships <span class="keyword">with</span> small farms</span><br><span class="line">        <span class="keyword">around</span> <span class="keyword">the</span> world <span class="keyword">to</span> hand-select beans <span class="keyword">at</span> <span class="keyword">the</span></span><br><span class="line">        peak <span class="keyword">of</span> season. We <span class="keyword">then</span> careful roast <span class="keyword">in</span></span><br><span class="line">        small batches <span class="keyword">to</span> maximize their potential.</span><br><span class="line">      &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">  &lt;/aside&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><ul><li>1 页面上一个普通的面板</li><li>2 第二个面板在深色容器里</li></ul><p>我们用变量重新改写一下面板中的文字和背景颜色。把下面的代码片段加进你的样式表。这里把背景颜色设成白色，文字颜色设成黑色。在你添加深色主题之前，我会解释这段代码的工作原理。</p><p>[ 代码片段 2.28 利用变量定义面板的颜色 ]</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">:root &#123;</span><br><span class="line">  --main-bg: <span class="number">#fff</span>;                       1</span><br><span class="line">  --main-<span class="attribute">color</span>: <span class="number">#000</span>;                    1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.panel</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1rem</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#999</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0.5em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: var(--main-bg);      2</span><br><span class="line">  <span class="attribute">color</span>: var(--main-color);              2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.panel</span> &gt; <span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0.8em</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">text-transform</span>: uppercase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1 分别把背景色和文字颜色定义为白色和黑色</li><li>2 在面板样式中使用变量</li></ul><p>你再一次把变量声明在<code>:root</code>选择器里。很明显，这样的话我们就可以在根元素（整个页面）下的任何元素中引用这个变量了。当根元素下的子元素使用这些变量时，它们就能拿到这些变量对应的值。</p><p>你有两个面板，不过它们仍然看起来是一样的。现在，再一次定义这些变量，但这次是在一个不同的选择器中。下一个代码片段是深色容器的，它有深灰色的背景色，以及小小的padding和margin。同时，它也重写了两个变量。添加到你的样式表吧。</p><p>[ 代码片段 2.29 设置深色容器的样式 ]</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.dark</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">2em</span>;                   1</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#999</span>;            2</span><br><span class="line">  --main-bg: <span class="number">#333</span>;                   3</span><br><span class="line">  --main-<span class="attribute">color</span>: <span class="number">#fff</span>;                3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1 在深色容器和上一个容器间设定一个margin</li><li>2 给深色容器设定深灰色的背景色</li><li>3 在当前容器的作用域下，重新定义–main-bg 和 –main-color的值</li></ul><p>刷新页面，第二个面板就会有深色背景和白色文字。这是因为当这个面板去调用这些变量时，拿到的是深色容器作用域下的值，而不是根元素域下的值。注意，你并不需要修改这个容器里的样式或者添加额外的类名。</p><p>在这个例子里，你两次定义了自定义属性，第一次在根元素作用域上（<code>--main-color</code>是黑色的），第二次在深色容器作用域（<code>--main-color</code>是白色的）。自定义属性表现得像作用域变量，因为值会被后代元素继承。在深色容器中，<code>--main-color</code>是白色的，而在页面的其他位置，它是黑色的。</p><h3 id="2-6-2-通过JavaScript改变自定义属性的值"><a href="#2-6-2-通过JavaScript改变自定义属性的值" class="headerlink" title="2.6.2 通过JavaScript改变自定义属性的值"></a>2.6.2 通过JavaScript改变自定义属性的值</h3><p>在浏览器中，自定义属性还可以被JavaScript访问和动态地修改。毕竟这不是一本讲JavaScript的书，我会告诉你足够多的基本概念，然后你再把这些融入到自己的JavaScript项目中。</p><p>[ 代码片段 2.30 在JavaScript里访问一个自定义变量 ]</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> rootElement = <span class="built_in">document</span>.documentElement;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> styles = getComputedStyle(rootElement);                 <span class="number">1</span></span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> mainColor = styles.getPropertyValue(<span class="string">'--main-bg'</span>);       <span class="number">2</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="built_in">String</span>(mainColor).trim());                      <span class="number">3</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>1 获取元素的样式对象（style object）</li><li>2 从样式对象中获得 –main-bg 的值</li><li>3 确认 mainColor 是一个字符串以及把空格去掉，输出“#fff”</li></ul><p>因为你可以随手修改自定义属性的值，你可以用JavaScript给<code>--main-bg</code>动态地定义一个新的值。如果你把它定义为浅蓝色，它就是展示成这样（图2.15）。</p><p>[ 图 2.15 JavaScript可以通过改变变量–main-bg的值改变面板的背景色 ]</p><p><img src="http://sinacloud.net/woodysblog/css-in-depth/02fig15_alt.jpg" alt="&quot;图 2.15&quot;"></p><p>下面的代码片段，会在根元素下给<code>--main-bg</code>定义一个新的值，在<code>&lt;script&gt;</code>标签的最下面，加上这些的代码。</p><p>[ 代码片段 2.31 在JavaScript定义一个自定义变量的值 ]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rootElement = <span class="built_in">document</span>.documentElement;</span><br><span class="line">rootElement.style.setProperty(<span class="string">'--main-bg'</span>, <span class="string">'#cdf'</span>);            <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>1 把根元素下的 –main-bg 定义为浅蓝色</li></ul><p>如果你执行这段代码，任何继承了<code>--main-bg</code>属性的元素都会发生改变，对应的值会变成新的。在你的页面上，这会把第一个面板的背景色变成浅蓝色。第二个面板保持不变，因为它继承的还是在深色容器里定义的值。</p><p>利用这项技术，你可以在浏览器里用JavaScript给你的站点换主题。或者你可以高亮页面上的某些部分，又或者随手就可以做一些改变。只需要少量几行JavaScript代码，你做的改变就可以影响到页面上大量的元素。</p><h3 id="2-6-3-初探自定义属性"><a href="#2-6-3-初探自定义属性" class="headerlink" title="2.6.3 初探自定义属性"></a>2.6.3 初探自定义属性</h3><p>自定义属性是一个全新的CSS领域，开发者才刚刚开始探索。因为目前浏览器的支持比较有限，所以还没有到使用它的“黄金时间”。我相信，一段时间之后，你会看到很多关于自定义属性的最佳实践和新颖的玩法。这是你需要留意的。尝试使用自定义属性，看看你可以做出些什么吧。</p><p>需要关注的一点，如果你使用<code>var()</code>声明，低版本浏览器不能识别就会忽略它。如果可以的话，给那些浏览器提供一个回退（fallback）方案。</p><p>[ 代码片段（没有编号） ]</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">color</span>: black;</span><br><span class="line"><span class="built_in">color</span>: <span class="built_in">var</span>(--main-<span class="built_in">color</span>);</span><br></pre></td></tr></table></figure><p>自定义属性原生的动态特性，并不是总是可以使用的，可以关注它的浏览器支持情况<a href="http://caniuse.com" target="_blank" rel="noopener">http://caniuse.com</a>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>拥抱和使用相对单位，让页面的结构去定义样式代码的含义</li><li>个人喜欢对字号大小使用rem，选择性地对页面组件的一些简单缩放效果使用em</li><li>你可以让整个页面实现响应式缩放，而不需要任何的媒体查询</li><li>在声明行高时，使用不带单位的数值</li><li>开始了解和使用CSS最新的特性之一——自定义属性吧！</li></ul><hr><p>《别说你懂CSS相对单位》系列译文：</p><ul><li><a href="/blog/archives/css-in-depth-relative-units/">如何更愉快地使用em</a></li><li><a href="/blog/archives/css-in-depth-stop-thinking-in-px/">如何更愉快地使用rem</a></li><li><a href="/blog/archives/css-in-depth-viewport-relative-units/">视口相关单位的应用</a></li><li><a href="/blog/archives/css-in-depth-unitless-number/">无单位数字和行高</a></li><li><a href="/blog/archives/css-in-depth-css-variables/">CSS自定义属性</a> [本文]</li></ul><p>章节：</p><ul><li>2.1 相对单位值的魔力<ul><li>2.1.1 完美像素设计（pixel-perfect design）的挣扎</li><li>2.1.2 完美像素网页的终结</li><li>像素（pixel）、点（point）和pc（pica）</li></ul></li><li>2.2 em和rem<ul><li>2.2.1 对font-size使用em<ul><li>当我们在一个元素内用em同时声明font-size和其他属性</li><li>字号收缩问题</li></ul></li><li>2.2.2 对font-size使用rem<ul><li>可用性：对font-size使用相对长度单位</li></ul></li></ul></li><li>2.3 停止使用像素思维去思考<ul><li>2.3.1 设置一个合理的字号默认值</li><li>2.3.2 让这个面板变得“响应式”</li><li>2.3.3 调整单个组件的大小</li></ul></li><li>2.4 视口相关单位（viewport-relative units）<ul><li>CSS3</li><li>2.4.1 在font-size上使用vw</li><li>2.4.2 在font-size上使用calc()</li></ul></li><li>2.5 不带单位的数字（unitless number）和行高（line-height）</li><li>2.6 自定义属性（也叫“CSS变量”）<ul><li>2.6.1 动态改变自定义属性的值</li><li>2.6.2 通过JavaScript改变自定义属性的值</li><li>2.6.3 初探自定义属性</li></ul></li><li>总结</li></ul><blockquote><p>原著版权信息：</p><p>作者：Keith J.Grant<br>书籍：CSS in Depth<br>章节：<a href="https://livebook.manning.com/#!/book/css-in-depth/chapter-2" target="_blank" rel="noopener">Working with relative units</a>  </p></blockquote><hr><p>笔者 @Yuying Wu，前端爱好者 / 鼓励师 / 新西兰打工度假 / 铲屎官。目前就职于某大型电商的B2B前端团队。</p><p>感谢你读到这里，对上文若有任何疑问或建议，欢迎留言。</p><p>如果你和我一样喜欢前端，喜欢捣腾独立博客或者前沿技术，或者有什么职业疑问，欢迎关注我以及各种交流哈。</p><p>独立博客：<a href="http://wuyuying.com/">wuyuying.com</a><br>知乎ID：<a href="https://www.zhihu.com/people/yuying_wu/posts" target="_blank" rel="noopener">@Yuying Wu</a><br>Github：<a href="https://github.com/YuyingWu" target="_blank" rel="noopener">Yuying Wu</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前段时间试译了Keith J.Grant的CSS好书《CSS in Depth》，其中的第二章&lt;a href=&quot;https://livebook.manning.com/#!/book/css-in-depth/chapter-2&quot; target=&quot;_blank&quot; rel=
      
    
    </summary>
    
    
      <category term="front-end" scheme="http://wuyuying.com/tags/front-end/"/>
    
      <category term="css" scheme="http://wuyuying.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>无单位数字和行高 —— 别说你懂CSS相对单位</title>
    <link href="http://wuyuying.com/archives/css-in-depth-unitless-number/"/>
    <id>http://wuyuying.com/archives/css-in-depth-unitless-number/</id>
    <published>2018-07-05T05:28:03.000Z</published>
    <updated>2018-08-17T12:47:37.601Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间试译了Keith J.Grant的CSS好书《CSS in Depth》，其中的第二章<a href="https://livebook.manning.com/#!/book/css-in-depth/chapter-2" target="_blank" rel="noopener">《Working with relative units》</a>，书中对relative units的讲解和举例可以说相当全面，看完之后发现自己并不太懂CSS相对单位，也希望分享给大家，所以有了这个译文系列。（若有勘误或翻译建议，欢迎 <a href="https://github.com/YuyingWu/blog/tree/dev/source/_posts" target="_blank" rel="noopener">Github PR</a> ^_^）</p><p>《别说你懂CSS相对单位》系列译文：</p><ul><li><a href="/blog/archives/css-in-depth-relative-units/">如何更愉快地使用em</a></li><li><a href="/blog/archives/css-in-depth-stop-thinking-in-px/">如何更愉快地使用rem</a></li><li><a href="/blog/archives/css-in-depth-viewport-relative-units/">视口相关单位的应用</a></li><li><a href="/blog/archives/css-in-depth-unitless-number/">无单位数字和行高</a> [本文]</li><li><a href="/blog/archives/css-in-depth-css-variables/">CSS自定义属性</a></li></ul><p>本文对应的章节目录：</p><ul><li>2.5 不带单位的数字（unitless number）和行高（line-height）</li></ul><hr><h2 id="2-5-无单位数字（unitless-number）和行高（line-height）"><a href="#2-5-无单位数字（unitless-number）和行高（line-height）" class="headerlink" title="2.5 无单位数字（unitless number）和行高（line-height）"></a>2.5 无单位数字（unitless number）和行高（line-height）</h2><p>有一些属性可以接收不带单位的数值（意思就是一个不带长度单位的数字），如<code>line-height</code>、<code>z-index</code>和<code>font-weight</code>（700等于bold，400等于normal，如此类推）。你也可以在需要长度单位的地方（如px、em、rem）使用一个不带单位的<code>0</code>，因为长度已经是0了，带不带单位也无所谓了 —— 0px 等于 0% 等于 0em。</p><blockquote><p>警告</p><p>不带单位的0只可以表示长度单位和百分比的值，譬如padding、border和width。而对于一些特殊的情况，如度数（degrees）或者像秒这样基于时间的值（time-based values），是不可以使用不带单位的0的。</p></blockquote><p><code>line-height</code>属性最特别的地方，在于同时支持带单位和不带单位的值。你应该保持使用不带单位的数值，因为这样就可以从父元素继承。我们在页面上写点文字，看看它是怎么表现的吧。把下面代码添加到你的样式表。</p><p>[ 代码片段 2.20 继承<code>line-height</code>的模板 ]</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;p <span class="built_in">class</span>=<span class="string">"about-us"</span>&gt;</span><br><span class="line">    We have built partnerships <span class="keyword">with</span> small farms <span class="keyword">around</span> <span class="keyword">the</span> world <span class="keyword">to</span></span><br><span class="line">    hand-select beans <span class="keyword">at</span> <span class="keyword">the</span> peak <span class="keyword">of</span> season. We <span class="keyword">then</span> carefully roast <span class="keyword">in</span></span><br><span class="line">    small batches <span class="keyword">to</span> maximize their potential.</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>给<code>body</code>声明一个<code>line-height</code>，然后文档的其他元素会从这里继承。页面的展示符合预期，不管你对页面的其他元素的字号大小做了什么改变。</p><p>[ 图 2.11 不带单位的行高，会在每个后代元素下重新计算出实际值 ]</p><p><img src="http://sinacloud.net/woodysblog/css-in-depth/02fig11.jpg" alt="&quot;图 2.11&quot;"></p><p>把代码片段2.21的内容添加到你的样式表。段落（<code>&lt;p&gt;</code>）继承了1.2的行高。因为字号是32px（<code>2em</code> <em> 16px，浏览器默认字号大小），所以本地的行高计算值是38.4px（32px </em> 1.2）。这会给段落的行间距留下比较合适的空间。</p><p>[ 代码片段 2.21 对line-height使用不带单位的值 ]</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.2</span>;               <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.about-us</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1 后代元素继承不带单位的值</li></ul><p>如果你给行高设定了一个带单位的值，你可能会得到意想不到的结果，如图2.12那样，行间文字互相重叠了，代码片段2.22则是造成这个结果的CSS代码。</p><p>[ 图 2.12 继承行高造成的行间互叠 ]<br><img src="http://sinacloud.net/woodysblog/css-in-depth/02fig12.jpg" alt="&quot;图 2.12&quot;"></p><p>[ 代码片段 2.22 带单位的行高值造成意外的结果 ]</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.2em</span>;             <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.about-us</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2em</span>;                 <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1 后代元素继承了计算值（19.2px）</li><li>2 等于32px</li></ul><p>这样的结果源于一次奇怪的继承：当一个元素是用带单位的值声明的，那么它的后代元素会继承计算结果值。当行高属性是用类似em来声明时，它的值会先被计算，然后计算后的值会传到任何继承它的后代元素。对于<code>line-height</code>这个属性来说，如果子元素有跟父元素不一样字号大小的情况，就会导致意想不到的结果，譬如文字间的遮挡。</p><blockquote><p>长度 —— CSS中用来描述距离测量的正式用语。它是一个带单位的数字，如5px。长度有两种类型：绝对的和相对的。百分比跟长度很类似，但严格来说，百分比不能叫长度。</p></blockquote><p>当你（对某个属性）使用不带单位的数字，声明的值会被继承，也就是说这个值会在子元素中用来重新计算子元素域下的值，而这个通常是你想要的效果。使用不带单位的数字，可以让你在body上设定一个行高，然后什么都不用管，页面上其他元素会默认继承，除非在某个特定的地方你想要做一个额外的样式。</p><hr><p>《别说你懂CSS相对单位》系列译文：</p><ul><li><a href="/blog/archives/css-in-depth-relative-units/">如何更愉快地使用em</a></li><li><a href="/blog/archives/css-in-depth-stop-thinking-in-px/">如何更愉快地使用rem</a></li><li><a href="/blog/archives/css-in-depth-viewport-relative-units/">视口相关单位的应用</a></li><li><a href="/blog/archives/css-in-depth-unitless-number/">无单位数字和行高</a> [本文]</li><li><a href="/blog/archives/css-in-depth-css-variables/">CSS自定义属性</a></li></ul><p>章节：</p><ul><li>2.1 相对单位值的魔力<ul><li>2.1.1 完美像素设计（pixel-perfect design）的挣扎</li><li>2.1.2 完美像素网页的终结</li><li>像素（pixel）、点（point）和pc（pica）</li></ul></li><li>2.2 em和rem<ul><li>2.2.1 对font-size使用em<ul><li>当我们在一个元素内用em同时声明font-size和其他属性</li><li>字号收缩问题</li></ul></li><li>2.2.2 对font-size使用rem<ul><li>可用性：对font-size使用相对长度单位</li></ul></li></ul></li><li>2.3 停止使用像素思维去思考<ul><li>2.3.1 设置一个合理的字号默认值</li><li>2.3.2 让这个面板变得“响应式”</li><li>2.3.3 调整单个组件的大小</li></ul></li><li>2.4 视口相关单位（viewport-relative units）<ul><li>CSS3</li><li>2.4.1 在font-size上使用vw</li><li>2.4.2 在font-size上使用calc()</li></ul></li><li>2.5 不带单位的数字（unitless number）和行高（line-height）</li><li>2.6 自定义属性（也叫“CSS变量”）<ul><li>2.6.1 动态改变自定义属性的值</li><li>2.6.2 通过JavaScript改变自定义属性的值</li><li>2.6.3 初探自定义属性</li></ul></li><li>总结</li></ul><blockquote><p>原著版权信息：</p><p>作者：Keith J.Grant<br>书籍：CSS in Depth<br>章节：<a href="https://livebook.manning.com/#!/book/css-in-depth/chapter-2" target="_blank" rel="noopener">Working with relative units</a>   </p></blockquote><hr><p>笔者 @Yuying Wu，前端爱好者 / 鼓励师 / 新西兰打工度假 / 铲屎官。目前就职于某大型电商的B2B前端团队。</p><p>感谢你读到这里，对上文若有任何疑问或建议，欢迎留言。</p><p>如果你和我一样喜欢前端，喜欢捣腾独立博客或者前沿技术，或者有什么职业疑问，欢迎关注我以及各种交流哈。</p><p>独立博客：<a href="http://wuyuying.com/">wuyuying.com</a><br>知乎ID：<a href="https://www.zhihu.com/people/yuying_wu/posts" target="_blank" rel="noopener">@Yuying Wu</a><br>Github：<a href="https://github.com/YuyingWu" target="_blank" rel="noopener">Yuying Wu</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前段时间试译了Keith J.Grant的CSS好书《CSS in Depth》，其中的第二章&lt;a href=&quot;https://livebook.manning.com/#!/book/css-in-depth/chapter-2&quot; target=&quot;_blank&quot; rel=
      
    
    </summary>
    
    
      <category term="front-end" scheme="http://wuyuying.com/tags/front-end/"/>
    
      <category term="css" scheme="http://wuyuying.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>视口相关单位的应用 —— 别说你懂CSS相对单位</title>
    <link href="http://wuyuying.com/archives/css-in-depth-viewport-relative-units/"/>
    <id>http://wuyuying.com/archives/css-in-depth-viewport-relative-units/</id>
    <published>2018-07-05T05:28:02.000Z</published>
    <updated>2018-08-17T12:47:37.601Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间试译了Keith J.Grant的CSS好书《CSS in Depth》，其中的第二章<a href="https://livebook.manning.com/#!/book/css-in-depth/chapter-2" target="_blank" rel="noopener">《Working with relative units》</a>，书中对relative units的讲解和举例可以说相当全面，看完之后发现自己并不太懂CSS相对单位，也希望分享给大家，所以有了这个译文系列。（若有勘误或翻译建议，欢迎 <a href="https://github.com/YuyingWu/blog/tree/dev/source/_posts" target="_blank" rel="noopener">Github PR</a> ^_^）</p><p>《别说你懂CSS相对单位》系列译文：</p><ul><li><a href="/blog/archives/css-in-depth-relative-units/">如何更愉快地使用em</a></li><li><a href="/blog/archives/css-in-depth-stop-thinking-in-px/">如何更愉快地使用rem</a></li><li><a href="/blog/archives/css-in-depth-viewport-relative-units/">视口相关单位的应用</a> [本文]</li><li><a href="/blog/archives/css-in-depth-unitless-number/">无单位数字和行高</a></li><li><a href="/blog/archives/css-in-depth-css-variables/">CSS自定义属性</a></li></ul><p>本文对应的章节目录：</p><ul><li>2.4 视口相关单位（viewport-relative units）<ul><li>CSS3</li><li>2.4.1 在font-size上使用vw</li><li>2.4.2 在font-size上使用calc()</li></ul></li></ul><hr><h2 id="2-4-视口相关单位（viewport-relative-units）"><a href="#2-4-视口相关单位（viewport-relative-units）" class="headerlink" title="2.4 视口相关单位（viewport-relative units）"></a>2.4 视口相关单位（viewport-relative units）</h2><p>你已经学完em和rem了，它们都是以<code>font-size</code>为基准值的，但相对单位不只它们。还有视口相关单位，依赖浏览器的视口大小来定义长度的。</p><blockquote><p>视口（viewport） —— 在浏览器窗口中用来渲染页面的可视区域，这不包括浏览器的地址栏、工具栏、状态栏等（如果有的话）。</p></blockquote><p>如果你不熟悉视口相关单位的话，在这里简单介绍一下。</p><ul><li>vh —— 视口高度的1/100</li><li>vw —— 视口宽度的1/100</li><li>vmin —— 视区宽度或高度较小值的1/100（IE9支持的是vm）</li><li>vmax —— 视区宽度或高度较大值的1/100（在写本书时，IE或者Edge都不支持）</li></ul><p>举个例子，50vw等于视口宽度的一半，而25vh等于视口高度的25%。vmin依赖两者（宽或高）的较小值，如果我们需要确保一个元素不管在横屏还是竖屏下适应屏幕展示的话，这个属性会很有帮助：如果是横屏，vmin的基准值是屏幕的高度，如果是竖屏，它的基准值是屏幕的宽度。</p><p>图2.10展示了一个正方形的元素在不同屏幕尺寸下的视口的情况。宽和高的值都声明为90vmin，也就是宽高较小值的90%。边长的值等于，横屏情况下高度的90%，或者竖屏情况下宽度的90%。</p><p>[ 图 2.10 如果把一个元素的宽高定义成90vmin，它总会展示成一个正方形，边长稍小于屏幕的视口，不管它的尺寸或方向怎样。 ]</p><p><img src="http://sinacloud.net/woodysblog/css-in-depth/02fig10_alt.jpg" alt="&quot;图 2.10&quot;"></p><p>在代码片段2.18可以看到这个元素的样式，渲染了一个适应屏幕尺寸的大正方形，不管浏览器的尺寸是多少。你可以通过添加<code>&lt;div class=&quot;square&quot;&gt;</code>，再看看页面效果。</p><p>[ 代码片段 2.18 边长使用<code>vmin</code>的正方形元素 ]</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.square</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">90vmin</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">90vmin</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#369</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想做一个大英雄图片充满屏幕的效果，视口相关长度最合适不过。你的图片可以在一个长条形的容器内，把图片的高度设为100vh，那它的高度就会跟视口高度一样。</p><blockquote><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><p>视口相关单位对于大多数浏览器还是一项比较新的特性，所以当你试图把这个特性和其他样式混搭时，有可能会有一些很奇怪的bug。详情参考<a href="http://caniuse.com/#feat=viewport-units" target="_blank" rel="noopener">http://caniuse.com/#feat=viewport-units</a>列表中的“已知问题（Known Issues）”</p></blockquote><blockquote><h3 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h3><p>本章提到的很多单位类型，其实并不在早期的CSS版本里（尤其是rem和视口相关单位）。在这门语言一系列的更新迭代过程中，它们慢慢被加进来，我们将最新的版本称作CSS3。  </p><p>在二十世纪末二十一世纪初，在CSS规范的初版发布之后的很长一段时间，只有很小的改动。在1998年5月份，W3C（World Wide Web Consortium）发布了CSS 2规范。不久之后，修正版本2中问题和缺陷的2.1版本开始了，CSS 2.1的工作持续了好多年，但并没有添加什么令人印象深刻的特性。直到2011年4月份，版本2.1终于被确认为“提议推荐标准”（Proposed Recommendation）。到这个时候，大多数浏览器对CSS 2.1的特性已经支持得很好了，在此基础上，浏览器又努力地添加一些新的特性。这就是新规范CSS 3。  </p><p>“3”是个非正式的版本号，实际上并没有CSS3规范。相反，这个规范被拆成多个独立的模块，分别有独立的版本号。background和border的规范已经从盒模型（box model）以及层叠与继承（cascading and inheritance）规范中独立出来。通过这种方式，W3C就可以针对CSS某个模块进行更新迭代，而不用同时更新其他不相关的模块的内容。在这些模块规范里，很多还停留在第3版本（现在叫“第3级”），但有的模块（比如选择器规范（selectors specification））已经到第4级，而其他的模块（比如flexbox）还在第1级。  </p><p>这些新特性进入了人们的视野。我们可以看到在2009到2013年间，大量新的CSS特性涌进浏览器中。其中有现在比较出名的rem和视口相关单位，以及新的选择器（new selectors）、媒体查询（media queries）、网页文字（web fonts）、圆形边框（rounded borders）、动画（animation）、变换（transitions）、变形（transformations）以及定义颜色的不同方式。然而，每年的新特性的数量还在逐年稳定增长。  </p><p>这意味着，我们不再只跟一个特定版本的CSS规范打交道。这是一套有生命的标准，每个浏览器也在持续地支持新的特性，开发者会开始使用然后渐渐习惯它们。CSS4大概不会出现了，如果有的话，应该也只是个用于市场营销的名词。尽管这本书也会提到CSS3的新特性，但没有必要把它们都搬出来，就整个网页而言，这些都是CSS。</p></blockquote><h3 id="2-4-1-在font-size上使用vw"><a href="#2-4-1-在font-size上使用vw" class="headerlink" title="2.4.1 在font-size上使用vw"></a>2.4.1 在font-size上使用vw</h3><p>一个应用如果使用了视口相关单位，可能效果最不明显的地方就是用在字号大小上。事实上，我发现把vh和vw用在字号上比元素的宽或者高更实用。</p><p>试想一下，如果把元素的font-size声明为2vm，会怎么样？台式机屏幕宽是1200px，2vm等于24px（1200 <em> 2%）。而平板电脑的屏幕宽768px，2vm约等于15px（768 </em> 2%）。很棒的是，元素在两个尺寸下缩放自如。这意味着这里并没有一个突然的断点，元素会随着视口尺寸的增大而平滑增大。</p><p>不幸的是，24px对于大屏幕来说有点太大了。而更糟糕的是，在iPhone6它直接缩小到7.5px。好消息是缩放生效了，而坏消息是极限情况的处理有点差。你可以通过CSS的方法<code>calc()</code>解决这个问题。</p><h3 id="2-4-2-在font-size上使用calc"><a href="#2-4-2-在font-size上使用calc" class="headerlink" title="2.4.2 在font-size上使用calc()"></a>2.4.2 在font-size上使用calc()</h3><p><code>calc()</code>函数支持对2个或者更多个数值进行基础的运算。这个函数对不同类型的单位间的运算尤其有用。这个函数支持加（+）、减（-）、乘（*）和除以（/）。其中，加和减运算符左右必须留有空格，所以我建议我们来培养一个习惯，总是在四个运算符的两侧都写上空格，譬如<code>calc(1em + 10px)</code>。</p><p>你会在下一个代码片段中，使用<code>calc()</code>来计算vh单位和em单位的值。把你的样式表中的上一段设定基础字号大小的代码去掉（及相关的媒体查询代码），添加以下代码。</p><p>[ 代码片段 2.19 在font-size中使用em和vh单位进行calc()运算 ]</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="built_in">calc</span>(0.5em + 1vw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，打开页面，缓慢地改变浏览器的大小。你会发现，字号改变的过渡很平滑。0.5em在这里代表的是字号的最小值，1vm则代表着响应式地往上累加。这样基础字号大小就在iPhone6的11.75px和1200px宽浏览器窗口的20px间缩放。你可以根据自己的喜好改变这些值。</p><p>你现在可以实现响应式策略的核心逻辑而不需要添加一行媒体查询的代码。页面上的所有元素可以根据视口大小平滑缩放，不再需要3或4个硬编码的断点。</p><hr><p>《别说你懂CSS相对单位》系列译文：</p><ul><li><a href="/blog/archives/css-in-depth-relative-units/">如何更愉快地使用em</a></li><li><a href="/blog/archives/css-in-depth-stop-thinking-in-px/">如何更愉快地使用rem</a></li><li><a href="/blog/archives/css-in-depth-viewport-relative-units/">视口相关单位的应用</a> [本文]</li><li><a href="/blog/archives/css-in-depth-unitless-number/">无单位数字和行高</a></li><li><a href="/blog/archives/css-in-depth-css-variables/">CSS自定义属性</a></li></ul><p>章节：</p><ul><li>2.1 相对单位值的魔力<ul><li>2.1.1 完美像素设计（pixel-perfect design）的挣扎</li><li>2.1.2 完美像素网页的终结</li><li>像素（pixel）、点（point）和pc（pica）</li></ul></li><li>2.2 em和rem<ul><li>2.2.1 对font-size使用em<ul><li>当我们在一个元素内用em同时声明font-size和其他属性</li><li>字号收缩问题</li></ul></li><li>2.2.2 对font-size使用rem<ul><li>可用性：对font-size使用相对长度单位</li></ul></li></ul></li><li>2.3 停止使用像素思维去思考<ul><li>2.3.1 设置一个合理的字号默认值</li><li>2.3.2 让这个面板变得“响应式”</li><li>2.3.3 调整单个组件的大小</li></ul></li><li>2.4 视口相关单位（viewport-relative units）<ul><li>CSS3</li><li>2.4.1 在font-size上使用vw</li><li>2.4.2 在font-size上使用calc()</li></ul></li><li>2.5 不带单位的数字（unitless number）和行高（line-height）</li><li>2.6 自定义属性（也叫“CSS变量”）<ul><li>2.6.1 动态改变自定义属性的值</li><li>2.6.2 通过JavaScript改变自定义属性的值</li><li>2.6.3 初探自定义属性</li></ul></li><li>总结</li></ul><blockquote><p>原著版权信息：</p><p>作者：Keith J.Grant<br>书籍：CSS in Depth<br>章节：<a href="https://livebook.manning.com/#!/book/css-in-depth/chapter-2" target="_blank" rel="noopener">Working with relative units</a>  </p></blockquote><hr><p>笔者 @Yuying Wu，前端爱好者 / 鼓励师 / 新西兰打工度假 / 铲屎官。目前就职于某大型电商的B2B前端团队。</p><p>感谢你读到这里，对上文若有任何疑问或建议，欢迎留言。</p><p>如果你和我一样喜欢前端，喜欢捣腾独立博客或者前沿技术，或者有什么职业疑问，欢迎关注我以及各种交流哈。</p><p>独立博客：<a href="http://wuyuying.com/">wuyuying.com</a><br>知乎ID：<a href="https://www.zhihu.com/people/yuying_wu/posts" target="_blank" rel="noopener">@Yuying Wu</a><br>Github：<a href="https://github.com/YuyingWu" target="_blank" rel="noopener">Yuying Wu</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前段时间试译了Keith J.Grant的CSS好书《CSS in Depth》，其中的第二章&lt;a href=&quot;https://livebook.manning.com/#!/book/css-in-depth/chapter-2&quot; target=&quot;_blank&quot; rel=
      
    
    </summary>
    
    
      <category term="front-end" scheme="http://wuyuying.com/tags/front-end/"/>
    
      <category term="css" scheme="http://wuyuying.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>如何更愉快地使用rem —— 别说你懂CSS相对单位</title>
    <link href="http://wuyuying.com/archives/css-in-depth-stop-thinking-in-px/"/>
    <id>http://wuyuying.com/archives/css-in-depth-stop-thinking-in-px/</id>
    <published>2018-07-05T05:28:01.000Z</published>
    <updated>2018-08-17T12:47:37.600Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间试译了Keith J.Grant的CSS好书《CSS in Depth》，其中的第二章<a href="https://livebook.manning.com/#!/book/css-in-depth/chapter-2" target="_blank" rel="noopener">《Working with relative units》</a>，书中对relative units的讲解和举例可以说相当全面，看完之后发现自己并不太懂CSS相对单位，也希望分享给大家，所以有了这个译文系列。（若有勘误或翻译建议，欢迎 <a href="https://github.com/YuyingWu/blog/tree/dev/source/_posts" target="_blank" rel="noopener">Github PR</a> ^_^）</p><p>《别说你懂CSS相对单位》系列译文：</p><ul><li><a href="/blog/archives/css-in-depth-relative-units/">如何更愉快地使用em</a></li><li><a href="/blog/archives/css-in-depth-stop-thinking-in-px/">如何更愉快地使用rem</a> [本文]</li><li><a href="/blog/archives/css-in-depth-viewport-relative-units/">视口相关单位的应用</a></li><li><a href="/blog/archives/css-in-depth-unitless-number/">无单位数字和行高</a></li><li><a href="/blog/archives/css-in-depth-css-variables/">CSS自定义属性</a></li></ul><p>本文对应的章节目录：</p><ul><li>2.2 em和rem<ul><li>2.2.2 对font-size使用rem<ul><li>可用性：对font-size使用相对长度单位</li></ul></li></ul></li><li>2.3 停止使用像素思维去思考<ul><li>2.3.1 设置一个合理的字号默认值</li><li>2.3.2 让这个面板变得“响应式”</li><li>2.3.3 调整单个组件的大小</li></ul></li></ul><hr><h2 id="2-2-em和rem"><a href="#2-2-em和rem" class="headerlink" title="2.2 em和rem"></a>2.2 em和rem</h2><h3 id="2-2-2-对font-size使用rem"><a href="#2-2-2-对font-size使用rem" class="headerlink" title="2.2.2 对font-size使用rem"></a>2.2.2 对font-size使用rem</h3><p>当浏览器解析HTML文档时，创建了一个用来代表页面元素的集合，叫做DOM（文档对象模型，Document Object Model）。树状结构，每一个节点代表一个元素。<code>&lt;html&gt;</code>就是顶层节点（根节点），在下面的是它的子节点<code>&lt;head&gt;</code>和<code>&lt;body&gt;</code>，再往下就是它们的子节点，还有后代节点，如此类推。</p><p>根节点是文档里所有其他元素的祖先。它有一个特别的伪类（pseudo-class）选择器（:root），在样式表里可以用这个选择器表示。使用带类名的类型选择器html，或者直接用标签选择器，效果是一样的。</p><p>rem是根em（root em）的缩写。rem是和根元素关联的，不依赖当前元素。不管你在文档中的什么地方使用这个单位，1.2rem的计算值是相等的，等于1.2倍的根元素的字号大小。下面的示例代码中，声明了根元素的字号大小，并在嵌套的无序列表中使用rem声明字号大小。</p><p>[ 代码片段 2.10 使用rem声明字号大小 ]</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">:root &#123;                    1</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1em</span>;          2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: .<span class="number">8rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1 伪类 :root 等价于 html 选择器</li><li>2 使用浏览器的默认字号大小（16px）</li></ul><p>在这个示例里，根字号大小是浏览器的默认大小16px（根元素的1em等于浏览器的默认字号大小）。无序列表的字号大小为0.8rem，计算结果是12.8px。因为这只跟根元素相关，尽管你在列表里嵌套了列表，嵌套子列表的字号仍然保持不变。</p><blockquote><h4 id="可用性：对font-size使用相对长度单位"><a href="#可用性：对font-size使用相对长度单位" class="headerlink" title="可用性：对font-size使用相对长度单位"></a>可用性：对font-size使用相对长度单位</h4><p>一些浏览器会提供给用户2种方式定制文字的大小：缩放和设置一个默认的字号大小。通过按Ctrl+或者Ctrl-，用户可以对页面进行缩放。这在视觉上会把整个页面的文字或图片（其实是所有元素）都放大或缩小了。在一些浏览器，这个改变只针对当前的标签页且是临时的，不会影响到新开的标签页。 </p><p>设置默认字号大小，会有点不一样。不仅仅是设置的入口比较难找（一般在浏览器的设置页），而且这个设置是永久的，直到用户把默认值还原。值得注意的是，这个设置对使用px或其他绝对单位定义的字号大小无效。因为默认字号大小对一些用户是必要的，尤其是弱视的群体，你应该用相对单位或百分比来定义字号的大小。</p></blockquote><p>rem简化了很多em带来的复杂度。事实上，rem提供了一个在px和em间的相对单位折中解决方案，而且更易于使用。那么，是不是意味着你应该在对所有元素都使用rem，去掉其他长度单位呢？当然不是。</p><p>在CSS的世界里，这个答案通常是，看情况。rem只是你的工具箱中的其中一个。掌握CSS很重要的一点，就是学会分辨在什么场景下该使用什么工具。我的选择是，对<code>font-size</code>使用rem，对border使用px，对其他的度量方式如<code>padding</code>、<code>margin</code>、<code>border-radius</code>等使用em。然而在必要时，需要声明容器的宽度的话，我更喜欢使用百分比。</p><p>这样，字号大小就变得可预测，而当其他因素影响到元素的字号大小时，你也可以借助em去缩放元素的padding和margin。在border上使用像素是很合适的，尤其当你想要一根漂亮的线的时候。以上就是我对不同属性使用不同单位的理想方案，不过我要再次声明，这些都是工具，在某些特定场景下，利用不同的工具可能取到更好的效果。</p><blockquote><p>提示  </p><p>当你不确定的时候，对<code>font-size</code>使用rem，对<code>border</code>使用px，以及对其他大多数属性使用em。</p></blockquote><h2 id="2-3-停止使用像素思维去思考"><a href="#2-3-停止使用像素思维去思考" class="headerlink" title="2.3 停止使用像素思维去思考"></a>2.3 停止使用像素思维去思考</h2><p>把页面的根元素字号大小定义为0.625em或者62.5%，在最近几年来，这样的用法很常见，这是一种模式，或者更贴切地说，这是一种反模式。</p><p>[ 代码片段 2.11 反模式：全局地把font-size定义为10px ]</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: .<span class="number">625em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我并不推荐这种用法。这个用法把浏览器默认的字号大小16px缩小到10px。这样做的好处是简化了计算，如果设计师告诉你字号大小应该是14px，那你可以很轻易地计算出1.4rem，毕竟我们还是在使用相对单位。</p><p>一开始，这看起来很方便，但事实上这样的实现方式有两个问题。第一，强制你写了很多重复的样式代码。10px对于大多数文本来说太小了，你需要在整个页面中，来来回回地覆盖它。你会发现，自己把一段段落（<code>&lt;p&gt;</code>）的字号大小声明为1.4rem，然后又把导航（<code>&lt;nav&gt;</code>）的链接字号大小声明为1.4rem，样式代码中还有很多这样的用法。这样引入了更高的错误风险，当你需要修改时发现代码耦合程度比较高，同时也会让样式文件变大。</p><p>第二个问题是，你这么做的时候，其实你还是在用像素的思维在思考。虽然在代码里写的是<code>1.4rem</code>，但是在你的脑子里，其实还是想的是<code>14px</code>。在响应式网页开发中，你应该学会适应那些“模糊”的值。1.2em实际等于多少像素，并不重要，你只需要知道这是比继承的字号大一点点，那就足够了。而且，如果在屏幕上这不是你想要的效果，那就改吧。这是需要时间实验和试错的，但事实上，使用px的时候我们也需要这样做。（在第13章，我们会有更具体的方式来优化这个实现方式。）</p><p>当使用em时，我们很容易陷入纠结，这个值转化成像素值会是多少呢？尤其对于字号大小。你一直在乘和除以em值，这样你很快就会疯掉了。相反，我希望你可以接受一项挑战，尝试培养先开始使用em的习惯。如果你习惯使用像素，那转成em是需要一定时间和练习的，但相信我，这很值得。</p><p>这不是在说你再也不使用像素了。如果你跟一个设计师合作，你可能需要用更精确的像素值去沟通，这没问题的。在项目的开始，你需要声明一个基础的字号大小（通常是对标题或者标注的常用字号）。使用绝对值去描述大小，往往会更加容易。</p><p>转换成rem会有计算环节，那就让计算器去忙吧（通常我会在Mac电脑上按<code>cmd+空格</code>，在Spotlight里计算）。首先在根元素上声明根字号大小，从那开始，使用像素应该是例外的情况，而不是常态。</p><p>在这章内容里，我还是会持续地聊起像素。这会有助于我解释相对单位的工作原理，同时也能帮助你培养计算em值的习惯。在这章之后，我基本会使用相对单位来讨论字号的大小。</p><h3 id="2-3-1-设置一个合理的字号默认值"><a href="#2-3-1-设置一个合理的字号默认值" class="headerlink" title="2.3.1 设置一个合理的字号默认值"></a>2.3.1 设置一个合理的字号默认值</h3><p>先假设你想把默认字号设定为14px。把10px设定为基准值，再在页面中去覆盖它的写法，我们不推荐这种写法，相反，你应该在根元素上直接声明一个值。<br>在这个代码片段里，目标字号值是继承的，浏览器的默认值16px，那么14/16 = 0.875。</p><p>把下面的代码添加到一个新的样式表的最上面，我们会在这上面添加其他代码。这里设定根元素（<code>&lt;html&gt;</code>）的默认字号大小。</p><p>[ 代码片段 2.12 设定正确的默认字号大小 ]</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:root &#123;                    1</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0.875em</span>;      2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1 或者使用 HTML 选择器</li><li>2 14/16（期望值px / 继承值px）等于0.875</li></ul><p>现在，你的期望基准字号14px对整个页面的元素有效，你不需要在其他地方重新声明了。你只需要在设计不一样的地方修改成新的字号，譬如标题。</p><p>我们一起来创建图2.7那样的面板吧！你创建的这个面板，基于14px字号，使用相对单位。</p><p>[ 图 2.7 使用相对单位和继承字号的面板 ]</p><p><img src="http://sinacloud.net/woodysblog/css-in-depth/02fig07_alt.jpg" alt="&quot;图 2.7&quot;"></p><p>下面是模板，加到你的页面吧。</p><p>[ 代码片段 2.13 面板的模板 ]</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> class=<span class="string">"panel"</span>&gt;</span><br><span class="line">  &lt;h2&gt;Single-origin&lt;/h2&gt;</span><br><span class="line">  &lt;<span class="keyword">div</span> class=<span class="string">"panel-body"</span>&gt;</span><br><span class="line">    We have built partnerships <span class="keyword">with</span> small farms around <span class="keyword">the</span> world <span class="built_in">to</span></span><br><span class="line">    hand-select beans <span class="keyword">at</span> <span class="keyword">the</span> peak <span class="keyword">of</span> season. We <span class="keyword">then</span> carefully roast</span><br><span class="line">    <span class="keyword">in</span> &lt;<span class="keyword">a</span> href=<span class="string">"/batch-size"</span>&gt;small batches&lt;/<span class="keyword">a</span>&gt; <span class="built_in">to</span> maximize their</span><br><span class="line">    potential.</span><br><span class="line">  &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure><p>下一段代码是样式的。你会在<code>padding</code>和<code>border-radius</code>使用<code>em</code>，标题的字号使用<code>rem</code>，以及<code>border</code>使用<code>px</code>。把下面代码添加到你的样式表吧。</p><p>[ 代码片段 2.14 使用相对单位的面板 ]</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.panel</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1em</span>;                    1</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0.5em</span>;            1</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#999</span>;          2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.panel</span> &gt; <span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">0</span>;                   3</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0.8rem</span>;               4</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;               4</span><br><span class="line">  <span class="attribute">text-transform</span>: uppercase;       4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1 对padding和border-radius使用em</li><li>2 用1px定义细边框</li><li>3 把面板上面多余的空间去掉，更多解释看第3章</li><li>4 用rem控制标题的字号大小</li></ul><p>这段代码给面板添加了一个细边框以及定义了标题的样式。我希望标题的字号小一点，但要加粗和全是大写。（你可以根据自己的设计，把字号改大点或者使用不同的排版方式）</p><p>第二个选择器<code>&gt;</code>是一个直接后代组合选择符（direct descendant combinator），它代表的是<code>.panel</code>下的子元素<code>h2</code>。更完整的选择器和组合选择符的索引可以看附录A。</p><p>在代码片段2.13中，为了更清晰看到效果，我给<code>body</code>添加了一个类<code>panel-body</code>，不过你会发现，在你自己的代码里是不需要的。因为这个元素从根元素上继承了字号大小，它已经是你想要看到的那样。</p><h3 id="2-3-2-让这个面板变得“响应式”"><a href="#2-3-2-让这个面板变得“响应式”" class="headerlink" title="2.3.2 让这个面板变得“响应式”"></a>2.3.2 让这个面板变得“响应式”</h3><p>我们再更深入地看看这个问题。你可以根据屏幕尺寸的变化，添加媒体查询来改变基础字号大小，这可以令面板在不同尺寸的屏幕下，有不同的大小变化。（见图2.8）</p><p>[ 图 2.8 在不同屏幕大小的响应式面板：300px（左上角），800px（右上角），1440px（下面） ]</p><p><img src="http://sinacloud.net/woodysblog/css-in-depth/02fig08_alt.jpg" alt="&quot;图 2.8&quot;"></p><blockquote><p>媒体查询（media query） —— 通过<code>@media</code>规则来声明样式，在不同的屏幕尺寸或者媒体类型（如打印机或显示器）下，触发对应的样式控制。这是响应式设计的关键要素。详情看代码片段2.15的这个例子，我在第8章会更深入的讨论媒体查询这个话题。</p></blockquote><p>为了实现上面说的效果，把你的样式代码改成这样。</p><p>[ 代码片段 2.15 ]</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">:root &#123;                            1</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0.75em</span>;               1</span><br><span class="line">&#125;                                  1</span><br><span class="line"></span><br><span class="line">@<span class="keyword">media</span> (min-width: 800px) &#123;        2</span><br><span class="line">  :root &#123;                          2</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0.875em</span>;            2</span><br><span class="line">  &#125;                                2</span><br><span class="line">&#125;                                  2</span><br><span class="line"></span><br><span class="line">@<span class="keyword">media</span> (min-width: 1200px) &#123;       3</span><br><span class="line">  :root &#123;                          3</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1em</span>;                3</span><br><span class="line">  &#125;                                3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1 针对所有屏幕，但是在更大的屏幕会被覆盖</li><li>2 针对比800px更宽的屏幕，覆盖默认样式代码</li><li>3 针对比1200px更宽的屏幕，覆盖以上两套样式代码</li></ul><p>第一套样式规则，声明了小屏幕中的默认字号大小，这是我们想要在较小的屏幕上看到的字号大小。然后使用媒体查询，把800px和1200px分别作为两个分水岭逐级增加字号的大小，覆盖掉默认的代码。</p><p>针对页面的根元素使用这些字号大小，响应式地重新定义em和rem对应的值，从而达到响应改变整个页面的效果。尽管你没有直接对这个面板做任何的修改，它现在是响应式的。在小屏幕上，譬如一台手机，字号大小会被渲染成更小的（12px）。然后，在更大的屏幕上，宽大于800px和大于1200px的，组件的字号会分别放大到14px和16px。改变你的浏览器窗口，看看组件是怎么变化的吧。</p><p>如果你在整个页面中像这样严格使用相对单位，整个页面会随着视窗大小放大和缩小。这会是你的响应式策略里很重要的一部分。上面的2套媒体查询声明代码，可以帮助你节省在页面的其他部分使用媒体查询的额外代码。不过，如果你在元素中声明的字号大小是以像素为单位的，那就不会产生任何效果了。</p><p>类似地，如果你的老板或者客户觉得现在网站的字号太小或者太大，你随时可以做到通过修改一行代码影响到全局的元素，这项改变会影响到页面上的其他元素，不费吹灰之力。</p><h3 id="2-3-3-调整单个组件的大小"><a href="#2-3-3-调整单个组件的大小" class="headerlink" title="2.3.3 调整单个组件的大小"></a>2.3.3 调整单个组件的大小</h3><p>你也可以通过使用em缩放页面上的一个独立组件。有时，你可能会需要界面上的某些组件可以有个大号的版本。在我们的面板上这么做吧，首先你需要给面板添加一个类名<code>large</code>：<code>&lt;div class=&quot;panel large&quot;&gt;</code>。</p><p>在图2.9，我们看到了面板的普通版和大号版的比较。效果类似响应式面板，但是两种尺寸是可以同时在同一个页面中使用的。</p><p>[ 图 2.9 在一个页面上的普通尺寸面板和大号面板 ]</p><p><img src="http://sinacloud.net/woodysblog/css-in-depth/02fig09_alt.jpg" alt="&quot;图 2.9&quot;"></p><p>我们来对面板的字号声明方式做一些小的修改。你还是在使用相对单位，但需要调整它们的基准值。第一点，给每个面板的父元素字号大小的定义<code>font-size: 1rem</code>。这里指的是，不管在什么地方使用这个面板，每个面板的字号大小是一个确定值。</p><p>第二点，使用em重新声明标题的字号大小，而不使用rem，这样标题就可以和刚才声明的父元素字号1rem关联起来。下面是对应的代码，更新下你的样式表代码吧。</p><p>[ 代码片段 2.16 创建一个面板的大号版本 ]</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.panel</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1rem</span>;               1</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#999</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0.5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.panel</span> &gt; <span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0.8em</span>;              2</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">text-transform</span>: uppercase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1 给组件声明确定的字号大小</li><li>2 其他元素的字号大小用em和父元素字号关联</li></ul><p>这些修改看起来并没有影响面板的样式，但是现在你已经准备好了，做一个大号的面板只需要修改一小行代码。你需要做的，就是把父元素字号大小改写成1rem以外的一个值。因为其他元素的计算方式都依赖父元素的字号大小，只要修改它，整个面板的相关尺寸都会发生改变。添加下一个CSS代码片段到你的样式表，定义一个大号面板吧。</p><p>[ 代码片段 2.17 利用一行代码放大整个面板 ]</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.panel</span><span class="selector-class">.large</span> &#123;               <span class="number">1</span></span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.2rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1 组合选择器指向同时有panel类和large类的元素</li></ul><p>现在，你可以给普通面板添加<code>class=&quot;panel&quot;</code>和给大号面板添加<code>class=&quot;panel large&quot;</code>。类似地，你也可以定义一个小号版本，只需要把父元素的字号设得比1rem小。如果这个面板是一个更复杂的组件，包含多种字号大小或padding，也只需要一个声明就可以重置大小，只要所有的子元素都是使用em声明的。</p><hr><p>《别说你懂CSS相对单位》系列译文：</p><ul><li><a href="/blog/archives/css-in-depth-relative-units/">如何更愉快地使用em</a></li><li><a href="/blog/archives/css-in-depth-stop-thinking-in-px/">如何更愉快地使用rem</a> [本文]</li><li><a href="/blog/archives/css-in-depth-viewport-relative-units/">视口相关单位的应用</a></li><li><a href="/blog/archives/css-in-depth-unitless-number/">无单位数字和行高</a></li><li><a href="/blog/archives/css-in-depth-css-variables/">CSS自定义属性</a></li></ul><p>章节：</p><ul><li>2.1 相对单位值的魔力<ul><li>2.1.1 完美像素设计（pixel-perfect design）的挣扎</li><li>2.1.2 完美像素网页的终结</li><li>像素（pixel）、点（point）和pc（pica）</li></ul></li><li>2.2 em和rem<ul><li>2.2.1 对font-size使用em<ul><li>当我们在一个元素内用em同时声明font-size和其他属性</li><li>字号收缩问题</li></ul></li><li>2.2.2 对font-size使用rem<ul><li>可用性：对font-size使用相对长度单位</li></ul></li></ul></li><li>2.3 停止使用像素思维去思考<ul><li>2.3.1 设置一个合理的字号默认值</li><li>2.3.2 让这个面板变得“响应式”</li><li>2.3.3 调整单个组件的大小</li></ul></li><li>2.4 视口相关单位（viewport-relative units）<ul><li>CSS3</li><li>2.4.1 在font-size上使用vw</li><li>2.4.2 在font-size上使用calc()</li></ul></li><li>2.5 不带单位的数字（unitless number）和行高（line-height）</li><li>2.6 自定义属性（也叫“CSS变量”）<ul><li>2.6.1 动态改变自定义属性的值</li><li>2.6.2 通过JavaScript改变自定义属性的值</li><li>2.6.3 初探自定义属性</li></ul></li><li>总结</li></ul><blockquote><p>原著版权信息：</p><p>作者：Keith J.Grant<br>书籍：CSS in Depth<br>章节：<a href="https://livebook.manning.com/#!/book/css-in-depth/chapter-2" target="_blank" rel="noopener">Working with relative units</a>   </p></blockquote><hr><p>笔者 @Yuying Wu，前端爱好者 / 鼓励师 / 新西兰打工度假 / 铲屎官。目前就职于某大型电商的B2B前端团队。</p><p>感谢你读到这里，对上文若有任何疑问或建议，欢迎留言。</p><p>如果你和我一样喜欢前端，喜欢捣腾独立博客或者前沿技术，或者有什么职业疑问，欢迎关注我以及各种交流哈。</p><p>独立博客：<a href="http://wuyuying.com/">wuyuying.com</a><br>知乎ID：<a href="https://www.zhihu.com/people/yuying_wu/posts" target="_blank" rel="noopener">@Yuying Wu</a><br>Github：<a href="https://github.com/YuyingWu" target="_blank" rel="noopener">Yuying Wu</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前段时间试译了Keith J.Grant的CSS好书《CSS in Depth》，其中的第二章&lt;a href=&quot;https://livebook.manning.com/#!/book/css-in-depth/chapter-2&quot; target=&quot;_blank&quot; rel=
      
    
    </summary>
    
    
      <category term="front-end" scheme="http://wuyuying.com/tags/front-end/"/>
    
      <category term="css" scheme="http://wuyuying.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>如何更愉快地使用em —— 别说你懂CSS相对单位</title>
    <link href="http://wuyuying.com/archives/css-in-depth-relative-units/"/>
    <id>http://wuyuying.com/archives/css-in-depth-relative-units/</id>
    <published>2018-07-05T05:28:00.000Z</published>
    <updated>2018-08-17T12:47:37.598Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间试译了Keith J.Grant的CSS好书《CSS in Depth》，其中的第二章<a href="https://livebook.manning.com/#!/book/css-in-depth/chapter-2" target="_blank" rel="noopener">《Working with relative units》</a>，书中对relative units的讲解和举例可以说相当全面，看完之后发现自己并不太懂CSS相对单位，也希望分享给大家，所以有了这个译文系列。（若有勘误或翻译建议，欢迎 <a href="https://github.com/YuyingWu/blog/tree/dev/source/_posts" target="_blank" rel="noopener">Github PR</a> ^_^）</p><p>《别说你懂CSS相对单位》系列译文：</p><ul><li><a href="/blog/archives/css-in-depth-relative-units/">如何更愉快地使用em</a> [本文]</li><li><a href="/blog/archives/css-in-depth-stop-thinking-in-px/">如何更愉快地使用rem</a></li><li><a href="/blog/archives/css-in-depth-viewport-relative-units/">视口相关单位的应用</a></li><li><a href="/blog/archives/css-in-depth-unitless-number/">无单位数字和行高</a></li><li><a href="/blog/archives/css-in-depth-css-variables/">CSS自定义属性</a></li></ul><p>本文对应的章节目录：</p><ul><li>2.1 相对单位值的魔力<ul><li>2.1.1 完美像素设计（pixel-perfect design）的挣扎</li><li>2.1.2 完美像素网页的终结</li><li>像素（pixel）、点（point）和pc（pica）</li></ul></li><li>2.2 em和rem<ul><li>2.2.1 对font-size使用em<ul><li>当我们在一个元素内用em同时声明font-size和其他属性</li><li>字号收缩问题</li></ul></li></ul></li></ul><hr><p>CSS提供了很多种方式去定义一个值。大家最熟悉的可能也是最容易使用的就是像素（pixel），这被称做“绝对单位”。也就是说，5px在不同的场景下是一样的值。而其他的单位，如em和rem，不是绝对的而是相对的。相对单位的值会根据外部影响因素的变化而变化。例如，2em的值取决于你在哪个元素使用它（有时甚至是哪个属性）。很自然，相对单位使用起来会比较困难。</p><p>开发人员，甚至有经验的CSS开发人员，往往不喜欢跟相对单位打交道，其中包括臭名昭著的em。em的值可以被改变的方式似乎难以预测，没有px那么清晰。在本章中，我将揭开相对单位的神秘面纱。首先，我会解释它们为CSS带来的独特价值，然后我会帮助你更好地理解它们。我会解释它们的工作原理，也会告诉你怎么征服它们那看似不可预测的特性。你可以让相对单位为你所用，正确地运行，它们将让你的代码变得更加简单、灵活和容易使用。</p><h2 id="2-1-相对单位值的魔力"><a href="#2-1-相对单位值的魔力" class="headerlink" title="2.1 相对单位值的魔力"></a>2.1 相对单位值的魔力</h2><p>CSS是通过迟绑定（late-binding）的方式把样式渲染到web页面上的：内容和它的样式会在各自的渲染完成之后再合并到一起。比起其他类型的图形设计，这给设计过程添加了它们没有的复杂程度，同时也赋予CSS更强大的能力 —— 一个样式表可供成百上千个页面使用。此外，用户可以直接改变页面的最终呈现方式。举个例子，用户可以更改默认字号大小或者调整浏览器窗口的大小。</p><p>在早期的计算机应用程序开发以及传统出版行业中，开发人员或出版商清楚知道所在的媒介存在哪些限制。对于一个特定的应用程序，窗口可能是400px宽，300px高，或者一个版面可能是4英寸宽，6½英寸高。因此，当开发人员布局应用程序的按钮和文本时，他们很清楚这些元素可以做成什么尺寸，以及在屏幕上还有多少空间可以留给他们用来处理其他元素。然而在网页上，情况却不是这样的。</p><h3 id="2-1-1-完美像素设计（pixel-perfect-design）的挣扎"><a href="#2-1-1-完美像素设计（pixel-perfect-design）的挣扎" class="headerlink" title="2.1.1 完美像素设计（pixel-perfect design）的挣扎"></a>2.1.1 完美像素设计（pixel-perfect design）的挣扎</h3><p>在web环境下，用户可以将浏览器窗口设置为任意大小，且CSS需要去适应它。另外，用户可以在一个页面打开后，再调整它的大小，CSS也需要去适应这些新的约束条件。这说明了在你创建页面时样式还没有被调用，而是当页面在屏幕上渲染时，浏览器才会去计算样式的规则。</p><p>这给CSS增加了一层抽象的概念。我们不应该根据理想的情境来设计元素，而是应该声明一些样式规则，可以让该元素在任何场景下都能跑通。对于现在的互联网，你的页面可能要在一个4英寸的手机屏幕上展示，也可能在一个30英寸的大屏幕上。</p><p>长久以来，设计师大量使用“完美像素”设计，缓解了这个问题带来的复杂性。他们会创建一个有着严格定义的容器，通常是一个大约800px宽的居中的纵向列。然后在这些限制下他们再进行设计，这跟他们的前辈在原生应用程序或印刷出版物中做的设计或多或少有点类似。</p><h3 id="2-1-2-完美像素网页的终结"><a href="#2-1-2-完美像素网页的终结" class="headerlink" title="2.1.2 完美像素网页的终结"></a>2.1.2 完美像素网页的终结</h3><p>随着技术的进步和制造商推出更高分辨率的显示器，像素完美的设计方式慢慢开始崩溃。在21世纪初期，把页面设计成1024px宽还是800px宽，哪个是更保险的展示策略？开发者针对这个问题讨论得很多。然后，我们又针对能否改成1280px宽有类似的讨论。是时候做个决定了。把我们网站的内容宽度做得宽一点（相对于落伍的小电脑屏幕），还是做得窄一点（相对于新出的大屏幕），哪个选择更好呢？</p><p>当智能手机出现的时候，开发人员终于要（被迫）要停止假装每个人都可以在他们的网站上获得相同的体验了。不管我们喜不喜欢，我们都得放弃已知的多栏定宽（px）布局，并开始考虑响应式设计。我们再也不能逃避CSS所带来的抽象概念（abstraction），相反，我们要去拥抱这项特性。</p><blockquote><p>响应式 —— 在CSS中，这指的针对不同大小的浏览器窗口，用不同的方式响应更新页面的样式。我们要对不同尺寸的手机、平板电脑或桌面显示器多花心思了。我们将在<a href="https://livebook.manning.com/#!/book/css-in-depth/chapter-8/ch08" target="_blank" rel="noopener">第8章</a>中详细介绍响应式设计，但在本章中，我会先给大家介绍一些重要的基础概念。</p></blockquote><p>增加的抽象概念意味着额外的复杂性。如果我设定一个宽度为800px的元素，那么它在一个更小的窗口中会怎么显示呢？如果一个横向菜单不能全部在一行展示完，它又会怎么展示？在编写CSS时，你需要能够同时考虑具体情况以及普适性的问题。如果针对一个特定的问题，你有多种方式可以解决，那么你应该选那个在多种不同场景下更通用的解决方案。</p><p>在抽象概念这个问题上，相对单位是CSS提供的工具之一。与其把字号大小设置为14px，你可以把它设置为与窗口大小成比例缩放。或者，你可以设置页面上所有元素是依赖基础字号大小的变化而变化的，然后用一行代码就可以达到调整整个页面的目的。接下来，我们来看看CSS提供了哪些方式来实现以上的效果。</p><blockquote><h3 id="像素（pixel）、点（point）和pc（pica）"><a href="#像素（pixel）、点（point）和pc（pica）" class="headerlink" title="像素（pixel）、点（point）和pc（pica）"></a>像素（pixel）、点（point）和pc（pica）</h3><p>CSS支持一些绝对长度单位，其中最常见也最基本的是像素（px）。较不常见的绝对单位有毫米（mm，millimeter）、厘米（cm，centimeter）、英寸（in.，inch）、点（pt，point，印刷术语，长度为1/72 inch）以及pc（pica，印刷术语，长度为12 points）。如果你想了解其中的计算方式，以上的长度单位都可以直接转换成另一个单位：1 inch = 25.4 mm = 2.54 cm = 6 pc = 72 pt = 96 px。因此，16px与12pt（16/96×72）是等价的。设计师通常更熟悉点（point）的使用，而开发人员更习惯于像素，因此在和设计师沟通时，你可能需要在两者之间做一些计算工作。  </p><p>像素这个名字有点误导性 —— 1 CSS像素并不严格等同于显示器的1像素，在高分辨率显示器（如“Retina显示屏”）上尤其明显。尽管根据浏览器、操作系统和硬件的不同，CSS的测量值可能会有细微的差别，但96px总是会大致等于屏幕上的物理1英寸。（尽管有可能会因某些设备或用户设置而异。）</p></blockquote><h2 id="2-2-em和rem"><a href="#2-2-em和rem" class="headerlink" title="2.2 em和rem"></a>2.2 em和rem</h2><p>em是最常见的相对长度单位，这是排版中使用的一种度量方式，基准值是当前元素的字号大小。 在CSS中，1em表示当前元素的字号大小，实际值取决于在哪个元素上应用。图2.1展示了一个padding为1em的<code>div</code>。</p><p>[ 图 2.1：padding为1em的元素（添加虚线是为了让padding更明显）]</p><p><img src="http://sinacloud.net/woodysblog/css-in-depth/02fig01_alt.jpg" alt="&quot;图 2.1&quot;"></p><p>模板代码片段如下。这套样式规则定义字号为16px，也就是元素本身1em代表的值，然后再使用em来声明元素的padding。 把这段代码添加到一个新的样式表里，在<code>&lt;div class =&quot;padded&quot;&gt;</code>下随手写些文字，然后到浏览器看看效果吧。</p><p>代码片段 2.1：在padding上使用em</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.padded</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1em</span>;          1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1 把各个方向的padding的值设置为字号大小</li></ul><p>把<code>padding</code>赋值为1em，乘以字号，得到一个值为16px的<code>padding</code>渲染值。重点来了，使用相对单位声明的值会由浏览器转化为一个绝对值，我们称之为计算值。</p><p>在这个例子里，将<code>padding</code>改为2em会生成一个32px的计算值。如果同一个元素的另一个选择器，用一个不一样的字号值去覆盖它，这会改变em在这个域下的基准值，那么<code>padding</code>的计算值也会相应变化。</p><p>在设置<code>padding、height、width或border-radius</code>等属性时，使用em可能会很方便，因为如果它们继承了不同的字号大小，或者用户更改了字体设置，这些属性会均匀地缩放。</p><p>图2.2展示了两个不同大小的盒子。盒子内的<code>font-size</code>、<code>padding</code>和<code>border-radius</code>各不相同。</p><p>[ 图 2.2：有相对大小的padding和border-radius的元素 ]</p><p><img src="http://sinacloud.net/woodysblog/css-in-depth/02fig02.jpg" alt="&quot;图 2.2&quot;"></p><p>你可以通过用em声明<code>padding</code>和<code>border-radius</code>来给这些盒子声明样式规则。首先给每个元素设定<code>padding</code>和<code>border-radius</code>为1em，然后给每个盒子指定不同的字号，那么其他属性会跟着字号缩放。</p><p>在你的HTML代码里，创建如下的两个盒子，类名分别是<code>box-small</code>和<code>box-large</code>，代表两个字号修饰符。</p><p>[ 代码片段 2.2：在不同元素上使用em（HTML）]</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"box box-small"</span>&gt;</span>Small<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"box box-large"</span>&gt;</span>Large<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在，添加下面的样式到你的样式表。这里使用了em声明了一个盒子。还定义了小字号和大字号的修饰符，指定不同的字号大小。</p><p>[ 代码片段 2.3：在不同元素上使用em（CSS）]</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box-small</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">12px</span>;              <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box-large</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">18px</span>;              <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1 不同的字号大小，这会改变元素的em实际值的大小。</li></ul><p>这是em一个强大的功能。你可以定义一个元素的字号大小，然后使用一句简单的声明，就可以通过改变字号大小从而控制整个元素大小缩放。你后面将会创建另外一个这样的例子，不过首先，我们来讨论一下em和字号大小。</p><h3 id="2-2-1-对font-size使用em"><a href="#2-2-1-对font-size使用em" class="headerlink" title="2.2.1 对font-size使用em"></a>2.2.1 对font-size使用em</h3><p>当<code>font-size</code>使用em作为单位时，它的表现会有点不一样。我之前说过，em是以当前元素的字号大小作为基准值的。但是，如果你把一个元素的字号设为1.2em的时候，这是什么意思呢？一个元素的字号大小是不能等于它自己的1.2倍的。相反，在<code>font-size</code>上的em会先从继承到的字号大小衍生出来。</p><p>举个简单的例子，见图2.3。以下展示了一些不同字号大小的文字。在代码片段2.4，你会用到em来实现。</p><p>[ 图 2.3 以em为单位的两种不同的字号大小 ]</p><p><img src="http://sinacloud.net/woodysblog/css-in-depth/02fig03.jpg" alt="&quot;图 2.3&quot;"></p><p>在你的页面添加以下代码片段。第一行文字，在<code>&lt;body&gt;</code>标签里面，它会按body的字号大小渲染。第二部分，口号（slogan），继承父元素的字号大小。</p><p>[ 代码片段 2.4 相对<code>font-size</code>的模板 ]</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  We love coffee</span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"slogan"</span>&gt;</span>We love coffee<span class="tag">&lt;/<span class="name">p</span>&gt;</span>          1</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>1 slogan从<body>继承了字号大小。</body></li></ul><p>代码片段中，CSS代码片段声明了<code>body</code>的字号大小。为了更加清晰，在这里我用了px来声明。下一步，你可以用em来放大slogan的字号大小。</p><p>[ 代码片段 2.5：在font-size上使用em ]</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.slogan</span> &#123;                  <span class="number">1</span></span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.2em</span>;        <span class="number">1</span></span><br><span class="line">&#125;                          <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>1 计算：这个元素继承到字号，乘以1.2</li></ul><p>slogan声明的字号大小是1.2em，为了计算转换成像素值，你需要引用继承的字号16px，16 * 1.2 = 19.2，所以计算字号值是19.2px。</p><blockquote><p>提示 </p><p>如果你已经知道以px为单位的基础字号大小，但希望把它改用em声明，下面有个简单的计算公式：目标em值 = 目标像素值 / 父元素（被继承元素）像素值。举个例子，如果你想要一个10px的字号大小，父元素的字号是12px，10 / 12 = 0.8333em。如果你想要16px的字号大小，父元素字号是12px，那么 16 / 12 = 1.3333em。我们会在这章里多次用到这个计算公式。</p></blockquote><p>有一点对你很有帮助，对于大多数浏览器，默认字号大小是16px。技术上，关键字medium会被计算转换为16px。</p><h4 id="当我们在一个元素内用em同时声明font-size和其他属性"><a href="#当我们在一个元素内用em同时声明font-size和其他属性" class="headerlink" title="当我们在一个元素内用em同时声明font-size和其他属性"></a>当我们在一个元素内用em同时声明font-size和其他属性</h4><p>你已经使用过em声明<code>font-size</code>了（基于一个继承的字号大小值）。以及，你也曾经使用em声明其他属性，如<code>padding</code>和<code>border-radius</code>（基于当前元素的字号大小值）。当你针对同一个元素使用em声明<code>font-size</code>和其他属性的时候，em会变得很神奇。此时浏览器必须先计算<code>font-size</code>，然后基于这个值再去计算其他值。这些属性声明的时候使用的是相同的em值，但很可能它们会有不同的计算值。</p><p>在之前的例子里，我们计算到字号大小是19.2px（继承的16px乘以1.2em）。图2.4是相同的slogan元素，但有额外的1.2em <code>padding</code>以及为了让<code>padding</code>大小更加明显的灰色背景。可以看出，<code>padding</code>比<code>font-size</code>稍微大一些，尽管它俩声明的时候em值是一样的。</p><p>[ 图2.4 一个font-size为1.2em以及padding为1.2em的元素 ]</p><p><img src="http://sinacloud.net/woodysblog/css-in-depth/02fig04_alt.jpg" alt="&quot;图 2.4&quot;"></p><p>现在的情况是，这个段落从<code>body</code>继承了16px的字号大小，通过计算得到值为19.2px的字号计算值。这意味着，19.2px是1em在当前域的基础值，而这个值会被用作计算<code>padding</code>的值。对应的CSS代码在下面，更新你的样式表并查看你的测试页面吧。</p><p>[ 代码片段 2.6 在font-size和padding上使用em ]</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.slogan</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.2em</span>;             1</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1.2em</span>;               2</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1 赋值为 19.2 px</li><li>2 赋值为 23.04 px</li></ul><p>在这个例子里，<code>padding</code>的声明值为1.2em，乘以19.2px（当前元素的字号大小），计算出23.04px。我们可以看到，尽管<code>font-size</code>和<code>padding</code>声明时em值是一样的，但它们的计算值是不一样的。</p><h4 id="字号收缩问题"><a href="#字号收缩问题" class="headerlink" title="字号收缩问题"></a>字号收缩问题</h4><p>当你使用em声明多层嵌套的元素字号时，会产生意想不到的效果。要弄清楚每个元素的实际值，首先你需要知道它继承的父元素的字号大小，如果父元素的字号也是用em声明的，那么你需要知道它的父元素的字号大小，在dom树往上查，以此类推。</p><p>当你使用em声明列表的字号大小，列表嵌套了好几层，效果就更明显了。大多数web开发者会发现在他们的职业生涯里面，图2.5的列表嵌套形式有点眼熟。文字在逐步缩小！正是因为em带来的这一类烦人的问题，开发者才对em避而远之。</p><p>[ 图 2.5 嵌套列表中的字号缩小现象 ]</p><p><img src="http://sinacloud.net/woodysblog/css-in-depth/02fig05.jpg" alt="&quot;图 2.5&quot;"></p><p>当你多层嵌套列表，而每一层声明的字号大小以em为单位，字号收缩现象就会发生。在代码片段2.7和2.8的例子里，无序列表的字号是0.8em。这个选择器对页面上所有的ul有效，所以当一个列表从另外一个列表继承到字号大小的时候，em就产生复合效果。</p><p>[ 代码片段 2.7 在列表上使用em ]</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: .<span class="number">8em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[ 代码片段 2.8 多层嵌套的列表 ]</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Top level</span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span>                                    1</span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>Second level                      1</span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span>                                2</span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span>&gt;</span>Third level                   2</span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span>                            3</span><br><span class="line">              <span class="tag">&lt;<span class="name">li</span>&gt;</span>Fourth level              3</span><br><span class="line">                <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Fifth level<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>1 这个列表嵌套在第一个列表里，继承了它的字号大小</li><li>2 然后这个列表又嵌套在另一个列表里，继承了第二个列表的字号大小</li><li>3 ……以此类推</li></ul><p>每一个列表的字号大小是0.8乘以父元素的字号大小。这代表第一个列表的字号大小是12.8px，嵌套的子列表字号大小是10.24px（12.8px * 0.8），第三层列表的是8.192px，如此类推。同样地，如果你给字号大小的赋值大于1em，相反，文字的字号会一层层变大。我们想要的效果是像图2.6一样，在顶层声明字号的大小，但下面嵌套层级的列表字号保持不变。</p><p>[ 图 2.6 字号正常的多层嵌套列表 ]</p><p><img src="http://sinacloud.net/woodysblog/css-in-depth/02fig06.jpg" alt="&quot;图 2.6&quot;"></p><p>其中一种实现的方式可以看看代码片段2.9。第一个列表的字号大小还是0.8 em（见示例2.7），第二个选择器对嵌套在无序列表的无序列表有效 —— 也就是除了第一个无序列表以外的所有无序列表。现在嵌套的列表设定了跟父元素一致的字号大小，正如图2.6一样。</p><p>[ 代码片段 2.9 字号收缩现象的纠正 ]</p><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ul &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: .8em;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ul ul &#123;                1</span><br><span class="line">  <span class="attribute">font-size</span>: 1em;      1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1 嵌套在列表里面的列表，应该把字号大小设定为跟父元素一样</li></ul><p>这可以解决问题，但不是最优方案。因为你设置了一个字号值，马上用另一个选择器重写了这个规则。如果你可以使用针对嵌套的列表声明一个特定的选择器，避免互相覆盖，会是一个更好的方案。</p><p>到现在我们清楚了，如果你不是一个比较小心的人，你应该远离em。使用em作为<code>padding</code>、<code>margin</code>和元素缩放效果的单位挺好的，但当em遇上<code>font-size</code>时，事情可以变得很复杂。感谢上天，我们有个更好的选择 —— rem。</p><hr><p>《别说你懂CSS相对单位》系列译文：</p><ul><li><a href="/blog/archives/css-in-depth-relative-units/">如何更愉快地使用em</a> [本文]</li><li><a href="/blog/archives/css-in-depth-stop-thinking-in-px/">如何更愉快地使用rem</a></li><li><a href="/blog/archives/css-in-depth-viewport-relative-units/">视口相关单位的应用</a></li><li><a href="/blog/archives/css-in-depth-unitless-number/">无单位数字和行高</a></li><li><a href="/blog/archives/css-in-depth-css-variables/">CSS自定义属性</a></li></ul><p>章节：</p><ul><li>2.1 相对单位值的魔力<ul><li>2.1.1 完美像素设计（pixel-perfect design）的挣扎</li><li>2.1.2 完美像素网页的终结</li><li>像素（pixel）、点（point）和pc（pica）</li></ul></li><li>2.2 em和rem<ul><li>2.2.1 对font-size使用em<ul><li>当我们在一个元素内用em同时声明font-size和其他属性</li><li>字号收缩问题</li></ul></li><li>2.2.2 对font-size使用rem<ul><li>可用性：对font-size使用相对长度单位</li></ul></li></ul></li><li>2.3 停止使用像素思维去思考<ul><li>2.3.1 设置一个合理的字号默认值</li><li>2.3.2 让这个面板变得“响应式”</li><li>2.3.3 调整单个组件的大小</li></ul></li><li>2.4 视口相关单位（viewport-relative units）<ul><li>CSS3</li><li>2.4.1 在font-size上使用vw</li><li>2.4.2 在font-size上使用calc()</li></ul></li><li>2.5 不带单位的数字（unitless number）和行高（line-height）</li><li>2.6 自定义属性（也叫“CSS变量”）<ul><li>2.6.1 动态改变自定义属性的值</li><li>2.6.2 通过JavaScript改变自定义属性的值</li><li>2.6.3 初探自定义属性</li></ul></li><li>总结</li></ul><blockquote><p>原著版权信息：</p><p>作者：Keith J.Grant<br>书籍：CSS in Depth<br>章节：<a href="https://livebook.manning.com/#!/book/css-in-depth/chapter-2" target="_blank" rel="noopener">Working with relative units</a>  </p></blockquote><hr><p>笔者 @Yuying Wu，前端爱好者 / 鼓励师 / 新西兰打工度假 / 铲屎官。目前就职于某大型电商的B2B前端团队。</p><p>感谢你读到这里，对上文若有任何疑问或建议，欢迎留言。</p><p>如果你和我一样喜欢前端，喜欢捣腾独立博客或者前沿技术，或者有什么职业疑问，欢迎关注我以及各种交流哈。</p><p>独立博客：<a href="http://wuyuying.com/">wuyuying.com</a><br>知乎ID：<a href="https://www.zhihu.com/people/yuying_wu/posts" target="_blank" rel="noopener">@Yuying Wu</a><br>Github：<a href="https://github.com/YuyingWu" target="_blank" rel="noopener">Yuying Wu</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前段时间试译了Keith J.Grant的CSS好书《CSS in Depth》，其中的第二章&lt;a href=&quot;https://livebook.manning.com/#!/book/css-in-depth/chapter-2&quot; target=&quot;_blank&quot; rel=
      
    
    </summary>
    
    
      <category term="front-end" scheme="http://wuyuying.com/tags/front-end/"/>
    
      <category term="css" scheme="http://wuyuying.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>GraphQL小记</title>
    <link href="http://wuyuying.com/archives/graphql/"/>
    <id>http://wuyuying.com/archives/graphql/</id>
    <published>2018-06-26T13:32:09.000Z</published>
    <updated>2018-07-01T11:12:30.795Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://sinacloud.net/woodysblog/graphql/structure.png" alt="&quot;structure&quot;"></p><p>基于GraphQL、express、MongoDB、Apollo、React.js的小应用。<br>-&gt;&gt; 项目源码<a href="https://github.com/YuyingWu/playground/tree/master/graphql-playlist" target="_blank" rel="noopener">github传送门</a></p><p>内容包括：</p><ul><li>如何搭建基于GraphQL、express、MongoDB的后台服务器</li><li>如何定义数据模型</li><li>如何通过GraphiQL测试query和获取的数据结构，包括query（查询）和mutation（更新）</li><li>如何搭建可以跟graphql query通信的Apollo-React前端应用</li></ul><a id="more"></a><h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li>express<ul><li>express-graphql</li></ul></li><li>graphql</li><li>mongoose，连接server和数据库（mLab）</li><li><a href="https://mlab.com/" target="_blank" rel="noopener">mLab</a>，云端mongoDB</li></ul><h3 id="定义Book的Schema"><a href="#定义Book的Schema" class="headerlink" title="定义Book的Schema"></a>定义Book的Schema</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// schema.js</span></span><br><span class="line"><span class="keyword">const</span> graphql = <span class="built_in">require</span>(<span class="string">'graphql'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; GraphQLObjectType, GraphQLString &#125; = graphql;</span><br><span class="line"><span class="keyword">const</span> BookType = <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">  name: <span class="string">'Book'</span>,</span><br><span class="line">  fields: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">    id: &#123; <span class="keyword">type</span>: GraphQLString &#125;,</span><br><span class="line">    genre: &#123; <span class="keyword">type</span>: GraphQLString &#125;,</span><br><span class="line">    name: &#123; <span class="keyword">type</span>: GraphQLString &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="定义RootQuery"><a href="#定义RootQuery" class="headerlink" title="定义RootQuery"></a>定义RootQuery</h3><ul><li>book的类型是一个Graphql对象类型<code>BookType</code>；</li><li>args是发起这个query时，需要传入什么参数，这里是<code>id</code>；</li><li>resolve是根据参数从数据库查询数据的逻辑。</li></ul><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// schema.js</span></span><br><span class="line"><span class="keyword">const</span> RootQuery = <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">  <span class="attribute">name</span>: <span class="string">'RootQueryType'</span>,</span><br><span class="line">  <span class="attribute">fields</span>: &#123;</span><br><span class="line">    <span class="attribute">book</span>: &#123;</span><br><span class="line">      <span class="attribute">type</span>: BookType,</span><br><span class="line">      <span class="attribute">args</span>: &#123;</span><br><span class="line">        <span class="attribute">id:</span><span class="string"> &#123; type</span>: GraphQLString &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      resolve(<span class="built_in">parent</span>, args) &#123;</span><br><span class="line">        <span class="comment">// code to get data from db / other source</span></span><br><span class="line">        <span class="comment">// args.id</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="打开服务器的GraphiQL的面板"><a href="#打开服务器的GraphiQL的面板" class="headerlink" title="打开服务器的GraphiQL的面板"></a>打开服务器的GraphiQL的面板</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="comment">// 访问 http://127.0.0.1:5000/graphql</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> graphqlHTTP = <span class="built_in">require</span>(<span class="string">'express-graphql'</span>);</span><br><span class="line"><span class="keyword">const</span> schema = <span class="built_in">require</span>(<span class="string">'./schema/schema'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/graphql'</span>, graphqlHTTP(&#123;</span><br><span class="line">  schema,</span><br><span class="line">  graphiql: <span class="literal">true</span></span><br><span class="line">&#125;));</span><br><span class="line">app.listen(<span class="number">5000</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'now listening for requests on port 5000, http://127.0.0.1:5000/'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后在GraphiQL面板，查询对应book的内容。</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># Graphiql的查询语句</span></span><br><span class="line">&#123;</span><br><span class="line">  book(id: <span class="string">"1"</span>) &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta"># &#123;</span></span><br><span class="line"><span class="meta">#   "data": &#123;</span></span><br><span class="line"><span class="meta">#    "book": &#123;</span></span><br><span class="line"><span class="meta">#      "name": "Name of the Wind"</span></span><br><span class="line"><span class="meta">#     &#125;</span></span><br><span class="line"><span class="meta">#   &#125;</span></span><br><span class="line"><span class="meta"># &#125;</span></span><br></pre></td></tr></table></figure><h3 id="Graphql提供的类型-方法"><a href="#Graphql提供的类型-方法" class="headerlink" title="Graphql提供的类型/方法"></a>Graphql提供的类型/方法</h3><p><strong>GraphQLID</strong>，接受query中的字符串或数字类型的参数，转成JavaScript的string类型。<br><strong>GraphQLInt</strong>，number类型。<br><strong>GraphQLNonNull</strong>，使用方式<code>type: new GraphQLNonNull(GraphQLInt)</code>，说明该字段的数据类型为int且必填。</p><h3 id="关联类型（relative-type）"><a href="#关联类型（relative-type）" class="headerlink" title="关联类型（relative type）"></a>关联类型（relative type）</h3><p>把AuthorType作为BookType的关联类型（实现功能，每本书有个作者）</p><ul><li>声明一个字段<code>author</code>，类型为<code>AuthorType</code></li><li>在<code>resolve</code>中，参数<code>parent</code>带有当前query的返回结果，从数据库中查询<code>id</code>等于当前book的<code>authorId</code>的作者信息，作为<code>author</code>的返回值</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const <span class="type">BookType</span> = <span class="keyword">new</span> <span class="type">GraphQLObjectType</span>(&#123;</span><br><span class="line">  name: <span class="symbol">'Boo</span>k',</span><br><span class="line">  fields: () =&gt; (&#123;</span><br><span class="line">    id: &#123; <span class="class"><span class="keyword">type</span></span>: <span class="type">GraphQLID</span> &#125;,</span><br><span class="line">    genre: &#123; <span class="class"><span class="keyword">type</span></span>: <span class="type">GraphQLString</span> &#125;,</span><br><span class="line">    name: &#123; <span class="class"><span class="keyword">type</span></span>: <span class="type">GraphQLString</span> &#125;,</span><br><span class="line">    author: &#123;</span><br><span class="line">      <span class="class"><span class="keyword">type</span></span>: <span class="type">AuthorType</span>,</span><br><span class="line">      resolve(parent, args) &#123;</span><br><span class="line">        <span class="comment">// code to get data from db / other source</span></span><br><span class="line">        <span class="comment">// args.id</span></span><br><span class="line">        <span class="keyword">return</span> _.find(authors, &#123;</span><br><span class="line">          id: parent.authorId</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当关联类型需要返回一个数组</p><p>字段<code>books</code>返回<code>BookType</code>的数组，借助<code>GraphQLList</code>。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const <span class="type">AuthorType</span> = <span class="keyword">new</span> <span class="type">GraphQLObjectType</span>(&#123;</span><br><span class="line">  name: <span class="symbol">'Autho</span>r',</span><br><span class="line">  fields: () =&gt; (&#123;</span><br><span class="line">    id: &#123; <span class="class"><span class="keyword">type</span></span>: <span class="type">GraphQLID</span> &#125;,</span><br><span class="line">    name: &#123; <span class="class"><span class="keyword">type</span></span>: <span class="type">GraphQLString</span> &#125;,</span><br><span class="line">    age: &#123; <span class="class"><span class="keyword">type</span></span>: <span class="type">GraphQLInt</span> &#125;,</span><br><span class="line">    books: &#123;</span><br><span class="line">      <span class="class"><span class="keyword">type</span></span>: <span class="keyword">new</span> <span class="type">GraphQLList</span>(<span class="type">BookType</span>),</span><br><span class="line">      resolve(parent, args) &#123;</span><br><span class="line">        <span class="comment">// code to get data from db / other source</span></span><br><span class="line">        <span class="comment">// args.id</span></span><br><span class="line">        <span class="keyword">return</span> _.filter(books, &#123;</span><br><span class="line">          authorId: parent.id</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h3><p>数据库model的声明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// models/author.js</span></span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">const</span> Schema = mongoose.Schema;</span><br><span class="line"><span class="keyword">const</span> authorSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  name: <span class="built_in">String</span>,</span><br><span class="line">  age: <span class="built_in">Number</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = mongoose.model(<span class="string">'Author'</span>, authorSchema);</span><br></pre></td></tr></table></figure><p>在GraphQL schema中声明mutation<code>addAuthor</code>方法，把model<code>Author</code>的实例保存到数据库，且<code>return</code>相应数据。</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// schema.js</span></span><br><span class="line">const Mutation = <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">  name: 'Mutation',</span><br><span class="line">  fields: &#123;</span><br><span class="line">    addAuthor: &#123;</span><br><span class="line">      <span class="class"><span class="keyword">type</span>: <span class="title">AuthorType</span>,</span></span><br><span class="line">      args: &#123;</span><br><span class="line">        name: &#123; <span class="class"><span class="keyword">type</span>: <span class="title">GraphQLString</span> &#125;,</span></span><br><span class="line">        age: &#123; <span class="class"><span class="keyword">type</span>: <span class="title">GraphQLInt</span> &#125;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      resolve(parent, args) &#123;</span><br><span class="line">        <span class="comment">// 创建mongoose model `Author` 实例</span></span><br><span class="line">        <span class="keyword">let</span> author = <span class="keyword">new</span> Author(&#123;</span><br><span class="line">          name: args.name,</span><br><span class="line">          age: args.age</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mongoose model 实例的方法</span></span><br><span class="line">        <span class="keyword">return</span> author.save();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在GraphiQL中调用该mutation，执行添加author的操作，且获取添加后的数据结果。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GraphiQL</span></span><br><span class="line">mutation &#123;</span><br><span class="line">  addAuthor(<span class="string">name:</span> <span class="string">"wyy"</span>, <span class="string">age:</span> <span class="number">28</span>) &#123;</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回结果</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"data"</span>: &#123;</span><br><span class="line">    <span class="string">"addAuthor"</span>: &#123;</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">"wyy"</span>,</span><br><span class="line">      <span class="string">"age"</span>: <span class="number">28</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h2><h3 id="环境-1"><a href="#环境-1" class="headerlink" title="环境"></a>环境</h3><ul><li>React.js<ul><li>create-react-app</li></ul></li><li>Apollo系<ul><li>apollo-boost</li><li>graphql</li><li>react-apollo</li></ul></li></ul><h3 id="Step-1：连接React-component和Apollo-Provider"><a href="#Step-1：连接React-component和Apollo-Provider" class="headerlink" title="Step 1：连接React component和Apollo Provider"></a>Step 1：连接React component和Apollo Provider</h3><p>在整个React应用中，通过ApolloClient，打通graphql和react组件的连接。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">import</span> ApolloClient <span class="keyword">from</span> <span class="string">'apollo-boost'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ApolloProvider &#125; <span class="keyword">from</span> <span class="string">'react-apollo'</span>;</span><br><span class="line"><span class="keyword">const</span> client = <span class="keyword">new</span> ApolloClient(&#123;</span><br><span class="line">  uri: <span class="string">'http://localhost:5000/graphql'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ApolloProvider client=&#123;client&#125;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;h1&gt;hello, world&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">          &lt;BookList /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>ApolloProvider&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-2：graphql-query和React组件的数据交互"><a href="#Step-2：graphql-query和React组件的数据交互" class="headerlink" title="Step 2：graphql query和React组件的数据交互"></a>Step 2：graphql query和React组件的数据交互</h3><h4 id="1-声明graphql-query"><a href="#1-声明graphql-query" class="headerlink" title="1.声明graphql query"></a>1.声明graphql query</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// components/BookList.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; gql &#125; <span class="keyword">from</span> <span class="string">'apollo-boost'</span>;</span><br><span class="line"><span class="keyword">const</span> getBooksQuery = gql<span class="string">`</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  books &#123;</span></span><br><span class="line"><span class="string">    id</span></span><br><span class="line"><span class="string">    name</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><h4 id="2-利用Apollo连接gq-query和react-component"><a href="#2-利用Apollo连接gq-query和react-component" class="headerlink" title="2.利用Apollo连接gq query和react component"></a>2.利用Apollo连接<code>gq query</code>和react component</h4><p>结合<code>react-apollo</code>的<code>graphql</code>，以及刚才声明的query，把请求数据打进<code>BookList</code>的<code>props</code>。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; graphql &#125; from <span class="symbol">'react</span>-apollo';</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookList</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 具体组件实现 blah blah</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> graphql(getBooksQuery)(<span class="type">BookList</span>);</span><br></pre></td></tr></table></figure><p>假如，在一个组件内，需要注入多个query，可以利用<code>react-apollo</code>提供的<code>compose</code>方法。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; graphql, compose &#125; from <span class="symbol">'react</span>-apollo';</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookList</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 具体组件实现 blah blah</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> compose(</span><br><span class="line">  graphql(gqlQuery1, &#123; name: <span class="symbol">'gqlQuery</span>1' &#125;),</span><br><span class="line">  graphql(gqlQuery2, &#123; name: <span class="symbol">'gqlQuery</span>2' &#125;),</span><br><span class="line">)(<span class="type">BookList</span>);</span><br></pre></td></tr></table></figure><p><img src="http://sinacloud.net/woodysblog/graphql/gql-compose.png" alt="&quot;graphql compose&quot;"></p><h4 id="3-通过this-props-data获取请求数据"><a href="#3-通过this-props-data获取请求数据" class="headerlink" title="3.通过this.props.data获取请求数据"></a>3.通过this.props.data获取请求数据</h4><p>在server的graphiQL查询的数据结构如下。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"data"</span>: &#123;</span><br><span class="line">    <span class="attr">"books"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"5b374cdd5806e47eefce3734"</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"test"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在render输出client的this.props.data，可以发现props更新了两次。区别在于<code>loading</code>这个字段，这也可以作为一个判断的flag，当<code>loading</code>为<code>true</code>时，再进一步分析接口返回的数据结构。</p><p>第一次，<code>loading</code>为<code>true</code>，没有<code>books</code>这个字段。</p><p><img src="http://sinacloud.net/woodysblog/graphql/apollo-loading.png" alt="&quot;loading&quot;"></p><p>第二次，<code>loading</code>为<code>false</code>，而<code>books</code>返回了一个数组。</p><p><img src="http://sinacloud.net/woodysblog/graphql/apollo-loaded.png" alt="&quot;loaded&quot;"></p><h4 id="4-Mutation"><a href="#4-Mutation" class="headerlink" title="4. Mutation"></a>4. Mutation</h4><p>i. query的声明</p><p>值得注意的是，当调用mutation时，我们可能需要传入参数，如何获取从react组件传入的参数？可以利用query variables（query变量）实现。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// query.js</span></span><br><span class="line">const addBookMutation = gql`</span><br><span class="line"><span class="function"><span class="title">mutation</span><span class="params">(<span class="variable">$name</span>: String!, <span class="variable">$genre</span>: String!, <span class="variable">$authorId</span>: ID!)</span></span> &#123;</span><br><span class="line">  addBook(name: <span class="variable">$name</span>, genre: <span class="variable">$genre</span>, authorId: <span class="variable">$authorId</span>) &#123;</span><br><span class="line">    name</span><br><span class="line">    id</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p>ii. react component的数据交互</p><p>利用<code>react-apollo</code>的<code>compose</code>，把<code>addBookMutation</code>注入到<code>this.props</code>，通过<code>varibales</code>传入query变量。</p><p>而当我们希望在mutation之后重新获取某个query的数据时，可以在mutation操作中添加<code>refetchQueries</code>的回调。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// addBook.js</span></span><br><span class="line"><span class="function"><span class="title">addBook</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// formData为点击表单提交后，获取各项input/select的数据对象</span></span><br><span class="line">  this<span class="selector-class">.props</span><span class="selector-class">.addBookMutation</span>(&#123;</span><br><span class="line">    variables: &#123;</span><br><span class="line">      name: formData<span class="selector-class">.name</span>,</span><br><span class="line">      genre: formData<span class="selector-class">.genre</span>,</span><br><span class="line">      authorId: formData<span class="selector-class">.authorId</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    refetchQueries: [&#123;</span><br><span class="line">      query: anotherQueryWantedToBeRefetched</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-Query"><a href="#5-Query" class="headerlink" title="5. Query"></a>5. Query</h4><p>需要从组件传入参数，进行参数查询的gql query（引入query变量）。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// query.js</span></span><br><span class="line"><span class="keyword">const</span> getBooksQuery = gql`</span><br><span class="line">query ($<span class="keyword">id</span>: ID!) &#123;</span><br><span class="line">  book(<span class="keyword">id</span>: $<span class="keyword">id</span>) &#123;</span><br><span class="line">    <span class="keyword">id</span></span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getBook.js</span></span><br><span class="line"><span class="comment">// 在绑定组件和graphql数据前，把props.id注入到query的variables里</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> graphql(getBookQuery, &#123;</span><br><span class="line">  options: props =&gt; (&#123;</span><br><span class="line">    variables: &#123;</span><br><span class="line">      <span class="keyword">id</span>: props.id</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)(getBookComponentName);</span><br></pre></td></tr></table></figure><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p><code>问</code> 为什么在声明GraphQLObjectType实例时，fields不直接使用对象，而使用了函数？<br><code>答</code> 因为js的执行时机，直接使用对象的话，代码从上往下执行，fields中引用别的类型，如BookType和AuthorType有互相引用，会报错BookType或者AuthorType undefined。而使用函数的话，执行到函数内部逻辑时，外部的声明已经完成了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://sinacloud.net/woodysblog/graphql/structure.png&quot; alt=&quot;&amp;quot;structure&amp;quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;基于GraphQL、express、MongoDB、Apollo、React.js的小应用。&lt;br&gt;-&amp;gt;&amp;gt; 项目源码&lt;a href=&quot;https://github.com/YuyingWu/playground/tree/master/graphql-playlist&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何搭建基于GraphQL、express、MongoDB的后台服务器&lt;/li&gt;
&lt;li&gt;如何定义数据模型&lt;/li&gt;
&lt;li&gt;如何通过GraphiQL测试query和获取的数据结构，包括query（查询）和mutation（更新）&lt;/li&gt;
&lt;li&gt;如何搭建可以跟graphql query通信的Apollo-React前端应用&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="front-end" scheme="http://wuyuying.com/tags/front-end/"/>
    
      <category term="graphql" scheme="http://wuyuying.com/tags/graphql/"/>
    
  </entry>
  
  <entry>
    <title>Behavior Driven Development in ReactJS</title>
    <link href="http://wuyuying.com/archives/bdd-in-reactjs/"/>
    <id>http://wuyuying.com/archives/bdd-in-reactjs/</id>
    <published>2018-06-02T12:13:25.000Z</published>
    <updated>2018-06-23T06:42:34.505Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如果想跳过前文，可以直接定位到<a href="/blog/archives/test-driven-dev/#我的实战">实战篇</a></p></blockquote><h2 id="What-is-Test-Driven-Development"><a href="#What-is-Test-Driven-Development" class="headerlink" title="What is Test Driven Development?"></a>What is Test Driven Development?</h2><p>Coding of features and tests go hand in hand.</p><ol><li>Write a unit test.</li><li>Run the test. See it fail.</li><li>Write the feature code to pass the test.</li><li>Refactor the code.</li></ol><h2 id="Why-TDD"><a href="#Why-TDD" class="headerlink" title="Why TDD?"></a>Why TDD?</h2><ul><li>It reduces errors and defects in the long run.</li><li>It leads to higher quality code.</li></ul><h2 id="What-is-Behavior-Driven-Development"><a href="#What-is-Behavior-Driven-Development" class="headerlink" title="What is Behavior Driven Development?"></a>What is Behavior Driven Development?</h2><ul><li>A variation of TDD that tests for user scenarios.</li><li>Given, when, then… [ pattern ]</li><li>Given notes, when deleting, then remove a note.</li><li>BDD consists of scenarios/specifications.</li></ul><a id="more"></a><h2 id="Test-Tools"><a href="#Test-Tools" class="headerlink" title="Test Tools"></a>Test Tools</h2><ul><li>Jest</li><li>Enzyme</li></ul><blockquote><p>如果想看create-react-app或jest/enzyme环境的配置，可以<a href="#Setup">定位到setup内容</a>。</p></blockquote><h2 id="我的实战"><a href="#我的实战" class="headerlink" title="我的实战"></a>我的实战</h2><p>项目中Jest and Enzyme的实战。</p><h3 id="1-第一个Unit-Test-toMatchSnapshot"><a href="#1-第一个Unit-Test-toMatchSnapshot" class="headerlink" title="1. 第一个Unit Test: toMatchSnapshot"></a>1. 第一个Unit Test: <code>toMatchSnapshot</code></h3><p>快照是Jest把调用时的component的结构记录下来，下次可以用来对比结构有没有差异。</p><p>如果不一样，Jest会报错，如果是预期内的展示，可以按<code>u</code>把当前快照更新为最新的snapshot。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'render correctly'</span>, () =&gt; &#123;</span><br><span class="line">  expect(app).toMatchSnapshot();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-测试component的state"><a href="#2-测试component的state" class="headerlink" title="2. 测试component的state"></a>2. 测试component的state</h3><p>state的初始化检测 —— 状态<code>gifts</code>的值为空数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'init `state` for gifts as an empty list'</span>, () =&gt; &#123;</span><br><span class="line">  expect(app.state().gifts).toEqual([]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意：在jest中获得state是一个<code>state()</code>函数。</p><h3 id="3-点击交互的测试"><a href="#3-点击交互的测试" class="headerlink" title="3. 点击交互的测试"></a>3. 点击交互的测试</h3><p>通过className去查找交互元素，模拟用户行为，其中<code>simulate</code>是Enzyme提供的模拟函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'add a gift to `state` when click the `add` button'</span>, () =&gt; &#123;</span><br><span class="line">  app.find(<span class="string">'.btn-add'</span>).simulate(<span class="string">'click'</span>);</span><br><span class="line"></span><br><span class="line">  expect(app.state().gifts.length).not.toBe(<span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检验某个component（Gift）是否存在</span></span><br><span class="line">it(<span class="string">'create a Gift component'</span>, () =&gt; &#123;</span><br><span class="line">  expect(app.find(Gift).exists()).toBe(<span class="literal">true</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="4-利用describe划分测试代码块"><a href="#4-利用describe划分测试代码块" class="headerlink" title="4. 利用describe划分测试代码块"></a>4. 利用describe划分测试代码块</h3><p>用<code>describe</code>把测试分组。也可以使用<code>describe</code>定义一个场景，把相似的操作合并。</p><p>以下的两个测试都需要先触发一次<code>add-gift</code>按钮的点击，再验证相应的测试逻辑。</p><p>下面有两个hook，<code>beforeEach</code>和<code>afterEach</code>，可以用来执行<strong>前置共同的action</strong>和<strong>结束之后的reset逻辑</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'when clicking the `add-gift` button'</span>, () =&gt; &#123;</span><br><span class="line">    beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      app.find(<span class="string">'.btn-add'</span>).simulate(<span class="string">'click'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    afterEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// reset state `gifts` to []</span></span><br><span class="line">      app.setState(&#123;</span><br><span class="line">        gifts: []</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    it(<span class="string">'add a gift to `state`'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="comment">// app.find('.btn-add').simulate('click');</span></span><br><span class="line">      expect(app.state().gifts.length).not.toBe(<span class="number">0</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  </span><br><span class="line">    it(<span class="string">'display gifts on the rendered list'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="comment">// app.find('.btn-add').simulate('click');</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> stateListLength = app.state().gifts.length;</span><br><span class="line">      <span class="keyword">const</span> listItemLength = app.find(<span class="string">'.list-item'</span>).length;</span><br><span class="line">  </span><br><span class="line">      expect(stateListLength).toEqual(listItemLength);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="5-父子组件交互测试"><a href="#5-父子组件交互测试" class="headerlink" title="5. 父子组件交互测试"></a>5. 父子组件交互测试</h3><h4 id="1）背景"><a href="#1）背景" class="headerlink" title="1）背景"></a>1）背景</h4><p>在GiftGiver内，父组件<code>&lt;App /&gt;</code>根据<code>state</code>中的<code>gifts</code>数组渲染子组件<code>&lt;Gift /&gt;</code>，而子组件有一个删除按钮，点击后可以从父组件<code>state</code>中<code>gifts</code>去掉命中当前GiftID的数据项。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// state</span></span><br><span class="line"><span class="keyword">this</span>.state.gifts = [&#123;</span><br><span class="line">  id: xxx</span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line">removeGift(id) &#123;</span><br><span class="line">  <span class="comment">// this.state.gifts.filter(gift =&gt; gift.id !== id)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// render</span></span><br><span class="line">&#123; <span class="keyword">this</span>.state.gifts.map(<span class="function"><span class="params">gift</span> =&gt;</span> (</span><br><span class="line">  &lt;Gift gift=&#123;gift&#125; removeGift=&#123;removeGift&#125; /&gt;</span><br><span class="line">))&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Gift.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// render</span></span><br><span class="line"><span class="comment">// const &#123; gift, removeGift &#125; = this.props;</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;Button onClick=&#123; gift =&gt; removeGift(gift.id) &#125;&gt;remove&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure><h4 id="2）设计思路"><a href="#2）设计思路" class="headerlink" title="2）设计思路"></a>2）设计思路</h4><ol><li>把<code>removeGift</code>挂在父组件（<code>&lt;App /&gt;</code>）上，入参giftID</li><li>把<code>gift</code>的数据和<code>removeGift</code>作为props传给子组件（<code>&lt;Gift /&gt;</code>）</li><li>在子组件（<code>&lt;Gift /&gt;</code>），有一个删除按钮，点击后调用父组件的callback函数，入参giftID</li></ol><h4 id="3）写test-case的思路"><a href="#3）写test-case的思路" class="headerlink" title="3）写test case的思路"></a>3）写test case的思路</h4><h5 id="I-父组件的测试用例-App-test-js"><a href="#I-父组件的测试用例-App-test-js" class="headerlink" title="I. 父组件的测试用例 App.test.js"></a>I. 父组件的测试用例 App.test.js</h5><p><strong>涉及的核心逻辑或交互</strong>：负责从数据源<code>this.state.gifts</code>中干掉对应数据的函数<code>removeGift</code>。</p><p><strong>测试思路</strong>：<code>removeGift</code>入参giftID后，检查会不会正确地从<code>state</code>中去掉该项数组（giftID === item.id）。</p><p><strong>实现详情：</strong></p><p>a）前置操作：模拟调用行为。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// call the `removeGift` function in App.js</span></span><br><span class="line">  app.instance().removeGift(firstGiftID);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>b）断言逻辑：确定<code>this.state.gifts</code>中没有包含对应项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'gift with ID $&#123;firstGiftID&#125; is not in the state `gift`'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; gifts &#125; = app.state();</span><br><span class="line">  <span class="keyword">const</span> targetGiftList = gifts.find(<span class="function"><span class="params">gift</span> =&gt;</span> gift.id === firstGiftID) || [];</span><br><span class="line"></span><br><span class="line">  expect(targetGiftList.length).toBe(<span class="number">0</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="II-子组件的测试用例-Gift-test-js"><a href="#II-子组件的测试用例-Gift-test-js" class="headerlink" title="II. 子组件的测试用例 Gift.test.js"></a>II. 子组件的测试用例 Gift.test.js</h5><p><strong>涉及的核心逻辑或交互</strong>：</p><ul><li>点击一个删除按钮</li><li>调用父组件传过来的callback函数，并传入id</li></ul><p><strong>测试思路</strong>：</p><ul><li>在shallow时，模拟父元素传入对应的props</li><li>模拟用户行为，点击删除按钮</li><li>检查回调函数有没有被调用，以及传入的参数对不对</li></ul><p><strong>实现详情</strong>：</p><p>1）在shallow时，模拟父元素传入对应的props。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mockRemove = jest.fn(); <span class="comment">// 在第3点说明</span></span><br><span class="line"><span class="keyword">const</span> giftID = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> props = &#123;</span><br><span class="line">  gift: &#123;</span><br><span class="line">    id: giftID</span><br><span class="line">  &#125;,</span><br><span class="line">  removeGift: mockRemove</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> gift = shallow(&lt;Gift &#123; ...props &#125; /&gt;);</span><br></pre></td></tr></table></figure><p>2）<code>beforeEach</code>里模拟删除按钮的点击</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  gift.find(<span class="string">'.btn-delete'</span>).simulate(<span class="string">'click'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3）检查回调函数有没有被调用，以及传入的参数对不对</p><p>从第1点可以看到，shallow渲染传入props时，回调函数把原本的removeGift函数替换成jest的mock。(<code>const mockRemove = jest.fn();</code>)</p><p>因为该方法提供了一个断言检测方法，我们可以通过这个方式，检查回调函数有没有被调用以及传入的参数是否符合预期，实际的测试语句如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'calls the removeGift callback'</span>, () =&gt; &#123;</span><br><span class="line">  expect(mockRemove).toHaveBeenCalledWith(giftID);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="6-coverage-testing"><a href="#6-coverage-testing" class="headerlink" title="6. coverage testing"></a>6. coverage testing</h3><p>检测实际被调用代码的覆盖程度。（冗余代码检测）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run test -- --coverage</span><br></pre></td></tr></table></figure><p><img src="http://lc-wpyqjumv.cn-n1.lcfile.com/b79550c417506fb9c9c5.png" alt=""></p><p>指定<code>--coverage</code>目标文件：，在<code>package.json</code>下，添加以下语句：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"jest"</span>: &#123;</span><br><span class="line">  <span class="string">"collectCoverageFrom"</span>: [</span><br><span class="line">    <span class="string">"src/**.js"</span>,</span><br><span class="line">    <span class="string">"!src/index.js"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><p>如果存在某些函数/逻辑没有覆盖到，可以考虑新增一个和<code>component</code>同级的<code>helpers</code>文件夹，在里面单独写那些跟组件基本功能无关的逻辑，如用于生成ID的ID生成函数，可以单拎出来放进<code>helpers</code>及进行相应的单元测试。</p><h2 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h2><h3 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a>Preparation</h3><ol><li>node, v8.x</li><li>npm, v5.x</li><li>create-react-app</li></ol><h3 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h3><p>I. <code>create-react-app yourProjectName</code></p><p>II. install dependencies</p><ul><li>dependencies: react-dom &amp; react </li><li>devDependencies: enzyme &amp; jest-cli</li></ul><p>III. enzyme-adapter-react-16</p><p>In order to use the most current version of React &gt; 16, we now need to install “enzyme adapters” to provide full compatibility with React.</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i enzyme-adapter-react<span class="number">-16</span> --<span class="built_in">save</span>-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure><p>Next, add a src/tempPolyfills.js file to create the global request animation frame function that React now depends on.</p><p>src/tempPolyfills.js should contain the following contents:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> requestAnimationFrame = global.requestAnimationFrame = <span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">  setTimeout(callback, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>export default requestAnimationFrame;<br>Finally, add a src/setupTests.js file to configure the enzmye adapter for our tests. The disableLifecyleMethods portion is needed to allow us to modify props through different tests.</p><p>src/setupTests.js should contain the following contents:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requestAnimationFrame <span class="keyword">from</span> <span class="string">'./tempPolyfills'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; configure &#125; <span class="keyword">from</span> <span class="string">'enzyme'</span>;</span><br><span class="line"><span class="keyword">import</span> Adapter <span class="keyword">from</span> <span class="string">'enzyme-adapter-react-16'</span>;</span><br><span class="line"></span><br><span class="line">configure(&#123; <span class="attr">adapter</span>: <span class="keyword">new</span> Adapter(), <span class="attr">disableLifecycleMethods</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;如果想跳过前文，可以直接定位到&lt;a href=&quot;/blog/archives/test-driven-dev/#我的实战&quot;&gt;实战篇&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;What-is-Test-Driven-Development&quot;&gt;&lt;a href=&quot;#What-is-Test-Driven-Development&quot; class=&quot;headerlink&quot; title=&quot;What is Test Driven Development?&quot;&gt;&lt;/a&gt;What is Test Driven Development?&lt;/h2&gt;&lt;p&gt;Coding of features and tests go hand in hand.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Write a unit test.&lt;/li&gt;
&lt;li&gt;Run the test. See it fail.&lt;/li&gt;
&lt;li&gt;Write the feature code to pass the test.&lt;/li&gt;
&lt;li&gt;Refactor the code.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;Why-TDD&quot;&gt;&lt;a href=&quot;#Why-TDD&quot; class=&quot;headerlink&quot; title=&quot;Why TDD?&quot;&gt;&lt;/a&gt;Why TDD?&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;It reduces errors and defects in the long run.&lt;/li&gt;
&lt;li&gt;It leads to higher quality code.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;What-is-Behavior-Driven-Development&quot;&gt;&lt;a href=&quot;#What-is-Behavior-Driven-Development&quot; class=&quot;headerlink&quot; title=&quot;What is Behavior Driven Development?&quot;&gt;&lt;/a&gt;What is Behavior Driven Development?&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;A variation of TDD that tests for user scenarios.&lt;/li&gt;
&lt;li&gt;Given, when, then… [ pattern ]&lt;/li&gt;
&lt;li&gt;Given notes, when deleting, then remove a note.&lt;/li&gt;
&lt;li&gt;BDD consists of scenarios/specifications.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="front-end" scheme="http://wuyuying.com/tags/front-end/"/>
    
      <category term="testing" scheme="http://wuyuying.com/tags/testing/"/>
    
  </entry>
  
  <entry>
    <title>开箱即用，Hexo博客的github+server自动部署</title>
    <link href="http://wuyuying.com/archives/hexo-travis/"/>
    <id>http://wuyuying.com/archives/hexo-travis/</id>
    <published>2018-05-26T06:35:18.000Z</published>
    <updated>2018-06-05T13:46:08.048Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://lc-wpyqjumv.cn-n1.lcfile.com/9fb19e9b112f127c1adc.jpg" alt="&quot;Travis CI&quot;"></p><p>用了一段时间HEXO搭建个人的博客，但每次发布文章，都需要打开电脑<code>hexo g</code>编译之后，再提交到服务器上，确实挺麻烦的，和小伙伴聊完他的日志发布方式之后，痛定思痛，<strong>快捷发布日志</strong>这个问题需要解决一下了！Travis CLI搞起来！</p><h2 id="闲聊日志的快捷发布"><a href="#闲聊日志的快捷发布" class="headerlink" title="闲聊日志的快捷发布"></a>闲聊日志的快捷发布</h2><p>前几天，跟小伙伴Pipe一起参加个分享会，看到他做了笔记，结束后我说你发给我呀，他说直接看我博客（<a href="https://zhoukekestar.github.io/notes/2018/05/25/better-me.html" target="_blank" rel="noopener">《工作思维方式简记》</a>）呀！我的天，写完瞬间就发到站点去了！Pipe非常高产，去看看他的<a href="https://zhoukekestar.github.io/notes" target="_blank" rel="noopener">博客</a>，用“高产似母猪”来描述都不足为过，5月份还没有过完，发布了7篇日志。</p><p>我问他，怎么做到那么高产？Pipe说，第一点是他的日志是碎片化的偏记录的，不一定要憋出大文章才发，然后就是博客系统要方便，随写随发。</p><p>反观我的博客，更新频率真的很低，一方面是喜欢憋专题文章，拖着拖着，然后就没有然后了。另一方面也是发布确实麻烦，电脑编辑好markdown，还要执行各种命令，最后push到github和自己的服务器，文章才能被大家看到，一开始觉得还好蛮geek的，但后来确实由于这些门槛，有打击到那些随时来的写作思绪。</p><p>By the way，Pipe用的是<code>jekyll</code>，跟github的持续集成是天生的，而HEXO没有这样的优势。从Hexo换到Jekyll吧，也不是很麻烦，但是我在Hexo生态做了一些东西，还是有点不舍哈。</p><ul><li><a href="https://github.com/YuyingWu/blog" target="_blank" rel="noopener">github blog</a>：我的博客分支</li><li><a href="https://github.com/YuyingWu/hexo-generator-index-plus/blob/master/README.md" target="_blank" rel="noopener">hexo-generator-index-plus</a>：hexo小插件，首页排序生成器，和原生的index-generator比较显著的区别是加了置顶功能，可以在front-matter添加<code>top</code>属性即可。</li><li><a href="https://github.com/YuyingWu/hexo-theme-fresh" target="_blank" rel="noopener">hexo-theme-fresh</a>：hexo博客主题，绿色小清新，Medium风格。</li></ul><p><img src="//lc-wpyqjumv.cn-n1.lcfile.com/3061dbf0241049f3b646.gif" alt="&quot;hexo-theme-fresh效果截屏&quot;"></p><h2 id="HEXO的开发分支与生产分支"><a href="#HEXO的开发分支与生产分支" class="headerlink" title="HEXO的开发分支与生产分支"></a>HEXO的开发分支与生产分支</h2><p>仓库分成2个分支，主开发开支dev，以及生产环境的gh-pages分支。<br>查看博客可以通过访问<a href="https://yuyingwu.github.io/blog/" target="_blank" rel="noopener">github pages</a>，又或者直接访问我的域名 <a href="http://www.wuyuying.com/blog/archives/hexo-travis/" target="_blank" rel="noopener">wuyuying.com/blog</a>。</p><h3 id="开发分支-dev"><a href="#开发分支-dev" class="headerlink" title="开发分支 dev"></a>开发分支 dev</h3><p>在我的博客里，开发分支是<code>dev</code>，目录结构就是一开始<code>hexo init</code>后的结构。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- scaffolds <span class="comment">// 页面的模板，包括草稿（draft.md）、页面（page.md）、文章（post.md）以及其他自定义模板</span></span><br><span class="line">- source <span class="comment">// 放页面和文章markdown文档</span></span><br><span class="line">- themes <span class="comment">// 博客主题</span></span><br><span class="line">- _config<span class="selector-class">.yml</span> <span class="comment">// 配置文件</span></span><br><span class="line">- package.json</span><br><span class="line">- <span class="selector-class">.travis</span><span class="selector-class">.yml</span> <span class="comment">// 持续集成服务travis的文件</span></span><br></pre></td></tr></table></figure><p>本地开发流程一般是这样。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> hexo server, 启动本地服务器，预览我的文章</span><br><span class="line">hexo s </span><br><span class="line"></span><br><span class="line"><span class="string">//</span> hexo generate，编译文章，把 `source` 里面的页面和文章编译成 `public` 里面的html文件</span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line"><span class="string">//</span> hexo <span class="keyword">deploy</span>，如果 _config.yml 有配置<span class="keyword">deploy</span>的内容，执行该命令是会执行相应的部署逻辑</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>HEXO的详细科普和指令在这里就不写了哈，官方文档里都有 <a href="https://hexo.io/docs/" target="_blank" rel="noopener">&gt;&gt; 传送门</a>。</p><h3 id="生产分支-gh-pages"><a href="#生产分支-gh-pages" class="headerlink" title="生产分支 gh-pages"></a>生产分支 gh-pages</h3><p>在<code>dev</code>分支里，执行了<code>hexo g</code>编译之后，编译后的静态文件会存在<code>public</code>文件夹里，而我们就把里面的内容挪到最终的生产环境分支<code>gh-pages</code>里，也就是最终我们看到的静态博客。</p><p>当我们在github里把github-pages服务打开，并渲染<code>gh-pages</code>分支，我们就能访问自己的博客了（<a href="https://yuyingwu.github.io/blog/" target="_blank" rel="noopener">https://yuyingwu.github.io/blog/</a>）。</p><p><img src="//lc-wpyqjumv.cn-n1.lcfile.com/d3ebf243ea2b0dfd9dd1.png" alt="&quot;看看我的博客&quot;"></p><h2 id="Travis-CI"><a href="#Travis-CI" class="headerlink" title="Travis CI"></a>Travis CI</h2><p>在大致了解HEXO的开发流程之后，我们可以开始考虑，如果要实现快捷发布，是要做什么？<br><code>User Story</code>：<strong>希望可以在github上写一篇文章，提交之后，可以直接在我的线上博客看到</strong>。</p><p>在这里，我们用到了提供持续集成（CI, Continuous Integration）服务的<a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a>，但其实用到的不是它提供的CI服务，而更多的是通过监听分支提交的动态，在集成成功后去执行我们自定义的部署逻辑。</p><blockquote><p>持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。</p></blockquote><p>噢，还有些事前准备：</p><ul><li>先在<code>dev</code>分支里，创建<code>.travis.yml</code></li><li>在<a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CLI</a>平台上打开这个分支的CI开关</li></ul><h3 id="1-编译并同步到gh-pages"><a href="#1-编译并同步到gh-pages" class="headerlink" title="1. 编译并同步到gh-pages"></a>1. 编译并同步到gh-pages</h3><p>那直接上我的CI配置代码吧。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span> <span class="string">stable</span></span><br><span class="line"></span><br><span class="line"><span class="attr">addons:</span> <span class="comment"># Travis CI建议加的，自动更新api</span></span><br><span class="line"><span class="attr">  apt:</span></span><br><span class="line"><span class="attr">    update:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line"><span class="attr">  directories:</span> </span><br><span class="line"><span class="bullet">  -</span> <span class="string">node_modules</span> <span class="comment"># 缓存 node_modules</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="comment"># 初次安装，在CI环境中，执行安装npm依赖</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># before_script: </span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo</span> <span class="string">g</span> <span class="comment"># 执行 hexo generate，把文章编译到public中</span></span><br><span class="line"></span><br><span class="line"><span class="attr">after_success:</span> <span class="comment"># 执行script成功后，进入到public，把里面的代码提交到博客的gh-pages分支</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">cd</span> <span class="string">./public</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">init</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.name</span> <span class="string">"Yuying Wu"</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.email</span> <span class="string">"wuyuying1128@gmail.com"</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">add</span> <span class="string">.</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">commit</span> <span class="bullet">-m</span> <span class="string">"Update site"</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">push</span> <span class="bullet">--force</span> <span class="bullet">--quiet</span> <span class="string">"https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;"</span> <span class="attr">master:gh-pages</span></span><br><span class="line"></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">dev</span> <span class="comment"># CI 只针对分支 dev</span></span><br><span class="line"></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line"><span class="attr">  global:</span> <span class="comment"># 全局变量，上面的提交到github的命令有用到</span></span><br><span class="line"><span class="attr">  - GH_REF:</span> <span class="string">github.com/YuyingWu/blog.git</span></span><br><span class="line"><span class="attr">  - secure:</span> </span><br><span class="line"><span class="comment"># secure是自动生成的，执行`travis encrypt 'GH_TOKEN=$&#123;your_github_personal_access_token&#125;' --add`</span></span><br></pre></td></tr></table></figure><p>相信代码和注释写得很清楚了，有个地方需要进一步解释的，github提交那part，涉及github access token的生成和加密。</p><ol><li>生成github的<a href="https://github.com/settings/tokens" target="_blank" rel="noopener">Personal Access Tokens</a>（打开分支提交的权限）</li><li>安装Travis CLI <code>gem install travis</code>（如果登录遇到环境问题，可以看看下面参考文章里面的解决方案）</li><li>进入到本地<code>dev</code>目录下（带有<code>.travis.yml</code>），执行<code>travis login</code>登录，再执行<code>travis encrypt &#39;GH_TOKEN=${your_github_personal_access_token}&#39; --add</code>加密你的personal access token（也就是后来<code>.travis.yml</code>的<code>env.global.secure</code>的值）</li></ol><p>把<code>.travis.yml</code>提交之后，看看Travis CLI上，开始持续集成了哈。</p><p><img src="//lc-wpyqjumv.cn-n1.lcfile.com/cbf00765c8f94a151965.png" alt="&quot;开始准备&quot;"><br><img src="//lc-wpyqjumv.cn-n1.lcfile.com/b82303e0f85deb2088ce.png" alt="&quot;after_success把代码部署到gh-pages&quot;"></p><p>大功告成，集成之后，在github pages的页面上也能看到文章的更新。</p><h3 id="2-CI到我的服务器"><a href="#2-CI到我的服务器" class="headerlink" title="2. CI到我的服务器"></a>2. CI到我的服务器</h3><p>我的服务器是DO家（Digital Ocean）的，那一开始服务器初始化的过程，大家可以参考各个server商提供的setup文档哈，总的来说，在本地有个服务器信任的<code>id_rsa</code>的ssh文件，我们是可以通过<code>ssh user@ip_address</code>登录到服务器的。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个命令会自动把 id_rsa 加密传送到 .git 指定的仓库对应的 travis 中去（在我本地这个文件叫qq_rsa，不是默认的id_rsa）</span></span><br><span class="line">travis <span class="built_in">encrypt</span>-<span class="built_in">file</span> ~/.ssh/id_rsa <span class="comment">--add</span></span><br></pre></td></tr></table></figure><p>执行这个命令后，<code>.travis.yml</code>多了一行代码：（注意把其中的转义符<code>\</code>干掉哈），也会在分支目录下生成一个<code>id_rsa.enc</code>的加密文件，记得把这个文件也提交上去哟。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before_install:</span><br><span class="line">-<span class="ruby"> openssl aes-<span class="number">256</span>-cbc -K $encrypted_3cf6c1fd150f_key -iv $encrypted_3cf6c1fd150f_iv</span></span><br><span class="line"><span class="ruby">  -<span class="keyword">in</span> qq_rsa.enc -out ~<span class="regexp">/.ssh/id</span>_rsa -d</span></span><br></pre></td></tr></table></figure><p>然后为了保证在Travis里面能正常执行，我们处理下运行环境的rsa文件权限和输出提示信息，before_install如下。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">before_install:</span><br><span class="line">-<span class="ruby"> openssl aes-<span class="number">256</span>-cbc -K $encrypted_3cf6c1fd150f_key -iv $encrypted_3cf6c1fd150f_iv</span></span><br><span class="line"><span class="ruby">  -<span class="keyword">in</span> qq_rsa.enc -out ~<span class="regexp">/.ssh/id</span>_rsa -d</span></span><br><span class="line"><span class="ruby">- chmod <span class="number">600</span> ~<span class="regexp">/.ssh/id</span>_rsa</span></span><br><span class="line"><span class="ruby">- echo -e <span class="string">"Host 主机IP地址\n\tStrictHostKeyChecking no\n"</span> <span class="meta">&gt;&gt; </span>~<span class="regexp">/.ssh/config</span></span></span><br></pre></td></tr></table></figure><p>最后，在<code>after_success</code>里添加<strong>拷贝目标文件到服务器目标目录</strong>的操作，就大功告成了！</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">after_success</span><br><span class="line"><span class="comment"># other actions</span></span><br><span class="line">- scp -o stricthostkeychecking=no -r ./* root<span class="variable">@138</span>.<span class="number">68.161</span>.<span class="number">48</span><span class="symbol">:/home/wyyNode/public/blog/</span></span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://juejin.im/post/596e39916fb9a06baf2ed273" target="_blank" rel="noopener">如何快速搭建一个有域名且持续集成的hexo博客(2.0版)</a> - <a href="https://github.com/zytx121" target="_blank" rel="noopener">Eva-Yue</a></li><li><a href="http://lotabout.me/2016/Hexo-Auto-Deploy-to-Github/" target="_blank" rel="noopener">Hexo 自动部署到 Github</a> - <a href="http://lotabout.me/" target="_blank" rel="noopener">三点水</a></li><li><a href="http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html" target="_blank" rel="noopener">持续集成服务 Travis CI 教程</a> - 阮一峰</li><li><a href="https://github.com/travis-ci/travis.rb/issues/190" target="_blank" rel="noopener">“no implicit conversion of nil into String” when logging in</a> - 在执行<code>travis login</code>遇到的问题的解决方案</li><li><a href="https://iamstarkov.com/deploy-gh-pages-from-travis/" target="_blank" rel="noopener">Deploy to GitHub pages from Travis CI</a></li><li><a href="https://segmentfault.com/a/1190000009093621" target="_blank" rel="noopener">使用 Travis 将 GitHub 文件上传传至服务器</a> - <a href="https://github.com/Godi13" target="_blank" rel="noopener">Godi13</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://lc-wpyqjumv.cn-n1.lcfile.com/9fb19e9b112f127c1adc.jpg&quot; alt=&quot;&amp;quot;Travis CI&amp;quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;用了一段时间HEXO搭建个人的博客，但每次发布文章，都需要
      
    
    </summary>
    
    
      <category term="blog" scheme="http://wuyuying.com/tags/blog/"/>
    
      <category term="travisCI" scheme="http://wuyuying.com/tags/travisCI/"/>
    
      <category term="CI" scheme="http://wuyuying.com/tags/CI/"/>
    
      <category term="hexo" scheme="http://wuyuying.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>[译] React性能优化-虚拟Dom原理浅析</title>
    <link href="http://wuyuying.com/archives/optimizing-react-virtual-dom-explained/"/>
    <id>http://wuyuying.com/archives/optimizing-react-virtual-dom-explained/</id>
    <published>2018-05-13T11:15:19.000Z</published>
    <updated>2018-08-17T12:47:37.603Z</updated>
    
    <content type="html"><![CDATA[<p>本文译自<a href="https://evilmartians.com/chronicles/optimizing-react-virtual-dom-explained" target="_blank" rel="noopener">《Optimizing React: Virtual DOM explained》</a>，作者是<a href="https://github.com/iAdramelk" target="_blank" rel="noopener">Alexey Ivanov</a>和<a href="https://github.com/progapandist" target="_blank" rel="noopener">Andy Barnov</a>，来自<a href="https://evilmartians.com/chronicles" target="_blank" rel="noopener">Evil Martians’ team</a>团队。</p><p>译者说：通过一些实际场景和demo，给大家描述React的Virtual Dom Diff一些核心的原理和规则，以及基于这些我们可以做些什么提高应用的性能，很棒的文章。</p><hr><p><strong>通过学习React的Virtual DOM的知识，去加速你们的应用吧。对框架内部实现的介绍，比较全面且适合初学者，我们会让JSX更加简单易懂，给你展示React是如何判断要不要重新render，解释如何找到应用的性能瓶颈，以及给大家一些小贴士，如何避免常见错误。</strong></p><p>React在前端圈内保持领先的原因之一，因为它的学习曲线非常平易近人：把你的模板包在<code>JSX</code>，了解一下<code>props</code>和<code>state</code>的概念之后，你就可以轻松写出React代码了。</p><p>如果你已经熟悉React的工作方式，可以直接跳至“优化我的代码”篇。</p><p>但要真正掌握React，你需要像React一样思考（think in React）。本文也会试图在这个方面帮助你。</p><p>下面看看我们其中一个项目中的React table：</p><p><img src="http://sinacloud.net/woodysblog/img/ebay_table.png" alt="&quot;eBay上的一个巨大的React表格  用于业务。&quot;"></p><p>这个表里有数百个动态（表格内容变化）和可过滤的选项，理解这个框架更精细的点，对于保证顺畅的用户体验至关重要。</p><hr><p><strong>当事情出错时，你一定能感觉到。输入字段变得迟缓，复选框需要检查一秒钟，弹窗一个世纪后才出现，等等。</strong></p><hr><p>为了能够解决这些问题，我们需要完成一个React组件的整个生命旅程，从一开始的声明定义到在页面上渲染（再然后可能会更新）。系好安全带，我们要发车了！</p><h2 id="JSX的背后"><a href="#JSX的背后" class="headerlink" title="JSX的背后"></a>JSX的背后</h2><p>这个过程一般在前端会称为“转译”，但其实“汇编”将是一个更精确的术语。</p><p>React开发人员敦促你在编写组件时使用一种称为JSX的语法，混合了HTML和JavaScript。但浏览器对JSX及其语法毫无头绪，浏览器只能理解纯碎的JavaScript，所以JSX必须转换成JavaScript。这里是一个div的JSX代码，它有一个class name和一些内容：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=<span class="string">'cn'</span>&gt;</span><br><span class="line">  Content!</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><p>以上的代码，被转换成“正经”的JavaScript代码，其实是一个带有一些参数的函数调用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">  <span class="string">'div'</span>,</span><br><span class="line">  &#123; <span class="attr">className</span>: <span class="string">'cn'</span> &#125;,</span><br><span class="line">  <span class="string">'Content!'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>让我们仔细看看这些参数。</p><ul><li>第一个是元素的<code>type</code>。对于HTML标签，它将是一个带有<code>标签名称</code>的字符串。</li><li>第二个参数是一个包含所有元素属性（<code>attributes</code>）的对象。如果没有，它也可以是空的对象。</li><li>剩下的参数都可以认为是元素的子元素（<code>children</code>）。元素中的文本也算作一个child，是个字符串’Content！’ 作为函数调用的第三个参数放置。</li></ul><p>你应该可以想象，当我们有更多的children时会发生什么：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=<span class="string">'cn'</span>&gt;</span><br><span class="line">  Content <span class="number">1</span>!</span><br><span class="line">  &lt;br /&gt;</span><br><span class="line">  Content <span class="number">2</span>!</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">  <span class="string">'div'</span>,</span><br><span class="line">  &#123; <span class="attr">className</span>: <span class="string">'cn'</span> &#125;,</span><br><span class="line">  <span class="string">'Content 1!'</span>,              <span class="comment">// 1st child</span></span><br><span class="line">  React.createElement(<span class="string">'br'</span>), <span class="comment">// 2nd child</span></span><br><span class="line">  <span class="string">'Content 2!'</span>               <span class="comment">// 3rd child</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们的函数现在有五个参数：</p><ul><li>一个元素的类型</li><li>一个属性对象</li><li>三个子元素。</li></ul><p>因为其中一个child是一个React已知的HTML标签（<code>&lt;br/&gt;</code>），所以它也会被描述为一个函数调用（<code>React.createElement(&#39;br&#39;)</code>）。</p><p>到目前为止，我们已经涵盖了两种类型的children：</p><ul><li>简单的<code>String</code></li><li>另一种会调用<code>React.createElement</code>。</li></ul><p>然而，还有其他值可以作为参数：</p><ul><li>基本类型 <code>false, null, undefined, true</code></li><li>数组</li><li>React Components</li></ul><p>可以使用数组是因为可以将children分组并作为一个参数传递：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">  <span class="string">'div'</span>,</span><br><span class="line">  &#123; <span class="attr">className</span>: <span class="string">'cn'</span> &#125;,</span><br><span class="line">  [<span class="string">'Content 1!'</span>, React.createElement(<span class="string">'br'</span>), <span class="string">'Content 2!'</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>当然了，React的厉害之处，不仅仅因为我们可以把HTML标签直接放在JSX中使用，而是我们可以自定义自己的组件，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Table</span>(<span class="params">&#123; rows &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;table&gt;</span><br><span class="line">      &#123;rows.map(<span class="function"><span class="params">row</span> =&gt;</span> (</span><br><span class="line">        &lt;tr key=&#123;row.id&#125;&gt;</span><br><span class="line">          &lt;td&gt;&#123;row.title&#125;&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>tr&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;<span class="regexp">/table&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>组件可以让我们把模板分解为多个可重用的块。在上面的“函数式”（functional）组件的例子里，我们接收一个包含表格行数据的对象数组，最后返回一个调用<code>React.createElement</code>方法的<code>&lt;table&gt;</code>元素，<code>rows</code>则作为children传进table。</p><p>无论什么时候，我们这样去声明一个组件时：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Table rows=&#123;rows&#125; /&gt;</span><br></pre></td></tr></table></figure><p>从浏览器的角度来看，我们是这么写的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(Table, &#123; <span class="attr">rows</span>: rows &#125;);</span><br></pre></td></tr></table></figure><p>注意，这次我们的第一个参数不是<code>String</code>描述的<code>HTML标签</code>，而是一个引用，指向我们编写组件时编写的函数。组件的<code>attributes</code>现在是接收的<code>props</code>参数了。</p><h2 id="把组件（components）组合成页面（a-page）"><a href="#把组件（components）组合成页面（a-page）" class="headerlink" title="把组件（components）组合成页面（a page）"></a>把组件（components）组合成页面（a page）</h2><p>所以，我们已经将所有JSX组件转换为纯JavaScript，现在我们有一大堆函数调用，它的参数会被其他函数调用的，或者还有更多的其他函数调用这些参数……这些带参数的函数调用，是怎么转化成组成这个页面的实体DOM的呢？</p><p>为此，我们有一个<code>ReactDOM</code>库及其它的<code>render</code>方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Table</span>(<span class="params">&#123; rows &#125;</span>) </span>&#123; <span class="comment">/* ... */</span> &#125; <span class="comment">// defining a component</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// rendering a component</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  React.createElement(Table, &#123; <span class="attr">rows</span>: rows &#125;), <span class="comment">// "creating" a component</span></span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'#root'</span>) <span class="comment">// inserting it on a page</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>当<code>ReactDOM.render</code>被调用时，<code>React.createElement</code>最终也会被调用，返回以下对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// There are more fields, but these are most important to us</span></span><br><span class="line">&#123;</span><br><span class="line">  type: Table,</span><br><span class="line">  props: &#123;</span><br><span class="line">    rows: rows</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>这些对象，在React的角度上，构成了虚拟DOM。</strong></p><hr><p>他们将在所有进一步的渲染中相互比较，并最终转化为  真正的<code>DOM</code>（virtual VS real, 虚拟DOM VS 真实DOM）。</p><p>下面是另一个例子：这次div有一个class属性和几个children：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">  <span class="string">'div'</span>,</span><br><span class="line">  &#123; <span class="attr">className</span>: <span class="string">'cn'</span> &#125;,</span><br><span class="line">  <span class="string">'Content 1!'</span>,</span><br><span class="line">  <span class="string">'Content 2!'</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>变成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: <span class="string">'div'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    className: <span class="string">'cn'</span>,</span><br><span class="line">    children: [</span><br><span class="line">      <span class="string">'Content 1!'</span>,</span><br><span class="line">      <span class="string">'Content 2!'</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，那些除了<code>type</code>和<code>attribute</code>以外的属性，原本是单独传进来的，转换之后，会作为在<code>props.children</code>以一个数组的形式打包存在。也就是说，无论children是作为数组还是参数列表传递都没关系 —— 在生成的虚拟DOM对象的时候，它们最后都会被打包在一起的。</p><p>进一步说，我们可以直接在组件中把children作为一项属性传进去，结果还是一样的：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=<span class="string">'cn'</span> children=&#123;[<span class="string">'Content 1!'</span>, <span class="string">'Content 2!'</span>]&#125; /&gt;</span><br></pre></td></tr></table></figure><p>在构建虚拟DOM对象完成之后，<code>ReactDOM.render</code>将会按下面的原则，尝试将其转换为浏览器可以识别和展示的DOM节点：</p><ul><li><p>如果<code>type</code>包含一个带有<code>String</code>类型的标签名称（<code>tag name</code>）—— 创建一个标签，附带上<code>props</code>下所有<code>attributes</code>。</p></li><li><p>如果<code>type</code>是一个函数（<code>function</code>）或者类（<code>class</code>），调用它，并对结果递归地重复这个过程。</p></li><li><p>如果<code>props</code>下有<code>children</code>属性 —— 在父节点下，针对每个child重复以上过程。</p></li></ul><p>最后，得到以下HTML（对于我们的表格示例）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="重新构建DOM（Rebuilding-the-DOM）"><a href="#重新构建DOM（Rebuilding-the-DOM）" class="headerlink" title="重新构建DOM（Rebuilding the DOM）"></a>重新构建DOM（Rebuilding the DOM）</h2><p>在实际应用场景，<code>render</code>通常在根节点调用一次，后续的更新会有<code>state</code>来控制和触发调用。</p><p>请注意，标题中的“重新”！当我们想更新一个页面而不是全部替换时，React中的魔法就开始了。我们有一些实现它的方式。我们先从最简单的开始 —— 在同一个node节点再次执行<code>ReactDOM.render</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Second call</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  React.createElement(Table, &#123; <span class="attr">rows</span>: rows &#125;),</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'#root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这一次，上面的代码的表现，跟我们已经看到的有所不同。React将启动其<code>diff</code>算法，而不是从头开始创建所有DOM节点并将其放在页面上，来确定节点树的哪些部分必须更新，哪些可以保持不变。</p><p>那么，它是怎样工作的呢？其实只有少数几个简单的场景，理解它们将对我们的优化帮助很大。请记住，现在我们在看的，是在<code>React Virtual DOM</code>里面用来代表节点的<code>对象</code>。</p><h3 id="场景1：type是一个字符串，type在通话中保持不变，props也没有改变。"><a href="#场景1：type是一个字符串，type在通话中保持不变，props也没有改变。" class="headerlink" title="场景1：type是一个字符串，type在通话中保持不变，props也没有改变。"></a>场景1：<code>type</code>是一个字符串，<code>type</code>在通话中保持不变，<code>props</code>也没有改变。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// before update</span></span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'div'</span>, <span class="attr">props</span>: &#123; <span class="attr">className</span>: <span class="string">'cn'</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// after update</span></span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'div'</span>, <span class="attr">props</span>: &#123; <span class="attr">className</span>: <span class="string">'cn'</span> &#125; &#125;</span><br></pre></td></tr></table></figure><p>这是最简单的情况：DOM保持不变。</p><h3 id="场景2：type仍然是相同的字符串，props是不同的。"><a href="#场景2：type仍然是相同的字符串，props是不同的。" class="headerlink" title="场景2：type仍然是相同的字符串，props是不同的。"></a>场景2：<code>type</code>仍然是相同的字符串，<code>props</code>是不同的。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// before update:</span></span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'div'</span>, <span class="attr">props</span>: &#123; <span class="attr">className</span>: <span class="string">'cn'</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// after update:</span></span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'div'</span>, <span class="attr">props</span>: &#123; <span class="attr">className</span>: <span class="string">'cnn'</span> &#125; &#125;</span><br></pre></td></tr></table></figure><p><code>type</code>仍然代表HTML元素，React知道如何通过标准DOM API调用来更改元素的属性，而无需从DOM树中删除一个节点。</p><h3 id="场景3：type已更改为不同的String或从String组件。"><a href="#场景3：type已更改为不同的String或从String组件。" class="headerlink" title="场景3：type已更改为不同的String或从String组件。"></a>场景3：<code>type</code>已更改为不同的<code>String</code>或从<code>String</code>组件。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// before update:</span></span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'div'</span>, <span class="attr">props</span>: &#123; <span class="attr">className</span>: <span class="string">'cn'</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// after update:</span></span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'span'</span>, <span class="attr">props</span>: &#123; <span class="attr">className</span>: <span class="string">'cn'</span> &#125; &#125;</span><br></pre></td></tr></table></figure><p>React看到的<code>type</code>是不同的，它甚至不会尝试更新我们的节点：old元素将和它的所有子节点一起被删除（unmounted卸载）。因此，将元素替换为完全不同于DOM树的东西代价会非常昂贵。幸运的是，这在现实世界中很少发生。</p><p>划重点，记住React使用<code>===</code>（triple equals）来比较<code>type</code>的值，所以这两个值需要是相同类或相同函数的相同实例。</p><p>下一个场景更加有趣，通常我们会这么使用React。</p><h3 id="场景4：type是一个component。"><a href="#场景4：type是一个component。" class="headerlink" title="场景4：type是一个component。"></a>场景4：<code>type</code>是一个<code>component</code>。</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// before <span class="keyword">update</span>:</span><br><span class="line">&#123; <span class="keyword">type</span>: <span class="keyword">Table</span>, props: &#123; <span class="keyword">rows</span>: <span class="keyword">rows</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">// <span class="keyword">after</span> <span class="keyword">update</span>:</span><br><span class="line">&#123; <span class="keyword">type</span>: <span class="keyword">Table</span>, props: &#123; <span class="keyword">rows</span>: <span class="keyword">rows</span> &#125; &#125;</span><br></pre></td></tr></table></figure><hr><p><strong>你可能会说，“咦，但没有任何变化啊！”，但是你错了。</strong></p><hr><p>如果<code>type</code>是对函数或类的引用（即常规的React组件），并且我们启动了tree diff的过程，则React每次都会去检查组件的内部逻辑，以确保<code>render</code>返回的值不会改变（类似对副作用的预防措施）。对树中的每个组件进行遍历和扫描 —— 是的，在复杂的渲染场景下，成本可能会非常昂贵！</p><p>值得注意的是，一个<code>component</code>的<code>render</code>（只有类组件在声明时有这个函数）跟<code>ReactDom.render</code>不是同一个函数。</p><h2 id="关注子组件（children）的情况"><a href="#关注子组件（children）的情况" class="headerlink" title="关注子组件（children）的情况"></a>关注子组件（children）的情况</h2><p>除了上述四种常见场景之外，当一个元素有多个子元素时，我们还需要考虑React的行为。现在假设我们有这么一个元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">props: &#123;</span><br><span class="line">  children: [</span><br><span class="line">      &#123; <span class="attr">type</span>: <span class="string">'div'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">type</span>: <span class="string">'span'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">type</span>: <span class="string">'br'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>我们想要交换一下这些children的顺序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">props: &#123;</span><br><span class="line">  children: [</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">'span'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">'div'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">'br'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>之后会发生什么呢？</p><p>当<code>diffing</code>的时候，如果React在检查<code>props.children</code>下的数组时，按顺序去对比数组内元素的话：index 0将与index 0进行比较，index 1和index 1，等等。对于每一次对比，React会使用之前提过的diff规则。在我们的例子里，它认为<code>div</code>成为一个<code>span</code>，那么就会运用到情景3。这样不是很有效率的：想象一下，我们已经从1000行中删除了第一行。React将不得不“更新”剩余的999个子项，因为按index去对比的话，内容从第一条开始就不相同了。</p><p>幸运的是，React有一个<code>内置的方法（built-in）</code>来解决这个问题。如果一个元素有一个<code>key</code>属性，那么元素将按<code>key</code>而不是<code>index</code>来比较。只要<code>key</code>是唯一的，React就会移动元素，而不是将它们从DOM树中移除然后再将它们放回（这个过程在React里叫mounting和unmounting）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">props: &#123;</span><br><span class="line">  children: [ <span class="comment">// Now React will look on key, not index</span></span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">'div'</span>, <span class="attr">key</span>: <span class="string">'div'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">'span'</span>, <span class="attr">key</span>: <span class="string">'span'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">'br'</span>, <span class="attr">key</span>: <span class="string">'bt'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h2 id="当state发生了改变"><a href="#当state发生了改变" class="headerlink" title="当state发生了改变"></a>当state发生了改变</h2><p>到目前为止，我们只聊了下React哲学里面的<code>props</code>部分，却忽视了另外很重要的一部分<code>state</code>。下面是一个简单的<code>stateful</code>组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">counter</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  increment = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    counter: <span class="keyword">this</span>.state.counter + <span class="number">1</span>,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  render = <span class="function"><span class="params">()</span> =&gt;</span> (<span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.increment&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;'Counter: ' + this.state.counter&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>state</code>对象里，我们有一个key<code>counter</code>。点击按钮时，这个值会增加，然后按钮的文本也会发生相应的改变。但是，当我们这样做时，DOM中发生了什么？哪部分将被重新计算和更新？</p><p>调用<code>this.setState</code>会导致<code>re-render</code>（重新渲染），但不会影响到整个页面，而只会影响组件本身及其children组件。父母和兄弟姐妹都不会受到影响。当我们有一个层级很深的组件链时，这会让状态更新变得非常方便，因为我们只需要重绘(<code>redraw</code>)它的一部分。</p><h2 id="把问题说清楚"><a href="#把问题说清楚" class="headerlink" title="把问题说清楚"></a>把问题说清楚</h2><p>我们准备了一个<a href="https://iadramelk.github.io/optimizing-react-demo/dist/before.html" target="_blank" rel="noopener">小demo</a>，以便你可以在看到在“野蛮生长”的React编码方式下最常见的问题，后续我也告诉大家怎么去解决这些问题。你可以在<a href="https://github.com/iAdramelk/optimizing-react-demo" target="_blank" rel="noopener">这里看看它的源代码</a>。你还需要<a href="https://github.com/facebook/react-devtools" target="_blank" rel="noopener">React Developer Tools</a>，请确保浏览器安装了它们。</p><p>我们首先要看看的是，哪些元素以及什么时候导致Virtual DOM的更新。在浏览器的开发工具中，打开React面板并选择“Highlight Updates”复选框：</p><p><img src="http://sinacloud.net/woodysblog/img/react_dev_tools.png" alt="&quot;在Chrome中使用“突出显示更新”复选框选中DevTools&quot;"></p><p>现在尝试在表格中添加一行。如你所见，页面上的每个元素周围都会显示一个边框。这意味着每次添加一行时，React都在计算和比较整个虚拟DOM树。现在尝试点击一行内的counter按钮。你将看到<code>state</code>更新后虚拟DOM如何更新 —— 只有引用了<code>state key</code>的元素及其children受到影响。</p><p>React DevTools会提示问题出在哪里，但不会告诉我们有关细节的信息：特别是所涉及的更新，是由<code>diffing</code>元素引起的？还是被挂载（<code>mounting</code>）或者被卸载（<code>unmounting</code>）了？要了解更多信息，我们需要使用React的内置<a href="https://reactjs.org/docs/optimizing-performance.html#profiling-components-with-the-chrome-performance-tab" target="_blank" rel="noopener">分析器</a>（注意它不适用于生产模式）。</p><p>添加<code>?react_perf</code>到应用的URL，然后转到Chrome DevTools中的“Performance”标签。点击“录制”（Record）并在表格上点击。添加一些row，更改一下counter，然后点击“停止”（Stop）。</p><p><img src="http://sinacloud.net/woodysblog/img/react_perf_tools.png" alt="&quot;React DevTools的“Performance”选项卡&quot;"></p><p>在输出的结果中，我们关注“User timing”这项指标。放大时间轴直到看到“React Tree Reconciliation”这个组及其子项。这些就是我们组件的名称，它们旁边都写着[update]或[mount]。</p><hr><p><strong>我们的大部分性能问题都属于这两类问题之一。</strong></p><hr><p>无论是组件（还是从它分支的其他组件）出于某种原因都会在每次更新时re-mounted（慢），又或者我们在大型应用上执行对每个分支做diff，尽管这些组件并没有发生改变，我们不希望这些情况的发生。</p><h2 id="优化我们的代码：Mounting-Unmounting"><a href="#优化我们的代码：Mounting-Unmounting" class="headerlink" title="优化我们的代码：Mounting / Unmounting"></a>优化我们的代码：Mounting / Unmounting</h2><p>现在，我们已经了解到当需要update Virtual Dom时，React是依据哪些规则去判断要不要更新，以及也知道了我们可以通过什么方式去追踪这些diff场景的背后发生了什么，我们终于准备好优化我们的代码了！首先，我们来看看mounts/unmounts。</p><p>如果你能够注意到当一个元素包含的多个children，他们是由array组成的话，你可以实现十分显著的速度优化。</p><p>我们来看看这个case：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;Message /&gt;</span><br><span class="line">  &lt;Table /&gt;</span><br><span class="line">  &lt;Footer /&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><p>在我们的Virtual DOM里这么表示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">props: &#123;</span><br><span class="line">  children: [</span><br><span class="line">    &#123; <span class="attr">type</span>: Message &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: Table &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: Footer &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>这里有一个简单的<code>Message</code>例子，就是一个<code>div</code>写着一些简单的文本，和以及一个巨大的<code>Table</code>，比方说，超过1000行。它们（<code>Message</code>和<code>Table</code>）都是顶级<code>div</code>的子组件，所以它们被放置在父节点的<code>props.children</code>下，并且它们<code>key</code>都不会有。React甚至不会通过控制台警告我们要给每个<code>child</code>分配<code>key</code>，因为children正在<code>React.createElement</code>作为参数列表传递给父元素，而不是直接遍历一个数组。</p><p>现在我们的用户已读了一个通知，<code>Message</code>（譬如新通知按钮）从DOM上移除。<code>Table</code>和<code>Footer</code>是剩下的全部。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">props: &#123;</span><br><span class="line">  children: [</span><br><span class="line">    &#123; <span class="attr">type</span>: Table &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: Footer &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>React会怎么处理呢？它会看作是一个array类型的children，现在少了第一项，从前第一项是<code>Message</code>现在是<code>Table</code>了，也没有<code>key</code>作为索引，比较<code>type</code>的时候又发现它们俩不是同一个function或者class的同一个实例，于是会把整个<code>Table</code>unmount，然后在mount回去，渲染它的1000+行子数据。</p><p>因此，你可以给每个component添加唯一的<code>key</code>（但在目特殊的case下，使用key并不是最佳选择），或者采用更聪明的小技巧：使用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators" target="_blank" rel="noopener">短路求值</a>（又名“最小化求值”），这是JavaScript和许多其他现代语言的特性。看：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Using a boolean trick</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;isShown &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Message</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Table</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Footer</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>虽然<code>Message</code>会离开屏幕，父元素<code>div</code>的<code>props.children</code>仍然会拥有三个元素，<code>children[0]</code>具有一个值<code>false</code>（一个布尔值）。请记住<code>true, false, null, undefined</code>是虚拟DOM对象<code>type</code>属性的允许值，我们最终得到了类似的结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">props: &#123;</span><br><span class="line">  children: [</span><br><span class="line">    <span class="literal">false</span>, <span class="comment">//  isShown &amp;&amp; &lt;Message /&gt; evaluates to false</span></span><br><span class="line">    &#123; <span class="attr">type</span>: Table &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: Footer &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>因此，有没有<code>Message</code>组件，我们的索引值都不会改变，<code>Table</code>当然仍然会跟<code>Table</code>比较（当<code>type</code>是一个函数或类的引用时，diff比较的成本还是会有的），但仅仅比较虚拟DOM的成本，通常比“删除DOM节点”并“从0开始创建”它们要来得快。</p><p>现在我们来看看更多的东西。大家都挺喜欢用HOC的，高阶组件是一个将组件作为参数，执行某些操作，最后返回另外一个不同功能的组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withName</span>(<span class="params">SomeComponent</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Computing name, possibly expensive...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">SomeComponent</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">name</span>=<span class="string">&#123;name&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>这是一种常见的模式，但你需要小心。如果我们这么写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>() </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// Creates a new instance on each render</span></span><br><span class="line">    <span class="keyword">const</span> ComponentWithName = withName(SomeComponent);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">SomeComponentWithName</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>我们在父节点的<code>render</code>方法内部创建一个HOC。当我们重新渲染（<code>re-render</code>）树时，虚拟DOM是这样子的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// On first render:</span></span><br><span class="line">&#123;</span><br><span class="line">  type: ComponentWithName,</span><br><span class="line">  props: &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// On second render:</span></span><br><span class="line">&#123;</span><br><span class="line">  type: ComponentWithName, <span class="comment">// Same name, but different instance</span></span><br><span class="line">  props: &#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，React会对<code>ComponentWithName</code>这个实例做diff，但由于此时同名引用了不同的实例，因此全等比较（triple equal）失败，一个完整的re-mount会发生（整个节点换掉），而不是调整属性值或顺序。注意它也会导致状态丢失，<a href="https://github.com/facebook/react/blob/044015760883d03f060301a15beef17909abbf71/docs/docs/higher-order-components.md#dont-use-hocs-inside-the-render-method" target="_blank" rel="noopener">如此处所述</a>。幸运的是，这很容易解决，你需要始终在<code>render</code>外面创建一个HOC：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Creates a new instance just once</span></span><br><span class="line"><span class="keyword">const</span> ComponentWithName = withName(Component);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>() </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ComponentWithName</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="优化我的代码：Updating"><a href="#优化我的代码：Updating" class="headerlink" title="优化我的代码：Updating"></a>优化我的代码：Updating</h2><p>现在我们可以确保在非必要的时候，不做re-mount的事情了。然而，对位于DOM树根部附近（层级越上面的元素）的组件所做的任何更改都会导致其所有children的diffing和调整（<code>reconciliation</code>）。在层级很多、结构复杂的应用里，这些成本很昂贵，但经常是可以避免的。</p><hr><p><strong>如果有一种方法可以告诉React你不用来检查这个分支了，因为我们可以肯定那个分支不会有更新，那就太棒了！</strong></p><hr><p>这种方式是真的有的哈，它涉及一个built-in方法叫<code>shouldComponentUpdate</code>，它也是<a href="https://reactjs.org/docs/react-component.html#the-component-lifecycle" target="_blank" rel="noopener">组件生命周期</a>的一部分。这个方法的调用时机：组件的<code>render</code>和组件接收到state或props的值的更新时。然后我们可以自由地将它们与我们当前的值进行比较，并决定是否更新我们的组件（返回<code>true</code>或<code>false</code>）。如果我们返回<code>false</code>，React将不会重新渲染组件，也不会检查它的所有子组件。</p><p>通常来说，比较两个集合（set）<code>props</code>和<code>state</code>一个简单的浅层比较（shallow comparison）就足够了：如果顶层的值不同，我们不必接着比较了。浅比较不是JavaScript的一个特性，但有很多<a href="https://github.com/dashed/shallowequal" target="_blank" rel="noopener">小而美的库</a>（<code>utilities</code>）可以让我们用上那么棒的功能。</p><p>现在可以像这样编写我们的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableRow</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// will return true if new props/state are different from old ones</span></span><br><span class="line">  shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; props, state &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> !shallowequal(props, nextProps)</span><br><span class="line">           &amp;&amp; !shallowequal(state, nextState);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是你甚至都不需要自己写代码，因为React把这个特性内置在一个类<code>React.PureComponent</code>里面。它类似于  <code>React.Component</code>，只是<code>shouldComponentUpdate</code>已经为你实施了一个浅的<code>props</code>/<code>state</code>比较。</p><p>这听起来很“不动脑”，在声明class继承（<code>extends</code>）的时候，把<code>Component</code>换成<code>PureComponent</code>就可以享受高效率。事实上，并不是这么“傻瓜”，看看这些例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Table</span><br><span class="line">    <span class="comment">// map returns a new instance of array so shallow comparison will fail</span></span><br><span class="line">    rows=&#123;rows.map(<span class="comment">/* ... */</span>)&#125;</span><br><span class="line">    <span class="comment">// object literal is always "different" from predecessor</span></span><br><span class="line">    style=&#123; &#123; <span class="attr">color</span>: <span class="string">'red'</span> &#125; &#125;</span><br><span class="line">    <span class="comment">// arrow function is a new unnamed thing in the scope, so there will always be a full diffing</span></span><br><span class="line">    onUpdate=&#123;() =&gt; &#123; <span class="comment">/* ... */</span> &#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p>上面的代码片段演示了三种最常见的反模式。尽量避免它们！</p><hr><p><strong>如果你能注意点，在render定义之外创建所有对象、数组和函数，并确保它们在各种调用间，不发生更改 —— 你是安全的。</strong></p><hr><p>你在<a href="https://iadramelk.github.io/optimizing-react-demo/dist/after.html" target="_blank" rel="noopener">updated demo</a>，所有table的rows都被“净化”（<code>purified</code>）过，你可以看到<code>PureComponent</code>的表现了。如果你在React DevTools中打开“Highlight Updates”，你会注意到只有表格本身和新行在插入时会触发<code>render</code>，其他的行保持不变。</p><p>[译者说：为了便于大家理解<code>purified</code>，译者在下面插入了原文demo的一段代码]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableRow</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> React.createElement(<span class="string">'tr'</span>, &#123; <span class="attr">className</span>: <span class="string">'row'</span> &#125;,</span><br><span class="line">      React.createElement(<span class="string">'td'</span>, &#123; <span class="attr">className</span>: <span class="string">'cell'</span> &#125;, <span class="keyword">this</span>.props.title),</span><br><span class="line">      React.createElement(<span class="string">'td'</span>, &#123; <span class="attr">className</span>: <span class="string">'cell'</span> &#125;, React.createElement(Button)),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不过，如果你迫不及待地all in PureComponent，在应用里到处都用的话 —— 控制住你自己！</p><p>shallow比较两组<code>props</code>和<code>state</code>不是免费的，对于大多数基本组件来说，甚至都不值得：<code>shallowCompare</code>比<code>diffing</code>算法需要耗费更多的时间。</p><p>使用这个经验法则：pure component适用于复杂的表单和表格，但它们通常会减慢简单元素（按钮、图标）的效率。</p><hr><p>感谢你的阅读！现在你已准备好将这些见解应用到你的应用程序中。可以使用我们的小demo（<a href="https://iadramelk.github.io/optimizing-react-demo/dist/after.html" target="_blank" rel="noopener">用了</a>或<a href="https://iadramelk.github.io/optimizing-react-demo/dist/before.html" target="_blank" rel="noopener">没有用</a>PureComponent）的<a href="https://github.com/iAdramelk/optimizing-react-demo" target="_blank" rel="noopener">仓库</a>作为你的实验的起点。此外，请继续关注本系列的下一部分，我们计划涵盖Redux并优化你的数据，目标是提高整个应用的总体性能。</p><h2 id="译者说"><a href="#译者说" class="headerlink" title="译者说"></a>译者说</h2><p>正如原文末所说，Alex和Andy后续会继续写一个关于整体性能的系列，包括核心React和Redux等，我也会继续跟踪这个系列的文章，到时po到我的<a href="http://wuyuying.com/blog/">个人博客</a>和知乎专栏<a href="https://zhuanlan.zhihu.com/front-end-thinking" target="_blank" rel="noopener">《集异璧》</a>，感兴趣的同学们可以关注一下哈 ：）</p><p>欢迎对本文的翻译质量、内容的各种讨论。若有表述不当，欢迎斧正。</p><p>2018.05.13，晴，杭州滨江<br>Yuying Wu</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文译自&lt;a href=&quot;https://evilmartians.com/chronicles/optimizing-react-virtual-dom-explained&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Optimizing React
      
    
    </summary>
    
    
      <category term="front-end" scheme="http://wuyuying.com/tags/front-end/"/>
    
      <category term="performance" scheme="http://wuyuying.com/tags/performance/"/>
    
      <category term="reactjs" scheme="http://wuyuying.com/tags/reactjs/"/>
    
      <category term="translation" scheme="http://wuyuying.com/tags/translation/"/>
    
  </entry>
  
  <entry>
    <title>关于「自由态职业」</title>
    <link href="http://wuyuying.com/archives/slash/"/>
    <id>http://wuyuying.com/archives/slash/</id>
    <published>2018-04-30T15:37:19.000Z</published>
    <updated>2018-06-05T13:46:08.059Z</updated>
    
    <content type="html"><![CDATA[<p>最近读了萧秋水和剽悍一只猫的<a href="https://book.douban.com/subject/27177491/" target="_blank" rel="noopener">《知识变现》</a>，准确的来说，这本书不全是讲如何变现你的知识，而是从多方面去解释什么是“斜杠青年”和“自由职业”，而“自由态职业”又是什么，个人觉得此书应该改名为《国内斜杠青年/自由工作者的生活/工作现状》。</p><a id="more"></a><p>想起在新西兰working holiday的时候，曾经遇到一个Airbnb的房东Chris，是个自由职业的程序员。一次偶然的机会看到他的书房，看到3个屏幕，我就问他是不是IT行业的，没想到Chris是为IBM远程工作的，他在新西兰，团队base在美国还是加拿大，做的是后端开发相关工作。</p><p>这次我第一次面基自由职业者的工程师，非常好奇，就趁机问了一直很感兴趣的几个问题。</p><p><code>WYY:</code> 为什么会选择自由职业？<br><code>Chris:</code> 我有两个孩子，希望多一点时间陪伴家人，如果出国工作的话，可能一年就没多少时间可以在家里陪伴家人了。（注：新西兰的IT工作机会一般在奥克兰、惠灵顿这样的大城市，不过相对没有像美国或者中国一样有各式各样的top IT companies哈）</p><p><code>WYY:</code> 那日常你是怎么工作的呢？<br><code>Chris:</code> 早上6点起床，趁着孩子们还没起床，就开始锻炼和工作，有个独立的书房，可以安静的做自己的事情。然后到点了送孩子们去上学，回来继续工作，那么到孩子们放学之后，我就有自由的时间可以陪伴他们了。</p><p><code>WYY:</code> remote的工作，是怎么找到工作的？不会沟通成本比较高吗？<br><code>Chris:</code> 我之前就在IBM工作的，比较熟悉工作流程，后来我因为家庭原因，选择回来新西兰，我的前老板问我有没有兴趣远程工作，我就答应了，跟团队的合作、沟通还算流畅。</p><p>其实从跟Chris的对话里面可以发现，自由职业者的生活有可能比正常朝九晚五还困难些，需要自律，也需要具备很好的时间管理的能力，才能在工作和生活的时间打乱的情况，还能做到很好的平衡。专业能力以外，你可能还需要做一些自我销售、运营等等的工作以外的事情，让更多人知道你和信任你。</p><p>“自由职业”不是一种职业，而是你本身具备专业能力，有选择的“自由”。</p><p>正如书中说的：</p><blockquote><p>成为自由职业者并不是一件容易的事，要成为自由职业者，必须是具有一定的专业知识与技能，要有社会生存能力，还要有坚强的意志。</p></blockquote><p>整体来说，如果想了解斜杠青年/自由职业者的工作生活状态的话，还是可以看看这本书哈。更多书摘如下。</p><h2 id="斜杠青年和自由职业，职业定位新趋势"><a href="#斜杠青年和自由职业，职业定位新趋势" class="headerlink" title="斜杠青年和自由职业，职业定位新趋势"></a>斜杠青年和自由职业，职业定位新趋势</h2><p>“斜杠青年”来源于英文“Slash”，《纽约时报》专栏作家麦瑞克·阿尔伯撰写了一本书，叫作《双重职业》（One Person/Multiple Careers: A New Model for Work/Life Success）。</p><h3 id="你认为普通人如何修炼才能成为斜杠青年？"><a href="#你认为普通人如何修炼才能成为斜杠青年？" class="headerlink" title="你认为普通人如何修炼才能成为斜杠青年？"></a>你认为普通人如何修炼才能成为斜杠青年？</h3><p>（from 吉吉）</p><h4 id="第一，知道自己为什么要成为斜杠青年再开始："><a href="#第一，知道自己为什么要成为斜杠青年再开始：" class="headerlink" title="第一，知道自己为什么要成为斜杠青年再开始："></a>第一，知道自己为什么要成为斜杠青年再开始：</h4><ol><li>不要赶流行，不要因为别人说斜杠青年好，就盲目地加入，这应该是一种有目标的主动选择，而且知道需要大量的投入，其实很辛苦；</li><li>有深层次的需求，像我说的安全感，还有一些契机，比如年龄、家庭变故、工作瓶颈等；</li><li>摆清斜杠和单杠的关系，斜杠不是单杠做不好就逃避，单杠没解决的问题没踩过的坑，斜杠一样会掉进去重补这一课，所以应该把单杠做好，打一个比较稳的地基，培养核心技能，就算不喜欢，单杠也可以修炼你把不喜欢的事做好的能力。</li></ol><h4 id="第二，斜杠青年的四阶段："><a href="#第二，斜杠青年的四阶段：" class="headerlink" title="第二，斜杠青年的四阶段："></a>第二，斜杠青年的四阶段：</h4><ol><li><p>照妖镜：认知自己，找到精进的方向。</p><ul><li><p>更多维度地去了解自己，通过各种各样的工具，比如性格测试、行为风格测试、生活态度取向测试、价值观梳理，去认知自己，知道自己是什么样的人，为什么同样是探索，速度、节奏、心态会有不同。</p></li><li><p>知道自己喜欢什么，找到兴趣和天命。排除钱、时间等因素，最想做什么，梳理过往成就事件，找到一些共性，发现自己真正喜欢的是什么。</p></li><li><p>认知现实、遥望理想，将愿景描绘出来并固化，找到差距和努力的方向。</p></li></ul></li><li><p>默练剑：通过持续行动，修炼技能</p><ul><li>划分能力矩阵，喜欢与擅长的优势区是核心技能，需要不断打磨；</li><li>喜欢但是不擅长的，是潜能的部分，应该加强，培育发芽的小种子；</li><li>不喜欢也不擅长的盲区，不要做，回避不了的，死磕到不扯后腿。</li></ul></li><li><p>等风来：外化自己，扩大圈子，告诉别人自己准备好了，积极地站在风口处等待机会的来临，甚至主动出击。</p></li><li><p>滚雪球：依托一个平台和身份，斜杠身份的数量会不断地拓展，然后要具有把多重身份整合在一起打组合拳的能力。</p></li></ol><h4 id="第三，斜杠青年要注意的："><a href="#第三，斜杠青年要注意的：" class="headerlink" title="第三，斜杠青年要注意的："></a>第三，斜杠青年要注意的：</h4><ol><li>要围绕个人品牌，这样单个身份或者平台如果失去了势能，大家还会因为认可这个人而追随。</li><li>所有的积累都有价值，不一定马上兑换成显性的名利，但是这当中积累的经验、可迁移的能力都是弥足珍贵的，人走的每一步，都有价值。</li><li>要有多个维度的平衡：阶段性专注、身体保障、家人情感的支持、时常审视初心。</li></ol><h2 id="你适合成为自由职业者吗"><a href="#你适合成为自由职业者吗" class="headerlink" title="你适合成为自由职业者吗"></a>你适合成为自由职业者吗</h2><p>成为自由职业者并不是一件容易的事，要成为自由职业者，必须是具有一定的专业知识与技能，要有社会生存能力，还要有坚强的意志。</p><p>自由职业的自由，不是辞职的自由，而是选择的自由，这个选择背后，是能力的自由。</p><p>要想在自己的自由职业生涯中最大限度地降低风险，有几项原则：</p><p>第一，要把握好“市场需要、我最擅长、能者不多”的定位原则，使自己或自己的产品具有市场性、竞争性和独特性；不要试图山寨别人，靠拷贝别人现买现卖是没有竞争力的。同样的道理，如果你的产品或服务能够被别人轻易拷贝，那也说明你并没有别人不能取代的核心竞争力。</p><p>第二，为了防止自己知识和技能的老化，你必须具有不断学习和创造的能力，而不是试图“一招鲜，吃遍天”。这在知识更新速度日益加快的今天，已经行不通了。学习能力已经演变成为新的生存能力。</p><p>第三，增强自己的法律意识和风险意识，在与人合作的过程中要有维权意识，注意用法律和规则保护自己，以防“客大欺店”和遭小人暗算。</p><p>第四，尽早地为自己在医疗、意外和养老方面投入必要的保险资金，做到晴天也防连阴雨。</p><h2 id="互联网时代的雇佣关系"><a href="#互联网时代的雇佣关系" class="headerlink" title="互联网时代的雇佣关系"></a>互联网时代的雇佣关系</h2><p>里德·霍夫曼的《联盟》开章明义，给出了这样的观点。</p><p>在里德看来，用联盟的方式重建雇主和员工的关系非常必要。“商业世界需要有利于相互信任、相互投资、共同受益的新雇佣关系框架。理想的雇佣关系框架鼓励员工发展个人人脉、勇于开拓实干，而不是成为唯利是图的跳槽专业户。”</p><p>如何建立联盟，书中有几个最重要的观点：</p><ol><li>相互坦诚</li><li>相互尊重对方的价值观和梦想，并一起努力。</li><li>制定互惠互利的任期计划，包含双方的权利、义务和利益，并有明确的目标和时间（据书中的意思，就好像足球俱乐部的模式一样，队员干满一个赛季就可以转会，也可以继续留在球队干）。</li><li>帮助员工个人的职业发展。</li><li>鼓励和支持员工发展个人人脉，并保持与离职员工的相互关注和长久合作。</li></ol><h2 id="K-K-的1000付费用户理论"><a href="#K-K-的1000付费用户理论" class="headerlink" title="K.K.的1000付费用户理论"></a>K.K.的1000付费用户理论</h2><p>读凯文·凯利的《技术元素》，里面提到了1000人付费理论。主要的观点是，如果有1000人愿意给你一天自己的收入，那独立手艺人就可以依靠这个专门生产工作。</p><h2 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h2><p>《搞定1》<br>《小强升职记》</p><h2 id="每个人都可以是自己的人生设计师"><a href="#每个人都可以是自己的人生设计师" class="headerlink" title="每个人都可以是自己的人生设计师"></a>每个人都可以是自己的人生设计师</h2><p>《游牧东京》：作者米田智彦做的“生活实践项目” —— 不住在家里，也没有固定的办公室里工作，而是仅依靠一个拉杆箱在东京游走，与他人共享大都市的所有功能。</p><h2 id="如何提升基础能力"><a href="#如何提升基础能力" class="headerlink" title="如何提升基础能力"></a>如何提升基础能力</h2><h3 id="一、如何锻炼阅读能力"><a href="#一、如何锻炼阅读能力" class="headerlink" title="一、如何锻炼阅读能力"></a>一、如何锻炼阅读能力</h3><p>《如何阅读一本书》<br>《这样读书就够了》<br>《拆出你的沟通力I》<br>《拆出你的沟通力II》</p><h3 id="二、如何锻炼思考能力"><a href="#二、如何锻炼思考能力" class="headerlink" title="二、如何锻炼思考能力"></a>二、如何锻炼思考能力</h3><p><a href="https://www.douban.com/doulist/44255360/" target="_blank" rel="noopener">豆瓣书单</a> from 萧秋水</p><ol><li>《麦肯锡入职培训第一课》</li><li>《轻松学会独立思考》</li><li>《思考的技术》</li><li>《思考，快与慢》</li><li>《比知识还多》（最后一本比较难，可以先从作者的另外一本书《六顶思考帽》开始）</li></ol><h3 id="三、如何提升写作能力"><a href="#三、如何提升写作能力" class="headerlink" title="三、如何提升写作能力"></a>三、如何提升写作能力</h3><p>刻意练习第一条就得确定你练习要达到的目标。</p><p>你写哪个方向？准备用怎样的类型写作？对标的高手是谁？你计划通过多少篇的练习达到何种水平的输出质量？达到怎样输出质量的文章你才对外分享？</p><p>想好写什么文章，可以先写，也可以看别人怎样写再模仿写，都可以。但无论如何一定要多看。</p><p>比方写影评，先想想自己怎样写，好选一个不同的点切入。然后带着构思去翻别人写的影评，看看别人的立意、切入点、选图、联系的案例，还有金句，包括整体的框架，对比后发现不足，然后就知道改进的方向。</p><p>看完你要能说出一篇文章好在哪里，不好在哪里，要能看出你和作者在阅读面、阅历面上的差距在哪里。这样的看才能帮助自己找到差距，进而通过有追赶目标的写作来提升自己的写作质量。</p><h4 id="多看还要解决两个问题"><a href="#多看还要解决两个问题" class="headerlink" title="多看还要解决两个问题"></a>多看还要解决两个问题</h4><p>第一，看真正好的文字，看真正优秀写作者的文字。<br>第二，看不同类型的写作者的好文字，避免形成写作路径的依赖，广义的多看也包括看电影、听音乐，一切艺术都可以激发写作的灵感。</p><p>这也是多看的另外一个价值，帮助自己找到写作灵感，打开写作思路。</p><h4 id="今天的问题"><a href="#今天的问题" class="headerlink" title="今天的问题"></a>今天的问题</h4><p>什么是写作？什么是有质量的写作？什么是长期保持有质量的写作？</p><p>要提升能力，只读书是不够的，需要反复训练，才能真正提升，比如阅读能力，如果阅读的速度和质量上不去，那么学习能力也谈不上很高。而思考和写作更是需要练习的事情，这些练习，其实可以结合工作一起进行，即：根据自己的职业生涯规划和人生目标来确定阅读范围，并注重实践。</p><p>除了读书训练以外，接受培训、包括系统的成人教育，比如MBA等也是有效的，现在在线课程和学习社群也很发达，系统地学习课程和参与课程也是吸收知识的好途径。</p><h3 id="四、如何提升专业能力"><a href="#四、如何提升专业能力" class="headerlink" title="四、如何提升专业能力"></a>四、如何提升专业能力</h3><p>构建专业知识地图（知识树）。</p><p>《全新思维》一书里讲过，未来最重要的六种技能是：</p><ul><li><p>设计感：每个人都必须培养一种艺术感，好的设计可以改变世界，不管从事什么样的工作，都可以像艺术家一样工作。</p></li><li><p>故事感：会讲故事，用故事的形式表达自己、与人沟通，故事性会越来越成为商品和服务在拥挤的市场中脱颖而出的一件法宝。如果你对故事感的理解还不够，可以去了解一下戚泽明的故事，他从故事里看到商机，自称“首席故事官”。</p></li><li><p>交响能力：可以理解为整合事物的能力、跨界能力，善于找出看上去毫不相干的领域之间的联系，善于组合别人所不在意的要素，实现创新。</p></li><li><p>共情能力：可以理解为同理心，能够设身处地体验他人处境，从而达到感受和理解他人情感的能力。</p></li><li><p>娱乐感：简单说来就是会玩，人需要具备适当的幽默感（可千万别误解为会说黄段子！），不仅会玩，更要玩出水平。</p></li><li><p>探寻意义：能够寻找生存的意义，认真对待精神追求，寻找真正的幸福。</p></li></ul><p>简单的来说，就是：</p><p>要有品位、懂艺术、要会讲故事，能跨界，有同理心，会玩出花样来，而且要有追求，会探寻事物的意义。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近读了萧秋水和剽悍一只猫的&lt;a href=&quot;https://book.douban.com/subject/27177491/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《知识变现》&lt;/a&gt;，准确的来说，这本书不全是讲如何变现你的知识，而是从多方面去解释什么是“斜杠青年”和“自由职业”，而“自由态职业”又是什么，个人觉得此书应该改名为《国内斜杠青年/自由工作者的生活/工作现状》。&lt;/p&gt;
    
    </summary>
    
      <category term="reading" scheme="http://wuyuying.com/categories/reading/"/>
    
    
  </entry>
  
  <entry>
    <title>CSS Variables学习笔记</title>
    <link href="http://wuyuying.com/archives/css-var/"/>
    <id>http://wuyuying.com/archives/css-var/</id>
    <published>2018-01-11T09:32:16.000Z</published>
    <updated>2018-06-05T13:46:08.042Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了下CSS Variables（CSS变量，又名CSS自定义属性），跟大家分享一下我的学习笔记。</p><h2 id="一、什么是CSS-Variables"><a href="#一、什么是CSS-Variables" class="headerlink" title="一、什么是CSS Variables"></a>一、什么是CSS Variables</h2><p>来，直接看<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Using_CSS_variables" target="_blank" rel="noopener">MDN</a>上的描述：</p><blockquote><p>CSS 变量是由CSS作者定义的实体，其中包含要在整个文档中重复使用的特定值。使用自定义属性来设置变量名，并使用特定的 var() 来访问。</p></blockquote><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">color</span>: <span class="built_in">var</span>(--main-<span class="built_in">color</span>);</span><br></pre></td></tr></table></figure><h2 id="二、学习笔记"><a href="#二、学习笔记" class="headerlink" title="二、学习笔记"></a>二、学习笔记</h2><h3 id="1-声明-amp-调用"><a href="#1-声明-amp-调用" class="headerlink" title="1. 声明 &amp; 调用"></a>1. 声明 &amp; 调用</h3><h4 id="i-声明方式"><a href="#i-声明方式" class="headerlink" title="i. 声明方式"></a>i. 声明方式</h4><p>CSS变量声明的方式非常简单，如下，声明了一个名叫<code>color</code>的CSS变量。</p><ul><li>在css文件中写</li><li>写在html标签的inline-style里</li><li>用JS给某个元素声明，方法<code>.style.setProperty</code></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">  <span class="attribute">--color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">"--color: red;"</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>].style.setProperty(<span class="string">'--color'</span>, <span class="string">'red'</span>)</span><br></pre></td></tr></table></figure><h4 id="ii-调用方式"><a href="#ii-调用方式" class="headerlink" title="ii. 调用方式"></a>ii. 调用方式</h4><p>通过<code>var()</code>函数调用，如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.block</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="iii-变量的命名"><a href="#iii-变量的命名" class="headerlink" title="iii. 变量的命名"></a>iii. 变量的命名</h4><p>说完声明和调用，还有个小问题。那么，CSS变量的命名，有什么限制么？下面我们来测试一下。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.foo-test</span>&#123;</span><br><span class="line">  <span class="attribute">--foo</span>:;</span><br><span class="line">  <span class="attribute">--ffoo</span>:;</span><br><span class="line">  <span class="attribute">--Foo</span>: red;</span><br><span class="line">  <span class="attribute">--FOo</span>: blue;</span><br><span class="line">  <span class="attribute">--FOO</span>: green;</span><br><span class="line">  <span class="comment">/* 以下省略测试className的代码 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://sinacloud.net/woodysblog/img/css-var-case-sensitive.png" alt=""></p><p>从以上测试代码可以看出：</p><ul><li>CSS变量的命名是大小写敏感的</li><li>不赋值或者赋值空格，都是无效的</li></ul><h3 id="2-作用域-amp-继承"><a href="#2-作用域-amp-继承" class="headerlink" title="2. 作用域 &amp; 继承"></a>2. 作用域 &amp; 继承</h3><p>CSS变量也有作用域一说，而最顶层的作用域就是<code>:root</code>，下面的所有的元素都可以共享相关CSS变量。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span>&#123;</span><br><span class="line">  <span class="attribute">--color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚才我们在<code>body</code>上，定义了<code>--color</code>，在<code>body</code>下的子元素，都会默认继承这个属性，随意使用。当然也可以重载，把<code>--color</code>定义为别的值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"block"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>inherit color<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"css-var-text"</span>&gt;</span>overwrite color - hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">  <span class="attribute">--color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.block</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.css-var-text</span>&#123;</span><br><span class="line">  <span class="attribute">--color</span>: red;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>.block</code>，作为<code>body</code>的子元素，继承了<code>--color</code>属性，所以边框出来就是<code>green</code>。</p><p>而<code>.css-var-text</code>在自己的作用域中，重写了<code>--color</code>，出来的字体颜色是overwrite后的<code>blue</code>。</p><p><img src="http://sinacloud.net/woodysblog/img/css-var-inherit.png" alt=""></p><h3 id="3-浏览器支持"><a href="#3-浏览器支持" class="headerlink" title="3. 浏览器支持"></a>3. 浏览器支持</h3><h4 id="i-浏览器支持现状"><a href="#i-浏览器支持现状" class="headerlink" title="i. 浏览器支持现状"></a>i. 浏览器支持现状</h4><p>来看看<a href="https://caniuse.com/#search=css%20variables" target="_blank" rel="noopener">caniuse</a>上CSS Variables (Custom Properties)的支持度：</p><p>PC的话，IE 11和Edge的支持度都很差，而Chrome（2016.3）、Firefox（2017.11）和Safari(2017.3)的一些新版本都是支持的，相信很快就能普及。</p><p>Mobile的话，Safari在2016年的版本已经支持CSS变量了，但Opera、Chrome、UC等的支持还不太好。</p><p><img src="http://sinacloud.net/woodysblog/img/css-var-browser-support.png" alt=""></p><h4 id="ii-fallbacks"><a href="#ii-fallbacks" class="headerlink" title="ii. fallbacks"></a>ii. fallbacks</h4><p>浏览器的支持度不太好，我们又想玩新东西的话，就需要考虑如果浏览器不支持CSS变量，怎么优雅降级。（嗷，两套代码是有点……）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 当浏览器不支持CSS变量 */</span></span><br><span class="line"><span class="selector-class">.browser-support</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>: red;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 当浏览器支持CSS变量 */</span></span><br><span class="line">@<span class="keyword">supports</span> (--css: variables) &#123;</span><br><span class="line">  <span class="selector-class">.browser-support</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">var</span>(--color);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、代码习作"><a href="#三、代码习作" class="headerlink" title="三、代码习作"></a>三、代码习作</h2><h3 id="1-codepen"><a href="#1-codepen" class="headerlink" title="1. codepen"></a>1. codepen</h3><p>在学习CSS Variables的时候，有边写一些教程的demo，除了以上，还包括一些实际场景的应用，如像box-shadow复合属性的拆解，以及JS操作CSS变量等。</p><p></p><p data-height="500" data-theme-id="0" data-slug-hash="dZrYJg" data-default-tab="css,result" data-user="wuyuying" data-embed-version="2" data-pen-title="CSS Varibles Study Notes" class="codepen">See the Pen <a href="https://codepen.io/wuyuying/pen/dZrYJg/" target="_blank" rel="noopener">CSS Varibles Study Notes</a> by Y (<a href="https://codepen.io/wuyuying" target="_blank" rel="noopener">@wuyuying</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script><h3 id="2-flexbox属性的DEMO"><a href="#2-flexbox属性的DEMO" class="headerlink" title="2. flexbox属性的DEMO"></a>2. flexbox属性的DEMO</h3><p><img src="http://sinacloud.net/woodysblog/img/css-var-flexbox.png" alt=""></p><p>之前在团队也做过一下下flexbox的分享，大家也知道，flex属性和对应的值特别多，当时就很想做个可以随时变属性值看效果的playground。</p><p>但想了下传统的实现方式，貌似没有优雅的方法。</p><ul><li>CSS+JS实现：写一批classname，option切换时，通过JS修改classname改变样式；</li><li>纯JS实现，根据option的value用JS改写元素的inline style（一直修改dom）</li></ul><p>哎哟，换CSS Variables之后，一切就不一样了，可继承、可复用、易维护，目前实现比较简单，可能跟以上的传统方式差别不太大，不过后续要修改或者做更多优化，我相信优势就会凸显出来了。</p><p>demo传送门：<a href="http://wuyuying.com/flexbox-css-var/">wuyuying.com/flexbox-css-var</a><br><a href="https://github.com/YuyingWu/blog-modern/blob/master/pages/flexbox-css-var.js" target="_blank" rel="noopener">github传送门</a></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>哈哈，没想到小结写什么，如果大家有好玩的CSS Variables的应用，欢迎分享给我 ：）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近看了下CSS Variables（CSS变量，又名CSS自定义属性），跟大家分享一下我的学习笔记。&lt;/p&gt;
&lt;h2 id=&quot;一、什么是CSS-Variables&quot;&gt;&lt;a href=&quot;#一、什么是CSS-Variables&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="front-end" scheme="http://wuyuying.com/tags/front-end/"/>
    
      <category term="CSS" scheme="http://wuyuying.com/tags/CSS/"/>
    
      <category term="CSS Variables" scheme="http://wuyuying.com/tags/CSS-Variables/"/>
    
  </entry>
  
</feed>
