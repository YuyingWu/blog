<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>伍酱</title>
  
  <subtitle>吾悠杂货铺</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://wuyuying.com/"/>
  <updated>2018-06-06T02:31:40.000Z</updated>
  <id>http://wuyuying.com/</id>
  
  <author>
    <name>Yuying Wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Behavior Driven Development in ReactJS</title>
    <link href="http://wuyuying.com/archives/bdd-in-reactjs/"/>
    <id>http://wuyuying.com/archives/bdd-in-reactjs/</id>
    <published>2018-06-02T12:13:25.000Z</published>
    <updated>2018-06-06T02:31:40.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如果想跳过前文，可以直接定位到<a href="/blog/archives/test-driven-dev/#我的实战">实战篇</a></p></blockquote><h2 id="What-is-Test-Driven-Development"><a href="#What-is-Test-Driven-Development" class="headerlink" title="What is Test Driven Development?"></a>What is Test Driven Development?</h2><p>Coding of features and tests go hand in hand.</p><ol><li>Write a unit test.</li><li>Run the test. See it fail.</li><li>Write the feature code to pass the test.</li><li>Refactor the code.</li></ol><h2 id="Why-TDD"><a href="#Why-TDD" class="headerlink" title="Why TDD?"></a>Why TDD?</h2><ul><li>It reduces errors and defects in the long run.</li><li>It leads to higher quality code.</li></ul><h2 id="What-is-Behavior-Driven-Development"><a href="#What-is-Behavior-Driven-Development" class="headerlink" title="What is Behavior Driven Development?"></a>What is Behavior Driven Development?</h2><ul><li>A variation of TDD that tests for user scenarios.</li><li>Given, when, then… [ pattern ]</li><li>Given notes, when deleting, then remove a note.</li><li>BDD consists of scenarios/specifications.</li></ul><a id="more"></a><h2 id="Test-Tools"><a href="#Test-Tools" class="headerlink" title="Test Tools"></a>Test Tools</h2><ul><li>Jest</li><li>Enzyme</li></ul><blockquote><p>如果想看create-react-app或jest/enzyme环境的配置，可以<a href="#Setup">定位到setup内容</a>。</p></blockquote><h2 id="我的实战"><a href="#我的实战" class="headerlink" title="我的实战"></a>我的实战</h2><p>项目中Jest and Enzyme的实战。</p><h3 id="1-第一个Unit-Test-toMatchSnapshot"><a href="#1-第一个Unit-Test-toMatchSnapshot" class="headerlink" title="1. 第一个Unit Test: toMatchSnapshot"></a>1. 第一个Unit Test: <code>toMatchSnapshot</code></h3><p>快照是Jest把调用时的component的结构记录下来，下次可以用来对比结构有没有差异。</p><p>如果不一样，Jest会报错，如果是预期内的展示，可以按<code>u</code>把当前快照更新为最新的snapshot。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'render correctly'</span>, () =&gt; &#123;</span><br><span class="line">  expect(app).toMatchSnapshot();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-测试component的state"><a href="#2-测试component的state" class="headerlink" title="2. 测试component的state"></a>2. 测试component的state</h3><p>state的初始化检测 —— 状态<code>gifts</code>的值为空数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'init `state` for gifts as an empty list'</span>, () =&gt; &#123;</span><br><span class="line">  expect(app.state().gifts).toEqual([]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意：在jest中获得state是一个<code>state()</code>函数。</p><h3 id="3-点击交互的测试"><a href="#3-点击交互的测试" class="headerlink" title="3. 点击交互的测试"></a>3. 点击交互的测试</h3><p>通过className去查找交互元素，模拟用户行为，其中<code>simulate</code>是Enzyme提供的模拟函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'add a gift to `state` when click the `add` button'</span>, () =&gt; &#123;</span><br><span class="line">  app.find(<span class="string">'.btn-add'</span>).simulate(<span class="string">'click'</span>);</span><br><span class="line"></span><br><span class="line">  expect(app.state().gifts.length).not.toBe(<span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检验某个component（Gift）是否存在</span></span><br><span class="line">it(<span class="string">'create a Gift component'</span>, () =&gt; &#123;</span><br><span class="line">  expect(app.find(Gift).exists()).toBe(<span class="literal">true</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="4-利用describe划分测试代码块"><a href="#4-利用describe划分测试代码块" class="headerlink" title="4. 利用describe划分测试代码块"></a>4. 利用describe划分测试代码块</h3><p>用<code>describe</code>把测试分组。也可以使用<code>describe</code>定义一个场景，把相似的操作合并。</p><p>以下的两个测试都需要先触发一次<code>add-gift</code>按钮的点击，再验证相应的测试逻辑。</p><p>下面有两个hook，<code>beforeEach</code>和<code>afterEach</code>，可以用来执行<strong>前置共同的action</strong>和<strong>结束之后的reset逻辑</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'when clicking the `add-gift` button'</span>, () =&gt; &#123;</span><br><span class="line">    beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      app.find(<span class="string">'.btn-add'</span>).simulate(<span class="string">'click'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    afterEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// reset state `gifts` to []</span></span><br><span class="line">      app.setState(&#123;</span><br><span class="line">        gifts: []</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    it(<span class="string">'add a gift to `state`'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="comment">// app.find('.btn-add').simulate('click');</span></span><br><span class="line">      expect(app.state().gifts.length).not.toBe(<span class="number">0</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  </span><br><span class="line">    it(<span class="string">'display gifts on the rendered list'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="comment">// app.find('.btn-add').simulate('click');</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> stateListLength = app.state().gifts.length;</span><br><span class="line">      <span class="keyword">const</span> listItemLength = app.find(<span class="string">'.list-item'</span>).length;</span><br><span class="line">  </span><br><span class="line">      expect(stateListLength).toEqual(listItemLength);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="5-父子组件交互测试"><a href="#5-父子组件交互测试" class="headerlink" title="5. 父子组件交互测试"></a>5. 父子组件交互测试</h3><h4 id="1）背景"><a href="#1）背景" class="headerlink" title="1）背景"></a>1）背景</h4><p>在GiftGiver内，父组件<code>&lt;App /&gt;</code>根据<code>state</code>中的<code>gifts</code>数组渲染子组件<code>&lt;Gift /&gt;</code>，而子组件有一个删除按钮，点击后可以从父组件<code>state</code>中<code>gifts</code>去掉命中当前GiftID的数据项。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// state</span></span><br><span class="line"><span class="keyword">this</span>.state.gifts = [&#123;</span><br><span class="line">  id: xxx</span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line">removeGift(id) &#123;</span><br><span class="line">  <span class="comment">// this.state.gifts.filter(gift =&gt; gift.id !== id)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// render</span></span><br><span class="line">&#123; <span class="keyword">this</span>.state.gifts.map(<span class="function"><span class="params">gift</span> =&gt;</span> (</span><br><span class="line">  &lt;Gift gift=&#123;gift&#125; removeGift=&#123;removeGift&#125; /&gt;</span><br><span class="line">))&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Gift.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// render</span></span><br><span class="line"><span class="comment">// const &#123; gift, removeGift &#125; = this.props;</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;Button onClick=&#123; gift =&gt; removeGift(gift.id) &#125;&gt;remove&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure><h4 id="2）设计思路"><a href="#2）设计思路" class="headerlink" title="2）设计思路"></a>2）设计思路</h4><ol><li>把<code>removeGift</code>挂在父组件（<code>&lt;App /&gt;</code>）上，入参giftID</li><li>把<code>gift</code>的数据和<code>removeGift</code>作为props传给子组件（<code>&lt;Gift /&gt;</code>）</li><li>在子组件（<code>&lt;Gift /&gt;</code>），有一个删除按钮，点击后调用父组件的callback函数，入参giftID</li></ol><h4 id="3）写test-case的思路"><a href="#3）写test-case的思路" class="headerlink" title="3）写test case的思路"></a>3）写test case的思路</h4><h5 id="I-父组件的测试用例-App-test-js"><a href="#I-父组件的测试用例-App-test-js" class="headerlink" title="I. 父组件的测试用例 App.test.js"></a>I. 父组件的测试用例 App.test.js</h5><p><strong>涉及的核心逻辑或交互</strong>：负责从数据源<code>this.state.gifts</code>中干掉对应数据的函数<code>removeGift</code>。</p><p><strong>测试思路</strong>：<code>removeGift</code>入参giftID后，检查会不会正确地从<code>state</code>中去掉该项数组（giftID === item.id）。</p><p><strong>实现详情：</strong></p><p>a）前置操作：模拟调用行为。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// call the `removeGift` function in App.js</span></span><br><span class="line">  app.instance().removeGift(firstGiftID);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>b）断言逻辑：确定<code>this.state.gifts</code>中没有包含对应项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'gift with ID $&#123;firstGiftID&#125; is not in the state `gift`'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; gifts &#125; = app.state();</span><br><span class="line">  <span class="keyword">const</span> targetGiftList = gifts.find(<span class="function"><span class="params">gift</span> =&gt;</span> gift.id === firstGiftID) || [];</span><br><span class="line"></span><br><span class="line">  expect(targetGiftList.length).toBe(<span class="number">0</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="II-子组件的测试用例-Gift-test-js"><a href="#II-子组件的测试用例-Gift-test-js" class="headerlink" title="II. 子组件的测试用例 Gift.test.js"></a>II. 子组件的测试用例 Gift.test.js</h5><p><strong>涉及的核心逻辑或交互</strong>：</p><ul><li>点击一个删除按钮</li><li>调用父组件传过来的callback函数，并传入id</li></ul><p><strong>测试思路</strong>：</p><ul><li>在shallow时，模拟父元素传入对应的props</li><li>模拟用户行为，点击删除按钮</li><li>检查回调函数有没有被调用，以及传入的参数对不对</li></ul><p><strong>实现详情</strong>：</p><p>1）在shallow时，模拟父元素传入对应的props。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mockRemove = jest.fn(); <span class="comment">// 在第3点说明</span></span><br><span class="line"><span class="keyword">const</span> giftID = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> props = &#123;</span><br><span class="line">  gift: &#123;</span><br><span class="line">    id: giftID</span><br><span class="line">  &#125;,</span><br><span class="line">  removeGift: mockRemove</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> gift = shallow(&lt;Gift &#123; ...props &#125; /&gt;);</span><br></pre></td></tr></table></figure><p>2）<code>beforeEach</code>里模拟删除按钮的点击</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  gift.find(<span class="string">'.btn-delete'</span>).simulate(<span class="string">'click'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3）检查回调函数有没有被调用，以及传入的参数对不对</p><p>从第1点可以看到，shallow渲染传入props时，回调函数把原本的removeGift函数替换成jest的mock。(<code>const mockRemove = jest.fn();</code>)</p><p>因为该方法提供了一个断言检测方法，我们可以通过这个方式，检查回调函数有没有被调用以及传入的参数是否符合预期，实际的测试语句如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'calls the removeGift callback'</span>, () =&gt; &#123;</span><br><span class="line">  expect(mockRemove).toHaveBeenCalledWith(giftID);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="6-coverage-testing"><a href="#6-coverage-testing" class="headerlink" title="6. coverage testing"></a>6. coverage testing</h3><p>检测实际被调用代码的覆盖程度。（冗余代码检测）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run test -- --coverage</span><br></pre></td></tr></table></figure><p><img src="http://lc-wpyqjumv.cn-n1.lcfile.com/b79550c417506fb9c9c5.png" alt=""></p><p>指定<code>--coverage</code>目标文件：，在<code>package.json</code>下，添加以下语句：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"jest"</span>: &#123;</span><br><span class="line">  <span class="string">"collectCoverageFrom"</span>: [</span><br><span class="line">    <span class="string">"src/**.js"</span>,</span><br><span class="line">    <span class="string">"!src/index.js"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><p>如果存在某些函数/逻辑没有覆盖到，可以考虑新增一个和<code>component</code>同级的<code>helpers</code>文件夹，在里面单独写那些跟组件基本功能无关的逻辑，如用于生成ID的ID生成函数，可以单拎出来放进<code>helpers</code>及进行相应的单元测试。</p><h2 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h2><h3 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a>Preparation</h3><ol><li>node, v8.x</li><li>npm, v5.x</li><li>create-react-app</li></ol><h3 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h3><p>I. <code>create-react-app yourProjectName</code></p><p>II. install dependencies</p><ul><li>dependencies: react-dom &amp; react </li><li>devDependencies: enzyme &amp; jest-cli</li></ul><p>III. enzyme-adapter-react-16</p><p>In order to use the most current version of React &gt; 16, we now need to install “enzyme adapters” to provide full compatibility with React.</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i enzyme-adapter-react<span class="number">-16</span> --<span class="built_in">save</span>-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure><p>Next, add a src/tempPolyfills.js file to create the global request animation frame function that React now depends on.</p><p>src/tempPolyfills.js should contain the following contents:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> requestAnimationFrame = global.requestAnimationFrame = <span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">  setTimeout(callback, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>export default requestAnimationFrame;<br>Finally, add a src/setupTests.js file to configure the enzmye adapter for our tests. The disableLifecyleMethods portion is needed to allow us to modify props through different tests.</p><p>src/setupTests.js should contain the following contents:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requestAnimationFrame <span class="keyword">from</span> <span class="string">'./tempPolyfills'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; configure &#125; <span class="keyword">from</span> <span class="string">'enzyme'</span>;</span><br><span class="line"><span class="keyword">import</span> Adapter <span class="keyword">from</span> <span class="string">'enzyme-adapter-react-16'</span>;</span><br><span class="line"></span><br><span class="line">configure(&#123; <span class="attr">adapter</span>: <span class="keyword">new</span> Adapter(), <span class="attr">disableLifecycleMethods</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;如果想跳过前文，可以直接定位到&lt;a href=&quot;/blog/archives/test-driven-dev/#我的实战&quot;&gt;实战篇&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;What-is-Test-Driven-Development&quot;&gt;&lt;a href=&quot;#What-is-Test-Driven-Development&quot; class=&quot;headerlink&quot; title=&quot;What is Test Driven Development?&quot;&gt;&lt;/a&gt;What is Test Driven Development?&lt;/h2&gt;&lt;p&gt;Coding of features and tests go hand in hand.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Write a unit test.&lt;/li&gt;
&lt;li&gt;Run the test. See it fail.&lt;/li&gt;
&lt;li&gt;Write the feature code to pass the test.&lt;/li&gt;
&lt;li&gt;Refactor the code.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;Why-TDD&quot;&gt;&lt;a href=&quot;#Why-TDD&quot; class=&quot;headerlink&quot; title=&quot;Why TDD?&quot;&gt;&lt;/a&gt;Why TDD?&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;It reduces errors and defects in the long run.&lt;/li&gt;
&lt;li&gt;It leads to higher quality code.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;What-is-Behavior-Driven-Development&quot;&gt;&lt;a href=&quot;#What-is-Behavior-Driven-Development&quot; class=&quot;headerlink&quot; title=&quot;What is Behavior Driven Development?&quot;&gt;&lt;/a&gt;What is Behavior Driven Development?&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;A variation of TDD that tests for user scenarios.&lt;/li&gt;
&lt;li&gt;Given, when, then… [ pattern ]&lt;/li&gt;
&lt;li&gt;Given notes, when deleting, then remove a note.&lt;/li&gt;
&lt;li&gt;BDD consists of scenarios/specifications.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="front-end" scheme="http://wuyuying.com/tags/front-end/"/>
    
      <category term="testing" scheme="http://wuyuying.com/tags/testing/"/>
    
  </entry>
  
  <entry>
    <title>开箱即用，Hexo博客的github+server自动部署</title>
    <link href="http://wuyuying.com/archives/hexo-travis/"/>
    <id>http://wuyuying.com/archives/hexo-travis/</id>
    <published>2018-05-26T06:35:18.000Z</published>
    <updated>2018-06-02T12:20:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://lc-wpyqjumv.cn-n1.lcfile.com/9fb19e9b112f127c1adc.jpg" alt="&quot;Travis CI&quot;"></p><p>用了一段时间HEXO搭建个人的博客，但每次发布文章，都需要打开电脑<code>hexo g</code>编译之后，再提交到服务器上，确实挺麻烦的，和小伙伴聊完他的日志发布方式之后，痛定思痛，<strong>快捷发布日志</strong>这个问题需要解决一下了！Travis CLI搞起来！</p><h2 id="闲聊日志的快捷发布"><a href="#闲聊日志的快捷发布" class="headerlink" title="闲聊日志的快捷发布"></a>闲聊日志的快捷发布</h2><p>前几天，跟小伙伴Pipe一起参加个分享会，看到他做了笔记，结束后我说你发给我呀，他说直接看我博客（<a href="https://zhoukekestar.github.io/notes/2018/05/25/better-me.html" target="_blank" rel="noopener">《工作思维方式简记》</a>）呀！我的天，写完瞬间就发到站点去了！Pipe非常高产，去看看他的<a href="https://zhoukekestar.github.io/notes" target="_blank" rel="noopener">博客</a>，用“高产似母猪”来描述都不足为过，5月份还没有过完，发布了7篇日志。</p><p>我问他，怎么做到那么高产？Pipe说，第一点是他的日志是碎片化的偏记录的，不一定要憋出大文章才发，然后就是博客系统要方便，随写随发。</p><p>反观我的博客，更新频率真的很低，一方面是喜欢憋专题文章，拖着拖着，然后就没有然后了。另一方面也是发布确实麻烦，电脑编辑好markdown，还要执行各种命令，最后push到github和自己的服务器，文章才能被大家看到，一开始觉得还好蛮geek的，但后来确实由于这些门槛，有打击到那些随时来的写作思绪。</p><p>By the way，Pipe用的是<code>jekyll</code>，跟github的持续集成是天生的，而HEXO没有这样的优势。从Hexo换到Jekyll吧，也不是很麻烦，但是我在Hexo生态做了一些东西，还是有点不舍哈。</p><ul><li><a href="https://github.com/YuyingWu/blog" target="_blank" rel="noopener">github blog</a>：我的博客分支</li><li><a href="https://github.com/YuyingWu/hexo-generator-index-plus/blob/master/README.md" target="_blank" rel="noopener">hexo-generator-index-plus</a>：hexo小插件，首页排序生成器，和原生的index-generator比较显著的区别是加了置顶功能，可以在front-matter添加<code>top</code>属性即可。</li><li><a href="https://github.com/YuyingWu/hexo-theme-fresh" target="_blank" rel="noopener">hexo-theme-fresh</a>：hexo博客主题，绿色小清新，Medium风格。</li></ul><p><img src="//lc-wpyqjumv.cn-n1.lcfile.com/3061dbf0241049f3b646.gif" alt="&quot;hexo-theme-fresh效果截屏&quot;"></p><h2 id="HEXO的开发分支与生产分支"><a href="#HEXO的开发分支与生产分支" class="headerlink" title="HEXO的开发分支与生产分支"></a>HEXO的开发分支与生产分支</h2><p>仓库分成2个分支，主开发开支dev，以及生产环境的gh-pages分支。<br>查看博客可以通过访问<a href="https://yuyingwu.github.io/blog/" target="_blank" rel="noopener">github pages</a>，又或者直接访问我的域名 <a href="http://www.wuyuying.com/blog/archives/hexo-travis/" target="_blank" rel="noopener">wuyuying.com/blog</a>。</p><h3 id="开发分支-dev"><a href="#开发分支-dev" class="headerlink" title="开发分支 dev"></a>开发分支 dev</h3><p>在我的博客里，开发分支是<code>dev</code>，目录结构就是一开始<code>hexo init</code>后的结构。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> scaffolds /<span class="regexp">/ 页面的模板，包括草稿（draft.md）、页面（page.md）、文章（post.md）以及其他自定义模板</span></span></span><br><span class="line"><span class="ruby">- source /<span class="regexp">/ 放页面和文章markdown文档</span></span></span><br><span class="line"><span class="ruby">- themes /<span class="regexp">/ 博客主题</span></span></span><br><span class="line"><span class="ruby">- _config.yml /<span class="regexp">/ 配置文件</span></span></span><br><span class="line"><span class="ruby">- package.json</span></span><br><span class="line"><span class="ruby">- .travis.yml /<span class="regexp">/ 持续集成服务travis的文件</span></span></span><br></pre></td></tr></table></figure><p>本地开发流程一般是这样。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> hexo server, 启动本地服务器，预览我的文章</span><br><span class="line">hexo s </span><br><span class="line"></span><br><span class="line"><span class="string">//</span> hexo generate，编译文章，把 `source` 里面的页面和文章编译成 `public` 里面的html文件</span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line"><span class="string">//</span> hexo <span class="keyword">deploy</span>，如果 _config.yml 有配置<span class="keyword">deploy</span>的内容，执行该命令是会执行相应的部署逻辑</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>HEXO的详细科普和指令在这里就不写了哈，官方文档里都有 <a href="https://hexo.io/docs/" target="_blank" rel="noopener">&gt;&gt; 传送门</a>。</p><h3 id="生产分支-gh-pages"><a href="#生产分支-gh-pages" class="headerlink" title="生产分支 gh-pages"></a>生产分支 gh-pages</h3><p>在<code>dev</code>分支里，执行了<code>hexo g</code>编译之后，编译后的静态文件会存在<code>public</code>文件夹里，而我们就把里面的内容挪到最终的生产环境分支<code>gh-pages</code>里，也就是最终我们看到的静态博客。</p><p>当我们在github里把github-pages服务打开，并渲染<code>gh-pages</code>分支，我们就能访问自己的博客了（<a href="https://yuyingwu.github.io/blog/" target="_blank" rel="noopener">https://yuyingwu.github.io/blog/</a>）。</p><p><img src="//lc-wpyqjumv.cn-n1.lcfile.com/d3ebf243ea2b0dfd9dd1.png" alt="&quot;看看我的博客&quot;"></p><h2 id="Travis-CI"><a href="#Travis-CI" class="headerlink" title="Travis CI"></a>Travis CI</h2><p>在大致了解HEXO的开发流程之后，我们可以开始考虑，如果要实现快捷发布，是要做什么？<br><code>User Story</code>：<strong>希望可以在github上写一篇文章，提交之后，可以直接在我的线上博客看到</strong>。</p><p>在这里，我们用到了提供持续集成（CI, Continuous Integration）服务的<a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a>，但其实用到的不是它提供的CI服务，而更多的是通过监听分支提交的动态，在集成成功后去执行我们自定义的部署逻辑。</p><blockquote><p>持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。</p></blockquote><p>噢，还有些事前准备：</p><ul><li>先在<code>dev</code>分支里，创建<code>.travis.yml</code></li><li>在<a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CLI</a>平台上打开这个分支的CI开关</li></ul><h3 id="1-编译并同步到gh-pages"><a href="#1-编译并同步到gh-pages" class="headerlink" title="1. 编译并同步到gh-pages"></a>1. 编译并同步到gh-pages</h3><p>那直接上我的CI配置代码吧。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span> <span class="string">stable</span></span><br><span class="line"></span><br><span class="line"><span class="attr">addons:</span> <span class="comment"># Travis CI建议加的，自动更新api</span></span><br><span class="line"><span class="attr">  apt:</span></span><br><span class="line"><span class="attr">    update:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line"><span class="attr">  directories:</span> </span><br><span class="line"><span class="bullet">  -</span> <span class="string">node_modules</span> <span class="comment"># 缓存 node_modules</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="comment"># 初次安装，在CI环境中，执行安装npm依赖</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># before_script: </span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo</span> <span class="string">g</span> <span class="comment"># 执行 hexo generate，把文章编译到public中</span></span><br><span class="line"></span><br><span class="line"><span class="attr">after_success:</span> <span class="comment"># 执行script成功后，进入到public，把里面的代码提交到博客的gh-pages分支</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">cd</span> <span class="string">./public</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">init</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.name</span> <span class="string">"Yuying Wu"</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.email</span> <span class="string">"wuyuying1128@gmail.com"</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">add</span> <span class="string">.</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">commit</span> <span class="bullet">-m</span> <span class="string">"Update site"</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">push</span> <span class="bullet">--force</span> <span class="bullet">--quiet</span> <span class="string">"https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;"</span> <span class="attr">master:gh-pages</span></span><br><span class="line"></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">dev</span> <span class="comment"># CI 只针对分支 dev</span></span><br><span class="line"></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line"><span class="attr">  global:</span> <span class="comment"># 全局变量，上面的提交到github的命令有用到</span></span><br><span class="line"><span class="attr">  - GH_REF:</span> <span class="string">github.com/YuyingWu/blog.git</span></span><br><span class="line"><span class="attr">  - secure:</span> </span><br><span class="line"><span class="comment"># secure是自动生成的，执行`travis encrypt 'GH_TOKEN=$&#123;your_github_personal_access_token&#125;' --add`</span></span><br></pre></td></tr></table></figure><p>相信代码和注释写得很清楚了，有个地方需要进一步解释的，github提交那part，涉及github access token的生成和加密。</p><ol><li>生成github的<a href="https://github.com/settings/tokens" target="_blank" rel="noopener">Personal Access Tokens</a>（打开分支提交的权限）</li><li>安装Travis CLI <code>gem install travis</code>（如果登录遇到环境问题，可以看看下面参考文章里面的解决方案）</li><li>进入到本地<code>dev</code>目录下（带有<code>.travis.yml</code>），执行<code>travis login</code>登录，再执行<code>travis encrypt &#39;GH_TOKEN=${your_github_personal_access_token}&#39; --add</code>加密你的personal access token（也就是后来<code>.travis.yml</code>的<code>env.global.secure</code>的值）</li></ol><p>把<code>.travis.yml</code>提交之后，看看Travis CLI上，开始持续集成了哈。</p><p><img src="//lc-wpyqjumv.cn-n1.lcfile.com/cbf00765c8f94a151965.png" alt="&quot;开始准备&quot;"><br><img src="//lc-wpyqjumv.cn-n1.lcfile.com/b82303e0f85deb2088ce.png" alt="&quot;after_success把代码部署到gh-pages&quot;"></p><p>大功告成，集成之后，在github pages的页面上也能看到文章的更新。</p><h3 id="2-CI到我的服务器"><a href="#2-CI到我的服务器" class="headerlink" title="2. CI到我的服务器"></a>2. CI到我的服务器</h3><p>我的服务器是DO家（Digital Ocean）的，那一开始服务器初始化的过程，大家可以参考各个server商提供的setup文档哈，总的来说，在本地有个服务器信任的<code>id_rsa</code>的ssh文件，我们是可以通过<code>ssh user@ip_address</code>登录到服务器的。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个命令会自动把 id_rsa 加密传送到 .git 指定的仓库对应的 travis 中去（在我本地这个文件叫qq_rsa，不是默认的id_rsa）</span></span><br><span class="line">travis <span class="built_in">encrypt</span>-<span class="built_in">file</span> ~/.ssh/id_rsa <span class="comment">--add</span></span><br></pre></td></tr></table></figure><p>执行这个命令后，<code>.travis.yml</code>多了一行代码：（注意把其中的转义符<code>\</code>干掉哈），也会在分支目录下生成一个<code>id_rsa.enc</code>的加密文件，记得把这个文件也提交上去哟。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before_install:</span><br><span class="line">-<span class="ruby"> openssl aes-<span class="number">256</span>-cbc -K $encrypted_3cf6c1fd150f_key -iv $encrypted_3cf6c1fd150f_iv</span></span><br><span class="line"><span class="ruby">  -<span class="keyword">in</span> qq_rsa.enc -out ~<span class="regexp">/.ssh/id</span>_rsa -d</span></span><br></pre></td></tr></table></figure><p>然后为了保证在Travis里面能正常执行，我们处理下运行环境的rsa文件权限和输出提示信息，before_install如下。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">before_install:</span><br><span class="line">-<span class="ruby"> openssl aes-<span class="number">256</span>-cbc -K $encrypted_3cf6c1fd150f_key -iv $encrypted_3cf6c1fd150f_iv</span></span><br><span class="line"><span class="ruby">  -<span class="keyword">in</span> qq_rsa.enc -out ~<span class="regexp">/.ssh/id</span>_rsa -d</span></span><br><span class="line"><span class="ruby">- chmod <span class="number">600</span> ~<span class="regexp">/.ssh/id</span>_rsa</span></span><br><span class="line"><span class="ruby">- echo -e <span class="string">"Host 主机IP地址\n\tStrictHostKeyChecking no\n"</span> <span class="meta">&gt;&gt; </span>~<span class="regexp">/.ssh/config</span></span></span><br></pre></td></tr></table></figure><p>最后，在<code>after_success</code>里添加<strong>拷贝目标文件到服务器目标目录</strong>的操作，就大功告成了！</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">after_success</span><br><span class="line"><span class="comment"># other actions</span></span><br><span class="line">- scp -o stricthostkeychecking=no -r ./* root<span class="variable">@138</span>.<span class="number">68.161</span>.<span class="number">48</span><span class="symbol">:/home/wyyNode/public/blog/</span></span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://juejin.im/post/596e39916fb9a06baf2ed273" target="_blank" rel="noopener">如何快速搭建一个有域名且持续集成的hexo博客(2.0版)</a> - <a href="https://github.com/zytx121" target="_blank" rel="noopener">Eva-Yue</a></li><li><a href="http://lotabout.me/2016/Hexo-Auto-Deploy-to-Github/" target="_blank" rel="noopener">Hexo 自动部署到 Github</a> - <a href="http://lotabout.me/" target="_blank" rel="noopener">三点水</a></li><li><a href="http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html" target="_blank" rel="noopener">持续集成服务 Travis CI 教程</a> - 阮一峰</li><li><a href="https://github.com/travis-ci/travis.rb/issues/190" target="_blank" rel="noopener">“no implicit conversion of nil into String” when logging in</a> - 在执行<code>travis login</code>遇到的问题的解决方案</li><li><a href="https://iamstarkov.com/deploy-gh-pages-from-travis/" target="_blank" rel="noopener">Deploy to GitHub pages from Travis CI</a></li><li><a href="https://segmentfault.com/a/1190000009093621" target="_blank" rel="noopener">使用 Travis 将 GitHub 文件上传传至服务器</a> - <a href="https://github.com/Godi13" target="_blank" rel="noopener">Godi13</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://lc-wpyqjumv.cn-n1.lcfile.com/9fb19e9b112f127c1adc.jpg&quot; alt=&quot;&amp;quot;Travis CI&amp;quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;用了一段时间HEXO搭建个人的博客，但每次发布文章，都需要
      
    
    </summary>
    
    
      <category term="blog" scheme="http://wuyuying.com/tags/blog/"/>
    
      <category term="travisCI" scheme="http://wuyuying.com/tags/travisCI/"/>
    
      <category term="CI" scheme="http://wuyuying.com/tags/CI/"/>
    
      <category term="hexo" scheme="http://wuyuying.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>[译] React性能优化-虚拟Dom原理浅析</title>
    <link href="http://wuyuying.com/archives/optimizing-react-virtual-dom-explained/"/>
    <id>http://wuyuying.com/archives/optimizing-react-virtual-dom-explained/</id>
    <published>2018-05-13T11:15:19.000Z</published>
    <updated>2018-05-25T10:34:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文译自<a href="https://evilmartians.com/chronicles/optimizing-react-virtual-dom-explained" target="_blank" rel="noopener">《Optimizing React: Virtual DOM explained》</a>，作者是<a href="https://github.com/iAdramelk" target="_blank" rel="noopener">Alexey Ivanov</a>和<a href="https://github.com/progapandist" target="_blank" rel="noopener">Andy Barnov</a>，来自<a href="https://evilmartians.com/chronicles" target="_blank" rel="noopener">Evil Martians’ team</a>团队。</p><p>译者说：通过一些实际场景和demo，给大家描述React的Virtual Dom Diff一些核心的原理和规则，以及基于这些我们可以做些什么提高应用的性能，很棒的文章。</p><hr><p><strong>通过学习React的Virtual DOM的知识，去加速你们的应用吧。对框架内部实现的介绍，比较全面且适合初学者，我们会让JSX更加简单易懂，给你展示React是如何判断要不要重新render，解释如何找到应用的性能瓶颈，以及给大家一些小贴士，如何避免常见错误。</strong></p><p>React在前端圈内保持领先的原因之一，因为它的学习曲线非常平易近人：把你的模板包在<code>JSX</code>，了解一下<code>props</code>和<code>state</code>的概念之后，你就可以轻松写出React代码了。</p><p>如果你已经熟悉React的工作方式，可以直接跳至“优化我的代码”篇。</p><p>但要真正掌握React，你需要像React一样思考（think in React）。本文也会试图在这个方面帮助你。</p><p>下面看看我们其中一个项目中的React table：</p><p><img src="http://sinacloud.net/woodysblog/img/ebay_table.png" alt="&quot;eBay上的一个巨大的React表格  用于业务。&quot;"></p><p>这个表里有数百个动态（表格内容变化）和可过滤的选项，理解这个框架更精细的点，对于保证顺畅的用户体验至关重要。</p><hr><p><strong>当事情出错时，你一定能感觉到。输入字段变得迟缓，复选框需要检查一秒钟，弹窗一个世纪后才出现，等等。</strong></p><hr><p>为了能够解决这些问题，我们需要完成一个React组件的整个生命旅程，从一开始的声明定义到在页面上渲染（再然后可能会更新）。系好安全带，我们要发车了！</p><h2 id="JSX的背后"><a href="#JSX的背后" class="headerlink" title="JSX的背后"></a>JSX的背后</h2><p>这个过程一般在前端会称为“转译”，但其实“汇编”将是一个更精确的术语。</p><p>React开发人员敦促你在编写组件时使用一种称为JSX的语法，混合了HTML和JavaScript。但浏览器对JSX及其语法毫无头绪，浏览器只能理解纯碎的JavaScript，所以JSX必须转换成JavaScript。这里是一个div的JSX代码，它有一个class name和一些内容：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=<span class="string">'cn'</span>&gt;</span><br><span class="line">  Content!</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><p>以上的代码，被转换成“正经”的JavaScript代码，其实是一个带有一些参数的函数调用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">  <span class="string">'div'</span>,</span><br><span class="line">  &#123; <span class="attr">className</span>: <span class="string">'cn'</span> &#125;,</span><br><span class="line">  <span class="string">'Content!'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>让我们仔细看看这些参数。</p><ul><li>第一个是元素的<code>type</code>。对于HTML标签，它将是一个带有<code>标签名称</code>的字符串。</li><li>第二个参数是一个包含所有元素属性（<code>attributes</code>）的对象。如果没有，它也可以是空的对象。</li><li>剩下的参数都可以认为是元素的子元素（<code>children</code>）。元素中的文本也算作一个child，是个字符串’Content！’ 作为函数调用的第三个参数放置。</li></ul><p>你应该可以想象，当我们有更多的children时会发生什么：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=<span class="string">'cn'</span>&gt;</span><br><span class="line">  Content <span class="number">1</span>!</span><br><span class="line">  &lt;br /&gt;</span><br><span class="line">  Content <span class="number">2</span>!</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">  <span class="string">'div'</span>,</span><br><span class="line">  &#123; <span class="attr">className</span>: <span class="string">'cn'</span> &#125;,</span><br><span class="line">  <span class="string">'Content 1!'</span>,              <span class="comment">// 1st child</span></span><br><span class="line">  React.createElement(<span class="string">'br'</span>), <span class="comment">// 2nd child</span></span><br><span class="line">  <span class="string">'Content 2!'</span>               <span class="comment">// 3rd child</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们的函数现在有五个参数：</p><ul><li>一个元素的类型</li><li>一个属性对象</li><li>三个子元素。</li></ul><p>因为其中一个child是一个React已知的HTML标签（<code>&lt;br/&gt;</code>），所以它也会被描述为一个函数调用（<code>React.createElement(&#39;br&#39;)</code>）。</p><p>到目前为止，我们已经涵盖了两种类型的children：</p><ul><li>简单的<code>String</code></li><li>另一种会调用<code>React.createElement</code>。</li></ul><p>然而，还有其他值可以作为参数：</p><ul><li>基本类型 <code>false, null, undefined, true</code></li><li>数组</li><li>React Components</li></ul><p>可以使用数组是因为可以将children分组并作为一个参数传递：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">  <span class="string">'div'</span>,</span><br><span class="line">  &#123; <span class="attr">className</span>: <span class="string">'cn'</span> &#125;,</span><br><span class="line">  [<span class="string">'Content 1!'</span>, React.createElement(<span class="string">'br'</span>), <span class="string">'Content 2!'</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>当然了，React的厉害之处，不仅仅因为我们可以把HTML标签直接放在JSX中使用，而是我们可以自定义自己的组件，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Table</span>(<span class="params">&#123; rows &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;table&gt;</span><br><span class="line">      &#123;rows.map(<span class="function"><span class="params">row</span> =&gt;</span> (</span><br><span class="line">        &lt;tr key=&#123;row.id&#125;&gt;</span><br><span class="line">          &lt;td&gt;&#123;row.title&#125;&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>tr&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;<span class="regexp">/table&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>组件可以让我们把模板分解为多个可重用的块。在上面的“函数式”（functional）组件的例子里，我们接收一个包含表格行数据的对象数组，最后返回一个调用<code>React.createElement</code>方法的<code>&lt;table&gt;</code>元素，<code>rows</code>则作为children传进table。</p><p>无论什么时候，我们这样去声明一个组件时：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Table rows=&#123;rows&#125; /&gt;</span><br></pre></td></tr></table></figure><p>从浏览器的角度来看，我们是这么写的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(Table, &#123; <span class="attr">rows</span>: rows &#125;);</span><br></pre></td></tr></table></figure><p>注意，这次我们的第一个参数不是<code>String</code>描述的<code>HTML标签</code>，而是一个引用，指向我们编写组件时编写的函数。组件的<code>attributes</code>现在是接收的<code>props</code>参数了。</p><h2 id="把组件（components）组合成页面（a-page）"><a href="#把组件（components）组合成页面（a-page）" class="headerlink" title="把组件（components）组合成页面（a page）"></a>把组件（components）组合成页面（a page）</h2><p>所以，我们已经将所有JSX组件转换为纯JavaScript，现在我们有一大堆函数调用，它的参数会被其他函数调用的，或者还有更多的其他函数调用这些参数……这些带参数的函数调用，是怎么转化成组成这个页面的实体DOM的呢？</p><p>为此，我们有一个<code>ReactDOM</code>库及其它的<code>render</code>方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Table</span>(<span class="params">&#123; rows &#125;</span>) </span>&#123; <span class="comment">/* ... */</span> &#125; <span class="comment">// defining a component</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// rendering a component</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  React.createElement(Table, &#123; <span class="attr">rows</span>: rows &#125;), <span class="comment">// "creating" a component</span></span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'#root'</span>) <span class="comment">// inserting it on a page</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>当<code>ReactDOM.render</code>被调用时，<code>React.createElement</code>最终也会被调用，返回以下对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// There are more fields, but these are most important to us</span></span><br><span class="line">&#123;</span><br><span class="line">  type: Table,</span><br><span class="line">  props: &#123;</span><br><span class="line">    rows: rows</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>这些对象，在React的角度上，构成了虚拟DOM。</strong></p><hr><p>他们将在所有进一步的渲染中相互比较，并最终转化为  真正的<code>DOM</code>（virtual VS real, 虚拟DOM VS 真实DOM）。</p><p>下面是另一个例子：这次div有一个class属性和几个children：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">  <span class="string">'div'</span>,</span><br><span class="line">  &#123; <span class="attr">className</span>: <span class="string">'cn'</span> &#125;,</span><br><span class="line">  <span class="string">'Content 1!'</span>,</span><br><span class="line">  <span class="string">'Content 2!'</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>变成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: <span class="string">'div'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    className: <span class="string">'cn'</span>,</span><br><span class="line">    children: [</span><br><span class="line">      <span class="string">'Content 1!'</span>,</span><br><span class="line">      <span class="string">'Content 2!'</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，那些除了<code>type</code>和<code>attribute</code>以外的属性，原本是单独传进来的，转换之后，会作为在<code>props.children</code>以一个数组的形式打包存在。也就是说，无论children是作为数组还是参数列表传递都没关系 —— 在生成的虚拟DOM对象的时候，它们最后都会被打包在一起的。</p><p>进一步说，我们可以直接在组件中把children作为一项属性传进去，结果还是一样的：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=<span class="string">'cn'</span> children=&#123;[<span class="string">'Content 1!'</span>, <span class="string">'Content 2!'</span>]&#125; /&gt;</span><br></pre></td></tr></table></figure><p>在构建虚拟DOM对象完成之后，<code>ReactDOM.render</code>将会按下面的原则，尝试将其转换为浏览器可以识别和展示的DOM节点：</p><ul><li><p>如果<code>type</code>包含一个带有<code>String</code>类型的标签名称（<code>tag name</code>）—— 创建一个标签，附带上<code>props</code>下所有<code>attributes</code>。</p></li><li><p>如果<code>type</code>是一个函数（<code>function</code>）或者类（<code>class</code>），调用它，并对结果递归地重复这个过程。</p></li><li><p>如果<code>props</code>下有<code>children</code>属性 —— 在父节点下，针对每个child重复以上过程。</p></li></ul><p>最后，得到以下HTML（对于我们的表格示例）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="重新构建DOM（Rebuilding-the-DOM）"><a href="#重新构建DOM（Rebuilding-the-DOM）" class="headerlink" title="重新构建DOM（Rebuilding the DOM）"></a>重新构建DOM（Rebuilding the DOM）</h2><p>在实际应用场景，<code>render</code>通常在根节点调用一次，后续的更新会有<code>state</code>来控制和触发调用。</p><p>请注意，标题中的“重新”！当我们想更新一个页面而不是全部替换时，React中的魔法就开始了。我们有一些实现它的方式。我们先从最简单的开始 —— 在同一个node节点再次执行<code>ReactDOM.render</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Second call</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  React.createElement(Table, &#123; <span class="attr">rows</span>: rows &#125;),</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'#root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这一次，上面的代码的表现，跟我们已经看到的有所不同。React将从头开始创建所有DOM节点并将其放在页面上，而不是从头开始创建所有DOM节点，React将启动其<code>diff</code>算法，来确定节点树的哪些部分必须更新，哪些可以保持不变。</p><p>那么，它是怎样工作的呢？其实只有少数几个简单的场景，理解它们将对我们的优化帮助很大。请记住，现在我们在看的，是在<code>React Virtual DOM</code>里面用来代表节点的<code>对象</code>。</p><h3 id="场景1：type是一个字符串，type在通话中保持不变，props也没有改变。"><a href="#场景1：type是一个字符串，type在通话中保持不变，props也没有改变。" class="headerlink" title="场景1：type是一个字符串，type在通话中保持不变，props也没有改变。"></a>场景1：<code>type</code>是一个字符串，<code>type</code>在通话中保持不变，<code>props</code>也没有改变。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// before update</span></span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'div'</span>, <span class="attr">props</span>: &#123; <span class="attr">className</span>: <span class="string">'cn'</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// after update</span></span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'div'</span>, <span class="attr">props</span>: &#123; <span class="attr">className</span>: <span class="string">'cn'</span> &#125; &#125;</span><br></pre></td></tr></table></figure><p>这是最简单的情况：DOM保持不变。</p><h3 id="场景2：type仍然是相同的字符串，props是不同的。"><a href="#场景2：type仍然是相同的字符串，props是不同的。" class="headerlink" title="场景2：type仍然是相同的字符串，props是不同的。"></a>场景2：<code>type</code>仍然是相同的字符串，<code>props</code>是不同的。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// before update:</span></span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'div'</span>, <span class="attr">props</span>: &#123; <span class="attr">className</span>: <span class="string">'cn'</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// after update:</span></span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'div'</span>, <span class="attr">props</span>: &#123; <span class="attr">className</span>: <span class="string">'cnn'</span> &#125; &#125;</span><br></pre></td></tr></table></figure><p><code>type</code>仍然代表HTML元素，React知道如何通过标准DOM API调用来更改元素的属性，而无需从DOM树中删除一个节点。</p><h3 id="场景3：type已更改为不同的String或从String组件。"><a href="#场景3：type已更改为不同的String或从String组件。" class="headerlink" title="场景3：type已更改为不同的String或从String组件。"></a>场景3：<code>type</code>已更改为不同的<code>String</code>或从<code>String</code>组件。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// before update:</span></span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'div'</span>, <span class="attr">props</span>: &#123; <span class="attr">className</span>: <span class="string">'cn'</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// after update:</span></span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'span'</span>, <span class="attr">props</span>: &#123; <span class="attr">className</span>: <span class="string">'cn'</span> &#125; &#125;</span><br></pre></td></tr></table></figure><p>React看到的<code>type</code>是不同的，它甚至不会尝试更新我们的节点：old元素将和它的所有子节点一起被删除（unmounted卸载）。因此，将元素替换为完全不同于DOM树的东西代价会非常昂贵。幸运的是，这在现实世界中很少发生。</p><p>划重点，记住React使用<code>===</code>（triple equals）来比较<code>type</code>的值，所以这两个值需要是相同类或相同函数的相同实例。</p><p>下一个场景更加有趣，通常我们会这么使用React。</p><h3 id="场景4：type是一个component。"><a href="#场景4：type是一个component。" class="headerlink" title="场景4：type是一个component。"></a>场景4：<code>type</code>是一个<code>component</code>。</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// before <span class="keyword">update</span>:</span><br><span class="line">&#123; <span class="keyword">type</span>: <span class="keyword">Table</span>, props: &#123; <span class="keyword">rows</span>: <span class="keyword">rows</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">// <span class="keyword">after</span> <span class="keyword">update</span>:</span><br><span class="line">&#123; <span class="keyword">type</span>: <span class="keyword">Table</span>, props: &#123; <span class="keyword">rows</span>: <span class="keyword">rows</span> &#125; &#125;</span><br></pre></td></tr></table></figure><hr><p><strong>你可能会说，“咦，但没有任何变化啊！”，但是你错了。</strong></p><hr><p>如果<code>type</code>是对函数或类的引用（即常规的React组件），并且我们启动了tree diff的过程，则React会持续地去检查组件的内部逻辑，以确保<code>render</code>返回的值不会改变（类似对副作用的预防措施）。对树中的每个组件进行遍历和扫描 —— 是的，在复杂的渲染场景下，成本可能会非常昂贵！</p><p>值得注意的是，一个<code>component</code>的<code>render</code>（只有类组件在声明时有这个函数）跟<code>ReactDom.render</code>不是同一个函数。</p><h2 id="关注子组件（children）的情况"><a href="#关注子组件（children）的情况" class="headerlink" title="关注子组件（children）的情况"></a>关注子组件（children）的情况</h2><p>除了上述四种常见场景之外，当一个元素有多个子元素时，我们还需要考虑React的行为。现在假设我们有这么一个元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">props: &#123;</span><br><span class="line">  children: [</span><br><span class="line">      &#123; <span class="attr">type</span>: <span class="string">'div'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">type</span>: <span class="string">'span'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">type</span>: <span class="string">'br'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>我们想要交换一下这些children的顺序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">props: &#123;</span><br><span class="line">  children: [</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">'span'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">'div'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">'br'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>之后会发生什么呢？</p><p>当<code>diffing</code>的时候，如果React在检查<code>props.children</code>下的数组时，按顺序去对比数组内元素的话：index 0将与index 0进行比较，index 1和index 1，等等。对于每一次对比，React会使用之前提过的diff规则。在我们的例子里，它认为<code>div</code>成为一个<code>span</code>，那么就会运用到情景3。这样不是很有效率的：想象一下，我们已经从1000行中删除了第一行。React将不得不“更新”剩余的999个子项，因为按index去对比的话，内容从第一条开始就不相同了。</p><p>幸运的是，React有一个<code>内置的方法（built-in）</code>来解决这个问题。如果一个元素有一个<code>key</code>属性，那么元素将按<code>key</code>而不是<code>index</code>来比较。只要<code>key</code>是唯一的，React就会移动元素，而不是将它们从DOM树中移除然后再将它们放回（这个过程在React里叫mounting和unmounting）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">props: &#123;</span><br><span class="line">  children: [ <span class="comment">// Now React will look on key, not index</span></span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">'div'</span>, <span class="attr">key</span>: <span class="string">'div'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">'span'</span>, <span class="attr">key</span>: <span class="string">'span'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">'br'</span>, <span class="attr">key</span>: <span class="string">'bt'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h2 id="当state发生了改变"><a href="#当state发生了改变" class="headerlink" title="当state发生了改变"></a>当state发生了改变</h2><p>到目前为止，我们只聊了下React哲学里面的<code>props</code>部分，却忽视了另外很重要的一部分<code>state</code>。下面是一个简单的<code>stateful</code>组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">counter</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  increment = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    counter: <span class="keyword">this</span>.state.counter + <span class="number">1</span>,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  render = <span class="function"><span class="params">()</span> =&gt;</span> (<span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.increment&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;'Counter: ' + this.state.counter&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>state</code>对象里，我们有一个key<code>counter</code>。点击按钮时，这个值会增加，然后按钮的文本也会发生相应的改变。但是，当我们这样做时，DOM中发生了什么？哪部分将被重新计算和更新？</p><p>调用<code>this.setState</code>会导致<code>re-render</code>（重新渲染），但不会影响到整个页面，而只会影响组件本身及其children组件。父母和兄弟姐妹都不会受到影响。当我们有一个层级很深的组件链时，这会让状态更新变得非常方便，因为我们只需要重绘(<code>redraw</code>)它的一部分。</p><h2 id="把问题说清楚"><a href="#把问题说清楚" class="headerlink" title="把问题说清楚"></a>把问题说清楚</h2><p>我们准备了一个<a href="https://iadramelk.github.io/optimizing-react-demo/dist/before.html" target="_blank" rel="noopener">小demo</a>，以便你可以在看到在“野蛮生长”的React编码方式下最常见的问题，后续我也告诉大家怎么去解决这些问题。你可以在<a href="https://github.com/iAdramelk/optimizing-react-demo" target="_blank" rel="noopener">这里看看它的源代码</a>。你还需要<a href="https://github.com/facebook/react-devtools" target="_blank" rel="noopener">React Developer Tools</a>，请确保浏览器安装了它们。</p><p>我们首先要看看的是，哪些元素以及什么时候导致Virtual DOM的更新。在浏览器的开发工具中，打开React面板并选择“Highlight Updates”复选框：</p><p><img src="http://sinacloud.net/woodysblog/img/react_dev_tools.png" alt="&quot;在Chrome中使用“突出显示更新”复选框选中DevTools&quot;"></p><p>现在尝试在表格中添加一行。如你所见，页面上的每个元素周围都会显示一个边框。这意味着每次添加一行时，React都在计算和比较整个虚拟DOM树。现在尝试点击一行内的counter按钮。你将看到<code>state</code>更新后虚拟DOM如何更新 —— 只有引用了<code>state key</code>的元素及其children受到影响。</p><p>React DevTools会提示问题出在哪里，但不会告诉我们有关细节的信息：特别是所涉及的更新，是由<code>diffing</code>元素引起的？还是被挂载（<code>mounting</code>）或者被卸载（<code>unmounting</code>）了？要了解更多信息，我们需要使用React的内置<a href="https://reactjs.org/docs/optimizing-performance.html#profiling-components-with-the-chrome-performance-tab" target="_blank" rel="noopener">分析器</a>（注意它不适用于生产模式）。</p><p>添加<code>?react_perf</code>到应用的URL，然后转到Chrome DevTools中的“Performance”标签。点击“录制”（Record）并在表格上点击。添加一些row，更改一下counter，然后点击“停止”（Stop）。</p><p><img src="http://sinacloud.net/woodysblog/img/react_perf_tools.png" alt="&quot;React DevTools的“Performance”选项卡&quot;"></p><p>在输出的结果中，我们关注“User timing”这项指标。放大时间轴直到看到“React Tree Reconciliation”这个组及其子项。这些就是我们组件的名称，它们旁边都写着[update]或[mount]。</p><hr><p><strong>我们的大部分性能问题都属于这两类问题之一。</strong></p><hr><p>无论是组件（还是从它分支的其他组件）出于某种原因都会在每次更新时re-mounted（慢），又或者我们在大型应用上执行对每个分支做diff，尽管这些组件并没有发生改变，我们不希望这些情况的发生。</p><h2 id="优化我们的代码：Mounting-Unmounting"><a href="#优化我们的代码：Mounting-Unmounting" class="headerlink" title="优化我们的代码：Mounting / Unmounting"></a>优化我们的代码：Mounting / Unmounting</h2><p>现在，我们已经了解到当需要update Virtual Dom时，React是依据哪些规则去判断要不要更新，以及也知道了我们可以通过什么方式去追踪这些diff场景的背后发生了什么，我们终于准备好优化我们的代码了！首先，我们来看看mounts/unmounts。</p><p>如果你能够注意到当一个元素包含的多个children，他们是由array组成的话，你可以实现十分显著的速度优化。</p><p>我们来看看这个case：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;Message /&gt;</span><br><span class="line">  &lt;Table /&gt;</span><br><span class="line">  &lt;Footer /&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><p>在我们的Virtual DOM里这么表示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">props: &#123;</span><br><span class="line">  children: [</span><br><span class="line">    &#123; <span class="attr">type</span>: Message &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: Table &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: Footer &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>这里有一个简单的<code>Message</code>例子，就是一个<code>div</code>写着一些简单的文本，和以及一个巨大的<code>Table</code>，比方说，超过1000行。它们（<code>Message</code>和<code>Table</code>）都是顶级<code>div</code>的子组件，所以它们被放置在父节点的<code>props.children</code>下，并且它们<code>key</code>都不会有。React甚至不会通过控制台警告我们要给每个<code>child</code>分配<code>key</code>，因为children正在<code>React.createElement</code>作为参数列表传递给父元素，而不是直接遍历一个数组。</p><p>现在我们的用户已读了一个通知，<code>Message</code>（譬如新通知按钮）从DOM上移除。<code>Table</code>和<code>Footer</code>是剩下的全部。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">props: &#123;</span><br><span class="line">  children: [</span><br><span class="line">    &#123; <span class="attr">type</span>: Table &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: Footer &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>React会怎么处理呢？它会看作是一个array类型的children，现在少了第一项，从前第一项是<code>Message</code>现在是<code>Table</code>了，也没有<code>key</code>作为索引，比较<code>type</code>的时候又发现它们俩不是同一个function或者class的同一个实例，于是会把整个<code>Table</code>unmount，然后在mount回去，渲染它的1000+行子数据。</p><p>因此，你可以给每个component添加唯一的<code>key</code>（但在目特殊的case下，使用key并不是最佳选择），或者采用更聪明的小技巧：使用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators" target="_blank" rel="noopener">短路求值</a>（又名“最小化求值”），这是JavaScript和许多其他现代语言的特性。看：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Using a boolean trick</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;isShown &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Message</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Table</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Footer</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>虽然<code>Message</code>会离开屏幕，父元素<code>div</code>的<code>props.children</code>仍然会拥有三个元素，<code>children[0]</code>具有一个值<code>false</code>（一个布尔值）。请记住<code>true, false, null, undefined</code>是虚拟DOM对象<code>type</code>属性的允许值，我们最终得到了类似的结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">props: &#123;</span><br><span class="line">  children: [</span><br><span class="line">    <span class="literal">false</span>, <span class="comment">//  isShown &amp;&amp; &lt;Message /&gt; evaluates to false</span></span><br><span class="line">    &#123; <span class="attr">type</span>: Table &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: Footer &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>因此，有没有<code>Message</code>组件，我们的索引值都不会改变，<code>Table</code>当然仍然会跟<code>Table</code>比较（当<code>type</code>是一个函数或类的引用时，diff比较的成本还是会有的），但仅仅比较虚拟DOM的成本，通常比“删除DOM节点”并“从0开始创建”它们要来得快。</p><p>现在我们来看看更多的东西。大家都挺喜欢用HOC的，高阶组件是一个将组件作为参数，执行某些操作，最后返回另外一个不同功能的组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withName</span>(<span class="params">SomeComponent</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Computing name, possibly expensive...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">SomeComponent</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">name</span>=<span class="string">&#123;name&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>这是一种常见的模式，但你需要小心。如果我们这么写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>() </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// Creates a new instance on each render</span></span><br><span class="line">    <span class="keyword">const</span> ComponentWithName = withName(SomeComponent);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">SomeComponentWithName</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>我们在父节点的<code>render</code>方法内部创建一个HOC。当我们重新渲染（<code>re-render</code>）树时，虚拟DOM是这样子的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// On first render:</span></span><br><span class="line">&#123;</span><br><span class="line">  type: ComponentWithName,</span><br><span class="line">  props: &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// On second render:</span></span><br><span class="line">&#123;</span><br><span class="line">  type: ComponentWithName, <span class="comment">// Same name, but different instance</span></span><br><span class="line">  props: &#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，React会对<code>ComponentWithName</code>这个实例做diff，但由于此时同名引用了不同的实例，因此全等比较（triple equal）失败，一个完整的re-mount会发生（整个节点换掉），而不是调整属性值或顺序。注意它也会导致状态丢失，<a href="https://github.com/facebook/react/blob/044015760883d03f060301a15beef17909abbf71/docs/docs/higher-order-components.md#dont-use-hocs-inside-the-render-method" target="_blank" rel="noopener">如此处所述</a>。幸运的是，这很容易解决，你需要始终在<code>render</code>外面创建一个HOC：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Creates a new instance just once</span></span><br><span class="line"><span class="keyword">const</span> ComponentWithName = withName(Component);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>() </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ComponentWithName</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="优化我的代码：Updating"><a href="#优化我的代码：Updating" class="headerlink" title="优化我的代码：Updating"></a>优化我的代码：Updating</h2><p>现在我们可以确保在非必要的时候，不做re-mount的事情了。然而，对位于DOM树根部附近（层级越上面的元素）的组件所做的任何更改都会导致其所有children的diffing和调整（<code>reconciliation</code>）。在层级很多、结构复杂的应用里，这些成本很昂贵，但经常是可以避免的。</p><hr><p><strong>如果有一种方法可以告诉React你不用来检查这个分支了，因为我们可以肯定那个分支不会有更新，那就太棒了！</strong></p><hr><p>这种方式是真的有的哈，它涉及一个built-in方法叫<code>shouldComponentUpdate</code>，它也是<a href="https://reactjs.org/docs/react-component.html#the-component-lifecycle" target="_blank" rel="noopener">组件生命周期</a>的一部分。这个方法的调用时机：组件的<code>render</code>和组件接收到state或props的值的更新时。然后我们可以自由地将它们与我们当前的值进行比较，并决定是否更新我们的组件（返回<code>true</code>或<code>false</code>）。如果我们返回<code>false</code>，React将不会重新渲染组件，也不会检查它的所有子组件。</p><p>通常来说，比较两个集合（set）<code>props</code>和<code>state</code>一个简单的浅层比较（shallow comparison）就足够了：如果顶层的值不同，我们不必接着比较了。浅比较不是JavaScript的一个特性，但有很多<a href="https://github.com/dashed/shallowequal" target="_blank" rel="noopener">小而美的库</a>（<code>utilities</code>）可以让我们用上那么棒的功能。</p><p>现在可以像这样编写我们的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableRow</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// will return true if new props/state are different from old ones</span></span><br><span class="line">  shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; props, state &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> !shallowequal(props, nextProps)</span><br><span class="line">           &amp;&amp; !shallowequal(state, nextState);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是你甚至都不需要自己写代码，因为React把这个特性内置在一个类<code>React.PureComponent</code>里面。它类似于  <code>React.Component</code>，只是<code>shouldComponentUpdate</code>已经为你实施了一个浅的<code>props</code>/<code>state</code>比较。</p><p>这听起来很“不动脑”，在声明class继承（<code>extends</code>）的时候，把<code>Component</code>换成<code>PureComponent</code>就可以享受高效率。事实上，并不是这么“傻瓜”，看看这些例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Table</span><br><span class="line">    <span class="comment">// map returns a new instance of array so shallow comparison will fail</span></span><br><span class="line">    rows=&#123;rows.map(<span class="comment">/* ... */</span>)&#125;</span><br><span class="line">    <span class="comment">// object literal is always "different" from predecessor</span></span><br><span class="line">    style=&#123; &#123; <span class="attr">color</span>: <span class="string">'red'</span> &#125; &#125;</span><br><span class="line">    <span class="comment">// arrow function is a new unnamed thing in the scope, so there will always be a full diffing</span></span><br><span class="line">    onUpdate=&#123;() =&gt; &#123; <span class="comment">/* ... */</span> &#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p>上面的代码片段演示了三种最常见的反模式。尽量避免它们！</p><hr><p><strong>如果你能注意点，在render定义之外创建所有对象、数组和函数，并确保它们在各种调用间，不发生更改 —— 你是安全的。</strong></p><hr><p>你在<a href="https://iadramelk.github.io/optimizing-react-demo/dist/after.html" target="_blank" rel="noopener">updated demo</a>，所有table的rows都被“净化”（<code>purified</code>）过，你可以看到<code>PureComponent</code>的表现了。如果你在React DevTools中打开“Highlight Updates”，你会注意到只有表格本身和新行在插入时会触发<code>render</code>，其他的行保持不变。</p><p>[译者说：为了便于大家理解<code>purified</code>，译者在下面插入了原文demo的一段代码]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableRow</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> React.createElement(<span class="string">'tr'</span>, &#123; <span class="attr">className</span>: <span class="string">'row'</span> &#125;,</span><br><span class="line">      React.createElement(<span class="string">'td'</span>, &#123; <span class="attr">className</span>: <span class="string">'cell'</span> &#125;, <span class="keyword">this</span>.props.title),</span><br><span class="line">      React.createElement(<span class="string">'td'</span>, &#123; <span class="attr">className</span>: <span class="string">'cell'</span> &#125;, React.createElement(Button)),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不过，如果你迫不及待地all in PureComponent，在应用里到处都用的话 —— 控制住你自己！</p><p>shallow比较两组<code>props</code>和<code>state</code>不是免费的，对于大多数基本组件来说，甚至都不值得：<code>shallowCompare</code>比<code>diffing</code>算法需要耗费更多的时间。</p><p>使用这个经验法则：pure component适用于复杂的表单和表格，但它们通常会减慢简单元素（按钮、图标）的效率。</p><hr><p>感谢你的阅读！现在你已准备好将这些见解应用到你的应用程序中。可以使用我们的小demo（<a href="https://iadramelk.github.io/optimizing-react-demo/dist/after.html" target="_blank" rel="noopener">用了</a>或<a href="https://iadramelk.github.io/optimizing-react-demo/dist/before.html" target="_blank" rel="noopener">没有用</a>PureComponent）的<a href="https://github.com/iAdramelk/optimizing-react-demo" target="_blank" rel="noopener">仓库</a>作为你的实验的起点。此外，请继续关注本系列的下一部分，我们计划涵盖Redux并优化你的数据，目标是提高整个应用的总体性能。</p><h2 id="译者说"><a href="#译者说" class="headerlink" title="译者说"></a>译者说</h2><p>正如原文末所说，Alex和Andy后续会继续写一个关于整体性能的系列，包括核心React和Redux等，我也会继续跟踪这个系列的文章，到时po到我的<a href="http://wuyuying.com/blog/">个人博客</a>和知乎专栏<a href="https://zhuanlan.zhihu.com/front-end-thinking" target="_blank" rel="noopener">《集异璧》</a>，感兴趣的同学们可以关注一下哈 ：）</p><p>欢迎对本文的翻译质量、内容的各种讨论。若有表述不当，欢迎斧正。</p><p>2018.05.13，晴，杭州滨江<br>Yuying Wu</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文译自&lt;a href=&quot;https://evilmartians.com/chronicles/optimizing-react-virtual-dom-explained&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Optimizing React
      
    
    </summary>
    
    
      <category term="front-end" scheme="http://wuyuying.com/tags/front-end/"/>
    
      <category term="performance" scheme="http://wuyuying.com/tags/performance/"/>
    
      <category term="reactjs" scheme="http://wuyuying.com/tags/reactjs/"/>
    
      <category term="translation" scheme="http://wuyuying.com/tags/translation/"/>
    
  </entry>
  
  <entry>
    <title>关于「自由态职业」</title>
    <link href="http://wuyuying.com/archives/slash/"/>
    <id>http://wuyuying.com/archives/slash/</id>
    <published>2018-04-30T15:37:19.000Z</published>
    <updated>2018-05-25T15:20:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近读了萧秋水和剽悍一只猫的<a href="https://book.douban.com/subject/27177491/" target="_blank" rel="noopener">《知识变现》</a>，准确的来说，这本书不全是讲如何变现你的知识，而是从多方面去解释什么是“斜杠青年”和“自由职业”，而“自由态职业”又是什么，个人觉得此书应该改名为《国内斜杠青年/自由工作者的生活/工作现状》。</p><a id="more"></a><p>想起在新西兰working holiday的时候，曾经遇到一个Airbnb的房东Chris，是个自由职业的程序员。一次偶然的机会看到他的书房，看到3个屏幕，我就问他是不是IT行业的，没想到Chris是为IBM远程工作的，他在新西兰，团队base在美国还是加拿大，做的是后端开发相关工作。</p><p>这次我第一次面基自由职业者的工程师，非常好奇，就趁机问了一直很感兴趣的几个问题。</p><p><code>WYY:</code> 为什么会选择自由职业？<br><code>Chris:</code> 我有两个孩子，希望多一点时间陪伴家人，如果出国工作的话，可能一年就没多少时间可以在家里陪伴家人了。（注：新西兰的IT工作机会一般在奥克兰、惠灵顿这样的大城市，不过相对没有像美国或者中国一样有各式各样的top IT companies哈）</p><p><code>WYY:</code> 那日常你是怎么工作的呢？<br><code>Chris:</code> 早上6点起床，趁着孩子们还没起床，就开始锻炼和工作，有个独立的书房，可以安静的做自己的事情。然后到点了送孩子们去上学，回来继续工作，那么到孩子们放学之后，我就有自由的时间可以陪伴他们了。</p><p><code>WYY:</code> remote的工作，是怎么找到工作的？不会沟通成本比较高吗？<br><code>Chris:</code> 我之前就在IBM工作的，比较熟悉工作流程，后来我因为家庭原因，选择回来新西兰，我的前老板问我有没有兴趣远程工作，我就答应了，跟团队的合作、沟通还算流畅。</p><p>其实从跟Chris的对话里面可以发现，自由职业者的生活有可能比正常朝九晚五还困难些，需要自律，也需要具备很好的时间管理的能力，才能在工作和生活的时间打乱的情况，还能做到很好的平衡。专业能力以外，你可能还需要做一些自我销售、运营等等的工作以外的事情，让更多人知道你和信任你。</p><p>“自由职业”不是一种职业，而是你本身具备专业能力，有选择的“自由”。</p><p>正如书中说的：</p><blockquote><p>成为自由职业者并不是一件容易的事，要成为自由职业者，必须是具有一定的专业知识与技能，要有社会生存能力，还要有坚强的意志。</p></blockquote><p>整体来说，如果想了解斜杠青年/自由职业者的工作生活状态的话，还是可以看看这本书哈。更多书摘如下。</p><h2 id="斜杠青年和自由职业，职业定位新趋势"><a href="#斜杠青年和自由职业，职业定位新趋势" class="headerlink" title="斜杠青年和自由职业，职业定位新趋势"></a>斜杠青年和自由职业，职业定位新趋势</h2><p>“斜杠青年”来源于英文“Slash”，《纽约时报》专栏作家麦瑞克·阿尔伯撰写了一本书，叫作《双重职业》（One Person/Multiple Careers: A New Model for Work/Life Success）。</p><h3 id="你认为普通人如何修炼才能成为斜杠青年？"><a href="#你认为普通人如何修炼才能成为斜杠青年？" class="headerlink" title="你认为普通人如何修炼才能成为斜杠青年？"></a>你认为普通人如何修炼才能成为斜杠青年？</h3><p>（from 吉吉）</p><h4 id="第一，知道自己为什么要成为斜杠青年再开始："><a href="#第一，知道自己为什么要成为斜杠青年再开始：" class="headerlink" title="第一，知道自己为什么要成为斜杠青年再开始："></a>第一，知道自己为什么要成为斜杠青年再开始：</h4><ol><li>不要赶流行，不要因为别人说斜杠青年好，就盲目地加入，这应该是一种有目标的主动选择，而且知道需要大量的投入，其实很辛苦；</li><li>有深层次的需求，像我说的安全感，还有一些契机，比如年龄、家庭变故、工作瓶颈等；</li><li>摆清斜杠和单杠的关系，斜杠不是单杠做不好就逃避，单杠没解决的问题没踩过的坑，斜杠一样会掉进去重补这一课，所以应该把单杠做好，打一个比较稳的地基，培养核心技能，就算不喜欢，单杠也可以修炼你把不喜欢的事做好的能力。</li></ol><h4 id="第二，斜杠青年的四阶段："><a href="#第二，斜杠青年的四阶段：" class="headerlink" title="第二，斜杠青年的四阶段："></a>第二，斜杠青年的四阶段：</h4><ol><li><p>照妖镜：认知自己，找到精进的方向。</p><ul><li><p>更多维度地去了解自己，通过各种各样的工具，比如性格测试、行为风格测试、生活态度取向测试、价值观梳理，去认知自己，知道自己是什么样的人，为什么同样是探索，速度、节奏、心态会有不同。</p></li><li><p>知道自己喜欢什么，找到兴趣和天命。排除钱、时间等因素，最想做什么，梳理过往成就事件，找到一些共性，发现自己真正喜欢的是什么。</p></li><li><p>认知现实、遥望理想，将愿景描绘出来并固化，找到差距和努力的方向。</p></li></ul></li><li><p>默练剑：通过持续行动，修炼技能</p><ul><li>划分能力矩阵，喜欢与擅长的优势区是核心技能，需要不断打磨；</li><li>喜欢但是不擅长的，是潜能的部分，应该加强，培育发芽的小种子；</li><li>不喜欢也不擅长的盲区，不要做，回避不了的，死磕到不扯后腿。</li></ul></li><li><p>等风来：外化自己，扩大圈子，告诉别人自己准备好了，积极地站在风口处等待机会的来临，甚至主动出击。</p></li><li><p>滚雪球：依托一个平台和身份，斜杠身份的数量会不断地拓展，然后要具有把多重身份整合在一起打组合拳的能力。</p></li></ol><h4 id="第三，斜杠青年要注意的："><a href="#第三，斜杠青年要注意的：" class="headerlink" title="第三，斜杠青年要注意的："></a>第三，斜杠青年要注意的：</h4><ol><li>要围绕个人品牌，这样单个身份或者平台如果失去了势能，大家还会因为认可这个人而追随。</li><li>所有的积累都有价值，不一定马上兑换成显性的名利，但是这当中积累的经验、可迁移的能力都是弥足珍贵的，人走的每一步，都有价值。</li><li>要有多个维度的平衡：阶段性专注、身体保障、家人情感的支持、时常审视初心。</li></ol><h2 id="你适合成为自由职业者吗"><a href="#你适合成为自由职业者吗" class="headerlink" title="你适合成为自由职业者吗"></a>你适合成为自由职业者吗</h2><p>成为自由职业者并不是一件容易的事，要成为自由职业者，必须是具有一定的专业知识与技能，要有社会生存能力，还要有坚强的意志。</p><p>自由职业的自由，不是辞职的自由，而是选择的自由，这个选择背后，是能力的自由。</p><p>要想在自己的自由职业生涯中最大限度地降低风险，有几项原则：</p><p>第一，要把握好“市场需要、我最擅长、能者不多”的定位原则，使自己或自己的产品具有市场性、竞争性和独特性；不要试图山寨别人，靠拷贝别人现买现卖是没有竞争力的。同样的道理，如果你的产品或服务能够被别人轻易拷贝，那也说明你并没有别人不能取代的核心竞争力。</p><p>第二，为了防止自己知识和技能的老化，你必须具有不断学习和创造的能力，而不是试图“一招鲜，吃遍天”。这在知识更新速度日益加快的今天，已经行不通了。学习能力已经演变成为新的生存能力。</p><p>第三，增强自己的法律意识和风险意识，在与人合作的过程中要有维权意识，注意用法律和规则保护自己，以防“客大欺店”和遭小人暗算。</p><p>第四，尽早地为自己在医疗、意外和养老方面投入必要的保险资金，做到晴天也防连阴雨。</p><h2 id="互联网时代的雇佣关系"><a href="#互联网时代的雇佣关系" class="headerlink" title="互联网时代的雇佣关系"></a>互联网时代的雇佣关系</h2><p>里德·霍夫曼的《联盟》开章明义，给出了这样的观点。</p><p>在里德看来，用联盟的方式重建雇主和员工的关系非常必要。“商业世界需要有利于相互信任、相互投资、共同受益的新雇佣关系框架。理想的雇佣关系框架鼓励员工发展个人人脉、勇于开拓实干，而不是成为唯利是图的跳槽专业户。”</p><p>如何建立联盟，书中有几个最重要的观点：</p><ol><li>相互坦诚</li><li>相互尊重对方的价值观和梦想，并一起努力。</li><li>制定互惠互利的任期计划，包含双方的权利、义务和利益，并有明确的目标和时间（据书中的意思，就好像足球俱乐部的模式一样，队员干满一个赛季就可以转会，也可以继续留在球队干）。</li><li>帮助员工个人的职业发展。</li><li>鼓励和支持员工发展个人人脉，并保持与离职员工的相互关注和长久合作。</li></ol><h2 id="K-K-的1000付费用户理论"><a href="#K-K-的1000付费用户理论" class="headerlink" title="K.K.的1000付费用户理论"></a>K.K.的1000付费用户理论</h2><p>读凯文·凯利的《技术元素》，里面提到了1000人付费理论。主要的观点是，如果有1000人愿意给你一天自己的收入，那独立手艺人就可以依靠这个专门生产工作。</p><h2 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h2><p>《搞定1》<br>《小强升职记》</p><h2 id="每个人都可以是自己的人生设计师"><a href="#每个人都可以是自己的人生设计师" class="headerlink" title="每个人都可以是自己的人生设计师"></a>每个人都可以是自己的人生设计师</h2><p>《游牧东京》：作者米田智彦做的“生活实践项目” —— 不住在家里，也没有固定的办公室里工作，而是仅依靠一个拉杆箱在东京游走，与他人共享大都市的所有功能。</p><h2 id="如何提升基础能力"><a href="#如何提升基础能力" class="headerlink" title="如何提升基础能力"></a>如何提升基础能力</h2><h3 id="一、如何锻炼阅读能力"><a href="#一、如何锻炼阅读能力" class="headerlink" title="一、如何锻炼阅读能力"></a>一、如何锻炼阅读能力</h3><p>《如何阅读一本书》<br>《这样读书就够了》<br>《拆出你的沟通力I》<br>《拆出你的沟通力II》</p><h3 id="二、如何锻炼思考能力"><a href="#二、如何锻炼思考能力" class="headerlink" title="二、如何锻炼思考能力"></a>二、如何锻炼思考能力</h3><p><a href="https://www.douban.com/doulist/44255360/" target="_blank" rel="noopener">豆瓣书单</a> from 萧秋水</p><ol><li>《麦肯锡入职培训第一课》</li><li>《轻松学会独立思考》</li><li>《思考的技术》</li><li>《思考，快与慢》</li><li>《比知识还多》（最后一本比较难，可以先从作者的另外一本书《六顶思考帽》开始）</li></ol><h3 id="三、如何提升写作能力"><a href="#三、如何提升写作能力" class="headerlink" title="三、如何提升写作能力"></a>三、如何提升写作能力</h3><p>刻意练习第一条就得确定你练习要达到的目标。</p><p>你写哪个方向？准备用怎样的类型写作？对标的高手是谁？你计划通过多少篇的练习达到何种水平的输出质量？达到怎样输出质量的文章你才对外分享？</p><p>想好写什么文章，可以先写，也可以看别人怎样写再模仿写，都可以。但无论如何一定要多看。</p><p>比方写影评，先想想自己怎样写，好选一个不同的点切入。然后带着构思去翻别人写的影评，看看别人的立意、切入点、选图、联系的案例，还有金句，包括整体的框架，对比后发现不足，然后就知道改进的方向。</p><p>看完你要能说出一篇文章好在哪里，不好在哪里，要能看出你和作者在阅读面、阅历面上的差距在哪里。这样的看才能帮助自己找到差距，进而通过有追赶目标的写作来提升自己的写作质量。</p><h4 id="多看还要解决两个问题"><a href="#多看还要解决两个问题" class="headerlink" title="多看还要解决两个问题"></a>多看还要解决两个问题</h4><p>第一，看真正好的文字，看真正优秀写作者的文字。<br>第二，看不同类型的写作者的好文字，避免形成写作路径的依赖，广义的多看也包括看电影、听音乐，一切艺术都可以激发写作的灵感。</p><p>这也是多看的另外一个价值，帮助自己找到写作灵感，打开写作思路。</p><h4 id="今天的问题"><a href="#今天的问题" class="headerlink" title="今天的问题"></a>今天的问题</h4><p>什么是写作？什么是有质量的写作？什么是长期保持有质量的写作？</p><p>要提升能力，只读书是不够的，需要反复训练，才能真正提升，比如阅读能力，如果阅读的速度和质量上不去，那么学习能力也谈不上很高。而思考和写作更是需要练习的事情，这些练习，其实可以结合工作一起进行，即：根据自己的职业生涯规划和人生目标来确定阅读范围，并注重实践。</p><p>除了读书训练以外，接受培训、包括系统的成人教育，比如MBA等也是有效的，现在在线课程和学习社群也很发达，系统地学习课程和参与课程也是吸收知识的好途径。</p><h3 id="四、如何提升专业能力"><a href="#四、如何提升专业能力" class="headerlink" title="四、如何提升专业能力"></a>四、如何提升专业能力</h3><p>构建专业知识地图（知识树）。</p><p>《全新思维》一书里讲过，未来最重要的六种技能是：</p><ul><li><p>设计感：每个人都必须培养一种艺术感，好的设计可以改变世界，不管从事什么样的工作，都可以像艺术家一样工作。</p></li><li><p>故事感：会讲故事，用故事的形式表达自己、与人沟通，故事性会越来越成为商品和服务在拥挤的市场中脱颖而出的一件法宝。如果你对故事感的理解还不够，可以去了解一下戚泽明的故事，他从故事里看到商机，自称“首席故事官”。</p></li><li><p>交响能力：可以理解为整合事物的能力、跨界能力，善于找出看上去毫不相干的领域之间的联系，善于组合别人所不在意的要素，实现创新。</p></li><li><p>共情能力：可以理解为同理心，能够设身处地体验他人处境，从而达到感受和理解他人情感的能力。</p></li><li><p>娱乐感：简单说来就是会玩，人需要具备适当的幽默感（可千万别误解为会说黄段子！），不仅会玩，更要玩出水平。</p></li><li><p>探寻意义：能够寻找生存的意义，认真对待精神追求，寻找真正的幸福。</p></li></ul><p>简单的来说，就是：</p><p>要有品位、懂艺术、要会讲故事，能跨界，有同理心，会玩出花样来，而且要有追求，会探寻事物的意义。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近读了萧秋水和剽悍一只猫的&lt;a href=&quot;https://book.douban.com/subject/27177491/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《知识变现》&lt;/a&gt;，准确的来说，这本书不全是讲如何变现你的知识，而是从多方面去解释什么是“斜杠青年”和“自由职业”，而“自由态职业”又是什么，个人觉得此书应该改名为《国内斜杠青年/自由工作者的生活/工作现状》。&lt;/p&gt;
    
    </summary>
    
      <category term="reading" scheme="http://wuyuying.com/categories/reading/"/>
    
    
  </entry>
  
  <entry>
    <title>CSS Variables学习笔记</title>
    <link href="http://wuyuying.com/archives/css-var/"/>
    <id>http://wuyuying.com/archives/css-var/</id>
    <published>2018-01-11T09:32:16.000Z</published>
    <updated>2018-05-25T10:34:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了下CSS Variables（CSS变量，又名CSS自定义属性），跟大家分享一下我的学习笔记。</p><h2 id="一、什么是CSS-Variables"><a href="#一、什么是CSS-Variables" class="headerlink" title="一、什么是CSS Variables"></a>一、什么是CSS Variables</h2><p>来，直接看<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Using_CSS_variables" target="_blank" rel="noopener">MDN</a>上的描述：</p><blockquote><p>CSS 变量是由CSS作者定义的实体，其中包含要在整个文档中重复使用的特定值。使用自定义属性来设置变量名，并使用特定的 var() 来访问。</p></blockquote><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">color</span>: <span class="built_in">var</span>(--main-<span class="built_in">color</span>);</span><br></pre></td></tr></table></figure><h2 id="二、学习笔记"><a href="#二、学习笔记" class="headerlink" title="二、学习笔记"></a>二、学习笔记</h2><h3 id="1-声明-amp-调用"><a href="#1-声明-amp-调用" class="headerlink" title="1. 声明 &amp; 调用"></a>1. 声明 &amp; 调用</h3><h4 id="i-声明方式"><a href="#i-声明方式" class="headerlink" title="i. 声明方式"></a>i. 声明方式</h4><p>CSS变量声明的方式非常简单，如下，声明了一个名叫<code>color</code>的CSS变量。</p><ul><li>在css文件中写</li><li>写在html标签的inline-style里</li><li>用JS给某个元素声明，方法<code>.style.setProperty</code></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">  <span class="attribute">--color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">"--color: red;"</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>].style.setProperty(<span class="string">'--color'</span>, <span class="string">'red'</span>)</span><br></pre></td></tr></table></figure><h4 id="ii-调用方式"><a href="#ii-调用方式" class="headerlink" title="ii. 调用方式"></a>ii. 调用方式</h4><p>通过<code>var()</code>函数调用，如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.block</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="iii-变量的命名"><a href="#iii-变量的命名" class="headerlink" title="iii. 变量的命名"></a>iii. 变量的命名</h4><p>说完声明和调用，还有个小问题。那么，CSS变量的命名，有什么限制么？下面我们来测试一下。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.foo-test</span>&#123;</span><br><span class="line">  <span class="attribute">--foo</span>:;</span><br><span class="line">  <span class="attribute">--ffoo</span>:;</span><br><span class="line">  <span class="attribute">--Foo</span>: red;</span><br><span class="line">  <span class="attribute">--FOo</span>: blue;</span><br><span class="line">  <span class="attribute">--FOO</span>: green;</span><br><span class="line">  <span class="comment">/* 以下省略测试className的代码 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://sinacloud.net/woodysblog/img/css-var-case-sensitive.png" alt=""></p><p>从以上测试代码可以看出：</p><ul><li>CSS变量的命名是大小写敏感的</li><li>不赋值或者赋值空格，都是无效的</li></ul><h3 id="2-作用域-amp-继承"><a href="#2-作用域-amp-继承" class="headerlink" title="2. 作用域 &amp; 继承"></a>2. 作用域 &amp; 继承</h3><p>CSS变量也有作用域一说，而最顶层的作用域就是<code>:root</code>，下面的所有的元素都可以共享相关CSS变量。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span>&#123;</span><br><span class="line">  <span class="attribute">--color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚才我们在<code>body</code>上，定义了<code>--color</code>，在<code>body</code>下的子元素，都会默认继承这个属性，随意使用。当然也可以重载，把<code>--color</code>定义为别的值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"block"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>inherit color<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"css-var-text"</span>&gt;</span>overwrite color - hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">  <span class="attribute">--color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.block</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.css-var-text</span>&#123;</span><br><span class="line">  <span class="attribute">--color</span>: red;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>.block</code>，作为<code>body</code>的子元素，继承了<code>--color</code>属性，所以边框出来就是<code>green</code>。</p><p>而<code>.css-var-text</code>在自己的作用域中，重写了<code>--color</code>，出来的字体颜色是overwrite后的<code>blue</code>。</p><p><img src="http://sinacloud.net/woodysblog/img/css-var-inherit.png" alt=""></p><h3 id="3-浏览器支持"><a href="#3-浏览器支持" class="headerlink" title="3. 浏览器支持"></a>3. 浏览器支持</h3><h4 id="i-浏览器支持现状"><a href="#i-浏览器支持现状" class="headerlink" title="i. 浏览器支持现状"></a>i. 浏览器支持现状</h4><p>来看看<a href="https://caniuse.com/#search=css%20variables" target="_blank" rel="noopener">caniuse</a>上CSS Variables (Custom Properties)的支持度：</p><p>PC的话，IE 11和Edge的支持度都很差，而Chrome（2016.3）、Firefox（2017.11）和Safari(2017.3)的一些新版本都是支持的，相信很快就能普及。</p><p>Mobile的话，Safari在2016年的版本已经支持CSS变量了，但Opera、Chrome、UC等的支持还不太好。</p><p><img src="http://sinacloud.net/woodysblog/img/css-var-browser-support.png" alt=""></p><h4 id="ii-fallbacks"><a href="#ii-fallbacks" class="headerlink" title="ii. fallbacks"></a>ii. fallbacks</h4><p>浏览器的支持度不太好，我们又想玩新东西的话，就需要考虑如果浏览器不支持CSS变量，怎么优雅降级。（嗷，两套代码是有点……）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 当浏览器不支持CSS变量 */</span></span><br><span class="line"><span class="selector-class">.browser-support</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>: red;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 当浏览器支持CSS变量 */</span></span><br><span class="line">@<span class="keyword">supports</span> (--css: variables) &#123;</span><br><span class="line">  <span class="selector-class">.browser-support</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">var</span>(--color);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、代码习作"><a href="#三、代码习作" class="headerlink" title="三、代码习作"></a>三、代码习作</h2><h3 id="1-codepen"><a href="#1-codepen" class="headerlink" title="1. codepen"></a>1. codepen</h3><p>在学习CSS Variables的时候，有边写一些教程的demo，除了以上，还包括一些实际场景的应用，如像box-shadow复合属性的拆解，以及JS操作CSS变量等。</p><p></p><p data-height="500" data-theme-id="0" data-slug-hash="dZrYJg" data-default-tab="css,result" data-user="wuyuying" data-embed-version="2" data-pen-title="CSS Varibles Study Notes" class="codepen">See the Pen <a href="https://codepen.io/wuyuying/pen/dZrYJg/" target="_blank" rel="noopener">CSS Varibles Study Notes</a> by Y (<a href="https://codepen.io/wuyuying" target="_blank" rel="noopener">@wuyuying</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script><h3 id="2-flexbox属性的DEMO"><a href="#2-flexbox属性的DEMO" class="headerlink" title="2. flexbox属性的DEMO"></a>2. flexbox属性的DEMO</h3><p><img src="http://sinacloud.net/woodysblog/img/css-var-flexbox.png" alt=""></p><p>之前在团队也做过一下下flexbox的分享，大家也知道，flex属性和对应的值特别多，当时就很想做个可以随时变属性值看效果的playground。</p><p>但想了下传统的实现方式，貌似没有优雅的方法。</p><ul><li>CSS+JS实现：写一批classname，option切换时，通过JS修改classname改变样式；</li><li>纯JS实现，根据option的value用JS改写元素的inline style（一直修改dom）</li></ul><p>哎哟，换CSS Variables之后，一切就不一样了，可继承、可复用、易维护，目前实现比较简单，可能跟以上的传统方式差别不太大，不过后续要修改或者做更多优化，我相信优势就会凸显出来了。</p><p>demo传送门：<a href="http://wuyuying.com/flexbox-css-var/">wuyuying.com/flexbox-css-var</a><br><a href="https://github.com/YuyingWu/blog-modern/blob/master/pages/flexbox-css-var.js" target="_blank" rel="noopener">github传送门</a></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>哈哈，没想到小结写什么，如果大家有好玩的CSS Variables的应用，欢迎分享给我 ：）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近看了下CSS Variables（CSS变量，又名CSS自定义属性），跟大家分享一下我的学习笔记。&lt;/p&gt;
&lt;h2 id=&quot;一、什么是CSS-Variables&quot;&gt;&lt;a href=&quot;#一、什么是CSS-Variables&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="front-end" scheme="http://wuyuying.com/tags/front-end/"/>
    
      <category term="CSS" scheme="http://wuyuying.com/tags/CSS/"/>
    
      <category term="CSS Variables" scheme="http://wuyuying.com/tags/CSS-Variables/"/>
    
  </entry>
  
  <entry>
    <title>我的2017</title>
    <link href="http://wuyuying.com/archives/year-2017/"/>
    <id>http://wuyuying.com/archives/year-2017/</id>
    <published>2018-01-01T10:23:28.000Z</published>
    <updated>2018-05-25T10:34:15.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://sinacloud.net/woodysblog/year-2017/DSC05035.jpg" alt="&quot;龙井路秋色&quot;"><br>（龙井路秋色 —— 摄于杭州龙井路 2017.12.03）</p><h2 id="Personal-Targets-for-2017"><a href="#Personal-Targets-for-2017" class="headerlink" title="Personal Targets for 2017"></a>Personal Targets for 2017</h2><ul><li>√ 找一份好工作</li><li>√ 运动</li><li>√ 理财（跑赢大盘）</li><li>× 读书（40本）</li></ul><p>在2017年的尾巴，汇总了下今年都做了什么，KPI达标了没？讲真，在我工作的这几年间，今年的达标程度算非常的高，还蛮开心的。</p><h3 id="找一份好工作"><a href="#找一份好工作" class="headerlink" title="找一份好工作"></a>找一份好工作</h3><p>找工作的故事，之前写过一篇<a href="/blog/archives/begin-again-2017/">《Begin again, 2017》</a>，在此就不再叙述了。</p><p>相信很多小伙伴们都知道的，今年5月份，我来了杭州，来到职业生涯中的第二家公司 —— 阿里巴巴，供职于国内第一大B2B平台<a href="https://www.1688.com" target="_blank" rel="noopener">1688</a>。简而言之，我现在做批发的，要是有想跟1688合作的朋友们，尤其是大新塘做牛仔的土豪们，欢迎联系我 :)</p><p>想入职阿里的靠谱前端朋友们，也欢迎把简历发给我：  </p><p><a href="mailto:`jiwu.wyy@alibaba-inc.com" target="_blank" rel="noopener">`jiwu.wyy@alibaba-inc.com</a>`</p><p><img src="http://sinacloud.net/woodysblog/year-2017/1688.jpg" alt=""></p><p>好啦，广告打完，说回这项KPI吧，个人认为，确实是找到一份<strong>好工作</strong>的。</p><p>我遇到了一个技术出身且很能talk、格局很高、EQ也非常高的老大 —— 重鱼，在融入新工作环境过程中，他给予我很多的帮助和建议。不过融入只是第一步，相信后续的发展，我能从他身上学到更多的东西。</p><p>我遇到了一群很nice很有能力的小伙伴们，在这就不一一点名，你们懂的，从大家身上我也get到很多新技能，不仅仅有技术或者业务能力的提高，还看到程序猿的另一面，不仅会敲代码，还玩得了狼人杀、可以一起去泡吧。</p><p><img src="http://sinacloud.net/woodysblog/year-2017/team1.jpg" alt=""></p><p><img src="http://sinacloud.net/woodysblog/year-2017/team2.jpg" alt=""></p><p><img src="http://sinacloud.net/woodysblog/year-2017/team3.jpg" alt=""></p><p>我看到了我想看到的阿里。我一直很想来阿里看看，想看看在马老师带领下的阿里巴巴是怎样的。我来的时间不长，且只在一个业务线，了解尚浅。</p><p>在新人培训（百年阿里）中，我认识了一些来自不同部门、各种岗位的同学们，有刚刚从学校步入职场的“小学鸡”，有在职场打滚多年、拥有若干创业经验的“老司机”。我从他们身上，一样的是，能看到大家对于新环境的憧憬和激情，这就是我想看到的阿里。</p><p>当然他们很多跟我一样，是马老师的粉丝，想来一睹马老师真容。在今年阿里巴巴B2B年会，还真看到马老师了，不过我是山顶的朋友，只能透过大屏幕远远的看他。</p><p><img src="http://sinacloud.net/woodysblog/year-2017/b2b-jack.jpg" alt=""></p><p><img src="http://sinacloud.net/woodysblog/year-2017/b2b.jpg" alt=""></p><h3 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h3><p>运动这一项，一直没有确定的kpi，一切随风，这几年，基本没有达标过（捂脸）</p><p>今年在运动这一栏，万万没想到，居然有东西可以写：</p><blockquote><p>慢跑训练<br>从9.18开始，一周3次，持续了6周<br>最长时间 42 Mins，最远距离 4.82 KM，最快配速 8:02 min/KM</p></blockquote><p><img src="http://sinacloud.net/woodysblog/year-2017/running.jpg" alt=""></p><p>对于跑步，一开始我是拒绝的，哪有人喜欢这样的运动，累cry，又容易跑着跑着就肚子疼，简直懒得动，有木有！</p><p>第1周，在公司的健身房，跑1分钟，走2分钟，8个回合，共24分钟2.6公里；<br>第6周，在江边，跑5分钟，走1分钟，7个回合，共42分钟4.82公里。</p><p>在这几个礼拜训练之后，感觉还是很不一样的。从一开始的拒绝，在健身房磨蹭，到后来每周在江边定期打卡，除了更加健康和学会了“呼呼呼、吸吸吸”的呼吸小窍门以外，还多了一些跟自己相处的时间。</p><p>在跑步之后，和自己对话的场景加了一项：</p><ul><li>安静地看书</li><li>在上班路上听电台/音乐</li><li><strong>跑步</strong></li></ul><p>在日常生活/工作中，我的大部分时间在写代码/学习写代码、玩手机、看电视剧，做这些事情也许我是一个人在做，但手上、脑子里都被各式各样的东东侵占着，没时间去想。</p><p>还记得有一次跟同事们饭后遛弯，聊起“如何放松”。我们甚至聊到冥想，我就把慢跑介绍给他们，紧张的都市人尤其值得拥有。</p><p>确实是这样的，有时候越睡越困，身体在休息，但思绪并没有释放，精神压力没有得到释放，还是一样的累。记得有一天心情不太舒畅，去江边跑步，刚开始我还是一样的没心情，但跑着跑着，当我把所有注意力放在呼吸和沿途的人和景上面，整个人放空地前进前进前进，跑完之后，我有种满血复活的感觉。</p><p><img src="http://sinacloud.net/woodysblog/year-2017/running2.jpg" alt=""></p><p>最近杭州有点冷，最冷的时候零下了，实在没勇气出门，暖和点要继续跑起来，不要浪费杭州那么棒的江边跑道。</p><h3 id="理财"><a href="#理财" class="headerlink" title="理财"></a>理财</h3><p>理财这块，也是每年比较羞于启齿的，哈哈，因为这几年几乎每年都是跑输大盘的，没赢过。</p><p>每年的理财KPI也只有一个 —— 能够跑赢大盘。</p><p>感觉得跑赢大盘越来越难了，2017年大盘大概涨了6.56%（2016.12.25-2017.12.25），真是Holy Shxx!!!</p><p>说回我自己的篮子吧，货基、股基、A股、美股、p2p啥都有点，就不细说了，12月份上车数字货币世界，Cardano给我打了个神助攻，一年下来终于没白玩了，哈哈。</p><blockquote><p>整个篮子浮盈10.24%</p></blockquote><p>2018年开始，放弃A股啦，每年都要用小基金赚得那点钱来补贴，左手倒右手，被割韭菜，年年白玩，今年做了一个艰难的决定，把深套的全都割了，不玩了！</p><p>嘿嘿，不过我可以和新欢一起玩，指数基金和Bitcoin的一众后宫。</p><h3 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h3><p>每年的目标是40本。</p><p>整理了一下，截至12.31，总共读了25本，其中跟工作/技术相关的有9本，经济/理财相关的4本。</p><p>今年技术书比较多，毕竟今年最大的目标是找工作，在投简历前几个月，为了让自己不要太out，只能多读书了，哈哈。</p><p>不过我的年度之书是这本，技术会过时，但经济概念不会，风趣易懂的经济故事书（其实后面概念理解起来也挺难的，哈哈，我打算二刷~）</p><blockquote><p><a href="https://book.douban.com/subject/26985299/" target="_blank" rel="noopener">《小岛经济学：鱼、美元和经济的故事》</a></p></blockquote><h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><p>今年2月份开始，写的一个专栏，记录我的新西兰生活 —— <a href="https://read.douban.com/column/6032026/" target="_blank" rel="noopener">《中土世界漂流记》</a>。讲真，更新频率不是很稳定，今年就写了7篇，这么更新到2019年肯定还在连载。那在2018年，还是希望隔周更新的，哈哈，我努力。</p><p><img src="http://sinacloud.net/woodysblog/year-2017/column.png" alt=""></p><h3 id="2017小结"><a href="#2017小结" class="headerlink" title="2017小结"></a>2017小结</h3><p>以上都是常规的计划内的目标，今年也有一些“小意外”。</p><p>譬如遇见我家大王 —— 胖达。</p><p><img src="http://sinacloud.net/woodysblog/year-2017/pangda.jpg" alt="&quot;小时候&quot;"></p><p><img src="http://sinacloud.net/woodysblog/year-2017/pangda-july.jpg" alt="&quot;小学鸡&quot;"></p><p><img src="http://sinacloud.net/woodysblog/year-2017/pangda-sep.jpg" alt="&quot;一秒变大叔&quot;"></p><p>没错，他就是一只丑萌的田园猫。</p><h2 id="Personal-Targets-for-2018"><a href="#Personal-Targets-for-2018" class="headerlink" title="Personal Targets for 2018"></a>Personal Targets for 2018</h2><blockquote><p>Hi, 2018</p></blockquote><p>新的一年，个人目标的划分，还是类似的，不再这里铺开了，实现情况看明年show time ：）</p><ul><li>个人修养类</li><li>运动</li><li>理财（跑赢大盘）</li><li>读书（40本）</li><li>写作（专栏隔周更新）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://sinacloud.net/woodysblog/year-2017/DSC05035.jpg&quot; alt=&quot;&amp;quot;龙井路秋色&amp;quot;&quot;&gt;&lt;br&gt;（龙井路秋色 —— 摄于杭州龙井路 2017.12.03）&lt;/p&gt;
&lt;h2 id=&quot;P
      
    
    </summary>
    
    
      <category term="总结" scheme="http://wuyuying.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>当我在欧洲艺术馆遇到馆长</title>
    <link href="http://wuyuying.com/archives/eu-gallery/"/>
    <id>http://wuyuying.com/archives/eu-gallery/</id>
    <published>2017-10-05T12:15:45.000Z</published>
    <updated>2018-05-25T10:34:15.000Z</updated>
    
    <content type="html"><![CDATA[<figure><br><img alt="poster" src="http://sinacloud.net/woodysblog/blog/img-placeholder.jpg" data-src="http://sinacloud.net/woodysblog/eu-gallery/gallery-4.jpg"><br><figcaption>poster</figcaption><br></figure><p>原定今天的计划是去杭州图书馆借几本书，顺便去看个展，就是这个号称“不出杭州看遍欧洲艺术品”的展览哈，我之前也不太了解欧洲历史文化，纯粹去凑个热闹。</p><p>先来看镇店之宝之一 —— 《戴面纱的女人》by Giuseppe Croff，面纱做得特别薄特别真，女人闭眼的神情也刻画得惟妙惟肖。</p><figure><br><img alt="戴面纱的女人" src="http://sinacloud.net/woodysblog/blog/img-placeholder.jpg" data-src="http://sinacloud.net/woodysblog/eu-gallery/gallery-6.jpg"><br><figcaption>戴面纱的女人</figcaption><br></figure><p>看这个汉白玉《爷爷的喜悦》by DonatoBarcaglia，近距离看像真的一样，身上的细节特别清晰，爷爷老去的皮肤和身上的青筋，以及孙子的baby fat，栩栩如生。</p><figure><br><img alt="爷爷的喜悦" src="http://sinacloud.net/woodysblog/blog/img-placeholder.jpg" data-src="http://sinacloud.net/woodysblog/eu-gallery/gallery-2.jpg"><br><figcaption>爷爷的喜悦</figcaption><br></figure><p>这幅《哥伦布向天主教君主们敬献新大陆的宝藏》by Emanuel Gottlieb Leutze，超大一幅油画，配上一个无敌浮夸的画框，据闻每一角代表的是一块大陆，最后连在一起，象征和平。馆长说这幅画华盛顿美术馆馆长问她要了很久，希望结束这场展览之后，能转让给他，因为哥伦布是美洲大陆的英雄，这幅画在DC最合适了。</p><figure><br><img alt="哥伦布向天主教君主们敬献新大陆的宝藏" src="http://sinacloud.net/woodysblog/blog/img-placeholder.jpg" data-src="http://sinacloud.net/woodysblog/eu-gallery/gallery-3.jpg"><br><figcaption>哥伦布向天主教君主们敬献新大陆的宝藏</figcaption><br></figure><p>这位小姐姐太美了有木有，不仅仅是身上的衣服，如丝般顺滑还加透视，看她的眼睛，画的特别有神，无论走到哪，都感觉她在看着你~</p><figure><br><img alt="漂亮的小姐姐" src="http://sinacloud.net/woodysblog/blog/img-placeholder.jpg" data-src="http://sinacloud.net/woodysblog/eu-gallery/gallery-5.jpg"><br><figcaption>漂亮的小姐姐</figcaption><br></figure><p>万万没想到，非常有收获，不仅仅是了解了这些艺术品背后千回百转的故事，更多的是折服于馆长的个人魅力和情怀。</p><p>馆长的名字叫<strong>吴静</strong>，法籍华裔，是一个古董钟表鉴定师，也是一个收藏家。欧洲艺术馆从想法到落地实施，选场地、挑藏品、布展，她只用了一年左右的时间。非常了不起有木有，今天很幸运，刚好碰到她在现场解说，艺术品背后的故事很精彩，人特别亲切和有感染力，更重要的是，她在以自己的方式去做公益，给这个世界给将来留下些什么，就是这个艺术馆及其背后的精神。</p><p>下面是我在现场听到的忍不住鼓掌几个观点，分享给大家：</p><blockquote><p>我每天只睡4个小时，没有电话和微信的消息打扰，安静地鉴定古董钟表。很多朋友问我，为什么还要那么努力地工作，我已经不需要了。上天让我来到这个世界，是有任务的，我希望看到自己更多的可能性。</p></blockquote><p>想象一下，一个以个人名义开了个艺术馆的馆长，每一件艺术品都价值不菲，肯定是生活无忧。而每天只睡4个小时，她认为，睡眠不是算时间的，更重要的是大脑的休息，只要你觉得精神饱满，睡够了，就起来，不要在乎睡了多少个小时。也听得出来她对自己在做的事情（古董钟表鉴定师和收藏）的热爱，她微信封面和头像就特别帅气~</p><figure><br><img alt="古董钟表鉴定师" src="http://sinacloud.net/woodysblog/blog/img-placeholder.jpg" data-src="http://sinacloud.net/woodysblog/eu-gallery/IMG_7470.jpg"><br><figcaption>古董钟表鉴定师</figcaption><br></figure><blockquote><p>生前，为死后做事</p></blockquote><p>解说时呀，有不少市民问起，为什么要搞这个展览？</p><p>吴静馆长说，生前，为死后做事。她的回答，真心让我觉得敬佩，特别圈粉。</p><p>做公益，直接捐钱是最简单的方式，钱捐了然后被花光了，对个人的生活、发展或者对家庭、抑或对这个社会，可能就没有然后了。</p><p>而这个公益欧洲艺术馆，正是她对公益的理解和所付诸的行动，从idea到action，花了一年的时间，收集的这些展品、展品从法国到中国的运输（在海上漂了三个多月）、场馆的装修（罗浮宫的设计团队），到志愿者的招募（自己也会下场做解说员），再到将来的一些跟国外合作的艺术program/课程。</p><p>可以看得出来，是个大工程，工作量也非常庞大，令我们最惊讶的是，这个项目落地中国会遇到很多的难处，目前是没有得到政府的补贴和支持的，馆长自费开的一个艺术馆（也有越来越多受馆长的感染参与进来的民间朋友），进场免费，只是为了控制人数，需要提前预约。</p><p>馆长的想法简单而美好，希望这个公益艺术馆能把欧洲文化带到中国来，让市民们不用出国，就能看到这些艺术品的真品和感受到西方艺术文化。希望美院的学生，不再需要对着那些千篇一律从模子出来的、没有细节的雕塑写生，而是可以来杭州的欧洲艺术馆，坐在这些有几百年历史的汉白玉雕塑下，随便画。（馆里的艺术品会有绳子起简单的隔离作用，但大多都没有玻璃柜子，展品跟你只有一步之遥）</p><p>以上，就是我所看到的，一个充满正能量的女子，用自己的方式做公益，希望自己百年之后，在做的这件事情对这个世界带来一些不一样和价值。希望在国内推动欧洲艺术的发展，也是对祖国、对中法文化交流的回馈。真的让我觉得非常鼓舞和感动。</p><p>在过程中，有幸跟馆长有对话，关于数字化图书馆的。</p><p><code>小伍</code> 吴静女士，您刚提到希望更多人知道这里，以及想在国内普及欧洲艺术，但目前这个馆只在杭州有，您有考虑过把艺术馆线上化吗？譬如百度百科的数字博物馆。<br><code>馆长</code> 嗯，当然是有的，知道的人肯定越多越好。可惜我从小在法国长大，这个项目在中国落地很难，虽然我带来了很多的收藏品，这些收藏品都很有价值，可惜我太不认识这方面的朋友。<br><code>小伍</code> 刚好，我认识了解这个百科数字图书馆的同学，我可以介绍你们认识，看能不能达成合作，把这个公益艺术馆搬到线上，让更多的国民知道，传播效果也许会更好。<br><code>馆长</code> 太好了，我们很需要，先谢谢你，回头我让助理跟你留下联系信息。</p><p>万万没想到，解说结束之后，我加了吴静女士的微信，感觉超亲切，刷了一遍她的朋友圈，再次被圈粉，超正能量，很多事情亲力亲为，感觉看到了另一个世界，真是应验了那句话 —— </p><blockquote><p>比你有才华、比你有钱、比你美的人，还比你拼，你还有什么理由不努力！</p></blockquote><p>真心希望有一天能看到欧洲艺术馆在百科的数字图书馆出现，推广给更多人民群众，独乐乐不如众乐乐嘛，那我这个撮合的媒人也会觉得功德无量啦，哈哈，也感谢我女神<strong>阮瑜</strong>把一个这么棒的产品带到这个世上，和百科美女<strong>小文子</strong>给我提供的帮助。</p><p>互联网产品推动传统行业的进步~ 我在工作过程中，无论是百度还是阿里，遇到过很多这样有情怀对社会有贡献的产品，不管我有没有参与其中，这样的好东西，我会不遗余力的在合适的场景推荐给合适的人。</p><p>最后，据我所知，欧洲艺术馆<strong>紧缺志愿者</strong>，在杭州的同学们可以联系一下，艺术馆会开3年，一直都会招募志愿者的，在这也帮忙打个广告，希望如果周边有朋友有意愿的话，赶紧联系一下~ </p><p>其实尤其对于美院的学生，这样的机会非常难得和珍贵，如果你是美院学生，又或者是辅导员，可以合作个项目啥的，一方面解决馆里缺志愿者的问题，另一方面可以近距离的接触著名收藏家以及她的珍藏艺术品，双赢~</p><p><strong>那么好的欧洲艺术馆，在杭的朋友，怎么能不去捧场呢！？</strong></p><p>此处应该有艺术馆的相关信息：</p><p>电话：15988484200<br>邮箱：<a href="mailto:eupart@163.com" target="_blank" rel="noopener">eupart@163.com</a><br>地址：浙江省杭州市江干区　解放东路58号　杭州图书馆地下负一层</p><p>欧洲艺术馆的公众号（可以在上面预约参观）</p><figure><br><img alt="欧洲艺术馆公众号" src="http://sinacloud.net/woodysblog/blog/img-placeholder.jpg" data-src="http://sinacloud.net/woodysblog/eu-gallery/qrcode.jpg"><br><figcaption>欧洲艺术馆公众号</figcaption><br></figure><p>最后的最后，楼主丧心病狂的想发一则招聘广告：</p><p>上面有提到互联网推动传统行业的进步，其实阿里对社会也有非常多的贡献，其中我所在的团队CBU，就是这么个有情怀有理想有贡献的团队，我们的目标是 ——  让世界没有难做的生意。</p><p>总而言之，有理想有情怀有钱有面儿有我这么赞的同事，<strong>招2年或以上经验的靠谱前端</strong>，欢迎自荐或推荐朋友，很急，在线等！！！暂时没想法也欢迎来撩~</p><p>花名：姬无<br>EMAIL：<a href="mailto:jiwu.wyy@alibaba-inc.com" target="_blank" rel="noopener">jiwu.wyy@alibaba-inc.com</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure&gt;&lt;br&gt;&lt;img alt=&quot;poster&quot; src=&quot;http://sinacloud.net/woodysblog/blog/img-placeholder.jpg&quot; data-src=&quot;http://sinacloud.net/woodysblog/eu-ga
      
    
    </summary>
    
    
      <category term="life" scheme="http://wuyuying.com/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>年轻就要造起来</title>
    <link href="http://wuyuying.com/archives/taobao-maker-festival-2017/"/>
    <id>http://wuyuying.com/archives/taobao-maker-festival-2017/</id>
    <published>2017-07-11T14:48:07.000Z</published>
    <updated>2018-05-25T10:34:15.000Z</updated>
    
    <content type="html"><![CDATA[<figure><br><img alt="大门口" src="http://sinacloud.net/woodysblog/blog/img-placeholder.jpg" data-src="http://sinacloud.net/woodysblog/taobao-maker-festival/entry-1.jpg"><br><figcaption>大门口</figcaption><br></figure><p>2017淘宝造物节 —— 年轻就要造起来！</p><p>我之前不知道有造物节，可能是因为我不在杭州，又或者媒体报道得也不多。今年的邀请函太吸引了，还有阿里内网、朋友圈、淘宝多个渠道以及各种公号的报道，尤其是黑科技浓浓的Tao Cafe无人便利店（我老爸都来问我知不知道这个店，宣传得太到位了），想不感兴趣都不行，拿到今天的票，就请假跑来“造”一下。</p><p>一进来有种夜店feel有木有，恰逢汪涵过来主持，中间舞台被包围了，人超多，远远的拍照好了。</p><figure><br><img alt="舞台" src="http://sinacloud.net/woodysblog/blog/img-placeholder.jpg" data-src="http://sinacloud.net/woodysblog/taobao-maker-festival/entry-2.jpg"><br><figcaption>舞台</figcaption><br></figure><figure><br><img alt="地上投射的造物节logo" data-src="http://sinacloud.net/woodysblog/taobao-maker-festival/entry-3.jpg"><br><figcaption>地上投射的造物节logo</figcaption><br></figure><p>进来以后，走了半圈，找不到我最想去的无人店呀……路盲找小二问，才发现Tao Cafe在刚才检票入口的旁边，白排队进来了，还绕了大半圈，简直惊呆了，你们感受一下这条长龙，我在队尾。以前我看到排队买喜茶的人很傻，没有好喝到让我等N个小时，现在发现如果有我很想要的东西的时候，虽然不太乐意，但还是等一下吧，Tao Cafe，我来了。</p><figure><br><img alt="无人便利店的排队长龙" src="http://sinacloud.net/woodysblog/blog/img-placeholder.jpg" data-src="http://sinacloud.net/woodysblog/taobao-maker-festival/store-waiting.jpg"><br><figcaption>无人便利店的排队长龙</figcaption><br></figure><p>半小时后，我在这~ 请看大屏幕，这个妹子在出门结账的时候，就是那么自信，自带光芒的，笑死 &gt;3&lt;</p><figure><br><img alt="无人便利店的排队长龙（半小时后）" src="http://sinacloud.net/woodysblog/blog/img-placeholder.jpg" data-src="http://sinacloud.net/woodysblog/taobao-maker-festival/store-waiting-2.jpg"><br><figcaption>无人便利店的排队长龙（半小时后）</figcaption><br></figure><p>足足一小时，我终于要刷脸进来无人便利店，这个门禁，很犀利，除了刷淘宝二维码之外，可能还需要刷脸，我看有的妹子进来之前，要把头发扎起来，不然过不了。</p><figure><br><img alt="无人便利店的门禁" src="http://sinacloud.net/woodysblog/blog/img-placeholder.jpg" data-src="http://sinacloud.net/woodysblog/taobao-maker-festival/store-entry.jpg"><br><figcaption>无人便利店的门禁</figcaption><br></figure><p>进来后，直奔小卖部，这里招牌是”招牌淘咖啡“，呃，不推荐啦，我没有喝过混一点果酱（貌似是黄桃味）的咖啡，虽然味道还可以，但是总有种”黑暗料理“的感觉，还是点普通咖啡吧。</p><figure><br><img alt="搬砖的排队去买咖啡" src="http://sinacloud.net/woodysblog/blog/img-placeholder.jpg" data-src="http://sinacloud.net/woodysblog/taobao-maker-festival/store-wu.jpg"><br><figcaption>搬砖的排队去买咖啡</figcaption><br></figure><figure><br><img alt="淘公仔" src="http://sinacloud.net/woodysblog/blog/img-placeholder.jpg" data-src="http://sinacloud.net/woodysblog/taobao-maker-festival/store-figure.jpg"><br><figcaption>淘公仔</figcaption><br></figure><p>无人便利店的概念很好，门禁、进门后的用户信息都可以捕抓到，真的非常有科技感、未来感。不过貌似暂未满足商用需求，我去买咖啡时，虽然有刷脸有AR，但是最后我是用支付宝码付款的；小伙伴买了个环保袋，走了两次付款通道，第一次说订单没下，第二次还是没有订单，最后在出口人工结账。两个情况的理由都是人太多，网络响应比较慢。[ 以上谨属本次体验的个人观点。我相信不久的未来，阿里的无人店会推广落地，再一次改变我们的生活 ]</p><p>呼呼，等了半天，进去逛了十分钟就出来了，满足好奇心。出来之后，找到一只大型淘公仔，还是要求合照啦~</p><figure><br><img alt="淘公仔合照" src="http://sinacloud.net/woodysblog/blog/img-placeholder.jpg" data-src="http://sinacloud.net/woodysblog/taobao-maker-festival/tao-smile.jpg"><br><figcaption>淘公仔合照</figcaption><br></figure><p>再次进场，逛各种店噜。各种名店、潮店都装修得很有心思，比较有特色。</p><p>我来之前，以为只是个小集市（一个淘宝店铺的展览会），逛逛就完事了。事实上不是这样的，人手一本小册子，上面有各种任务，大家除了逛逛逛、买买买、拍拍怕，还可以到各个店做任务、集印章、拿奖品。个人感觉很好，明年还想再来。</p><p>废话不多说，上图。</p><p>天猫精灵，智能音箱，小二给我们演示，大致还是灵敏的，哈哈，感兴趣的大家可以上天猫看看。</p><figure><br><img alt="天猫精灵的平板支撑" src="http://sinacloud.net/woodysblog/blog/img-placeholder.jpg" data-src="http://sinacloud.net/woodysblog/taobao-maker-festival/tmall-plank.jpg"><br><figcaption>天猫精灵的平板支撑</figcaption><br></figure><figure><br><img alt="环保的快递盒" src="http://sinacloud.net/woodysblog/blog/img-placeholder.jpg" data-src="http://sinacloud.net/woodysblog/taobao-maker-festival/green-action.jpg"><br><figcaption>环保的快递盒</figcaption><br></figure><p>One的展台……木有发现这个展馆跟”一个“有啥关系。</p><figure><br><img alt="红" src="http://sinacloud.net/woodysblog/blog/img-placeholder.jpg" data-src="http://sinacloud.net/woodysblog/taobao-maker-festival/wu-hong.jpg"><br><figcaption>红</figcaption><br></figure><figure><br><img alt="卖包的小店" src="http://sinacloud.net/woodysblog/blog/img-placeholder.jpg" data-src="http://sinacloud.net/woodysblog/taobao-maker-festival/bag-store.jpg"><br><figcaption>卖包的小店</figcaption><br></figure><figure><br><img alt="卖书的小罐头" src="http://sinacloud.net/woodysblog/blog/img-placeholder.jpg" data-src="http://sinacloud.net/woodysblog/taobao-maker-festival/bookshop.jpg"><br><figcaption>卖书的小罐头</figcaption><br></figure><p>这位苏州的老奶奶说，黑布上的每一个图案，她都要绣一天，店里都是各种各样的刺绣品，真是不容易啊~</p><figure><br><img alt="刺绣的老奶奶" src="http://sinacloud.net/woodysblog/blog/img-placeholder.jpg" data-src="http://sinacloud.net/woodysblog/taobao-maker-festival/grandma.jpg"><br><figcaption>刺绣的老奶奶</figcaption><br></figure><figure><br><img alt="另外一个手工的小锦囊" src="http://sinacloud.net/woodysblog/blog/img-placeholder.jpg" data-src="http://sinacloud.net/woodysblog/taobao-maker-festival/little-bag.jpg"><br><figcaption>另外一个手工的小锦囊</figcaption><br></figure><figure><br><img alt="小灯" src="http://sinacloud.net/woodysblog/blog/img-placeholder.jpg" data-src="http://sinacloud.net/woodysblog/taobao-maker-festival/light.jpg"><br><figcaption>小灯</figcaption><br></figure><p>逛完西市，我们来到了北街，这边的店有比较科技感的也有比较怀旧的。</p><figure><br><img alt="北街" src="http://sinacloud.net/woodysblog/blog/img-placeholder.jpg" data-src="http://sinacloud.net/woodysblog/taobao-maker-festival/north-area.jpg"><br><figcaption>北街</figcaption><br></figure><figure><br><img alt="杂货铺" src="http://sinacloud.net/woodysblog/blog/img-placeholder.jpg" data-src="http://sinacloud.net/woodysblog/taobao-maker-festival/store-else.jpg"><br><figcaption>杂货铺</figcaption><br></figure><figure><br><img alt="匠心" src="http://sinacloud.net/woodysblog/blog/img-placeholder.jpg" data-src="http://sinacloud.net/woodysblog/taobao-maker-festival/workshop.jpg"><br><figcaption>匠心</figcaption><br></figure><figure><br><img alt="电影院" src="http://sinacloud.net/woodysblog/blog/img-placeholder.jpg" data-src="http://sinacloud.net/woodysblog/taobao-maker-festival/cinema.jpg"><br><figcaption>电影院</figcaption><br></figure><figure><br><img alt="猫大王" src="http://sinacloud.net/woodysblog/blog/img-placeholder.jpg" data-src="http://sinacloud.net/woodysblog/taobao-maker-festival/cat.jpg"><br><figcaption>猫大王</figcaption><br></figure><p>哎，由于时间关系，我们只逛了舞台左边的西市和北街，左边的东市和南街根本没逛……好可惜，最后被广播赶走了，才5点半，说好的开到6点呢~</p><p>最后，po两张我比较喜欢的比较有感觉的，再一次读一下今年造物节的slogan，这也应该是我们生活的态度：</p><blockquote><p>年轻就要造！！！</p></blockquote><figure><br><img alt="毒鸡汤" src="http://sinacloud.net/woodysblog/blog/img-placeholder.jpg" data-src="http://sinacloud.net/woodysblog/taobao-maker-festival/black-white.jpg"><br><figcaption>毒鸡汤</figcaption><br></figure><figure><br><img alt="造" src="http://sinacloud.net/woodysblog/blog/img-placeholder.jpg" data-src="http://sinacloud.net/woodysblog/taobao-maker-festival/zao.jpg"><br><figcaption>造</figcaption><br></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure&gt;&lt;br&gt;&lt;img alt=&quot;大门口&quot; src=&quot;http://sinacloud.net/woodysblog/blog/img-placeholder.jpg&quot; data-src=&quot;http://sinacloud.net/woodysblog/taobao-m
      
    
    </summary>
    
    
      <category term="life" scheme="http://wuyuying.com/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Begin Again, 2017</title>
    <link href="http://wuyuying.com/archives/begin-again-2017/"/>
    <id>http://wuyuying.com/archives/begin-again-2017/</id>
    <published>2017-06-01T12:40:30.000Z</published>
    <updated>2018-05-25T10:34:15.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://sinacloud.net/woodysblog/blog/img-placeholder.jpg" data-src="http://sinacloud.net/woodysblog/blog/begin-again-ali-day.jpg"></p><p>想跟大家分享我找工作的故事。</p><p>今天是2017年5月份的最后一个工作日，去年的这个时候，我在办理离职手续。从离职到重新回到工作中，真是整整一年呀，原来所谓的间隔年是这么回事。</p><p>去年5月底，我在杭州，玩了半个月，出国前来杭州，并不是偶然，当时我在想，一年后我会再回来的，来阿里巴巴，我想先来看看这个未来工作的城市。</p><p>去年6月中旬，坐上飞机去了南半球的新西兰，体验和收获了各种，今年1月中旬回来了，从开始到结束，跨度了大概8个月。这大半年里面，大部分时间都在玩，间断的有1个多月时间有做临时工，做kiwi fruit包装，上班不用带脑子，下班后也不需要把工作带回家，感觉非常神奇和放松，收入水平跟大家聊过了，最低工资大概2w RMB，会有种智商不用在线、站着就赚钱的感觉，是一种从来没有体验过的工作方式。</p><p>很多小伙伴问我，你过去是做专业对口的工作么？在这里再解释一下，打工度假签证有规定不能为一个老板工作超过3个月，这项就限制了一般只能打季节工。何况做临时工的好处是想干就干，想不干就不干，上半个月班，赚够钱了，接着玩3个月，完全ok，这样比较灵活，始终我是去玩的，不是为了用劳动力换钱的，对吧？</p><p>回来以后的生活，各种约约约，持续到过年。</p><p>好像也不能一直这么hea（不羁放纵）下去，那就找工作吧。我去翻查了下印象笔记的工作日志，原来从2017.1.31（年初四）我就开始准备了，直到5.2我才收到阿里的正式的offer邮件，找工作花4个月？这几个月我都在干嘛呀，哈哈，找工作需要那么长的时间么？当然并不需要，以下分享一下我的时间表。</p><h2 id="找回感觉的2月"><a href="#找回感觉的2月" class="headerlink" title="找回感觉的2月"></a>找回感觉的2月</h2><p>2月份，我给自己列了一个书单和学习计划，一个月的准备时间。这段时间是我感到心理压力最大的时候，真的好难好累，看吧，出来混，还是要还的。</p><p>作为一枚工作了近3年并断产了大半年的页面仔，我没有去看面经和一些剑指offer的书哈，说出来也不怕大家笑，我看了一大堆前端基础教科书，如《JavaScript高级程序设计》、《无懈可击的WEB设计》和《图解HTTP》等等，大概11本。<del>还有看了廖雪峰、阮一峰和Youtube上的Max、Wes、The Net Ninja等老师的视频教程，包括Vue.js 2、ReactJS、Webpack、ES6、CSS Flex、NodeJS/Express等等。</del>以上看的这些啊，都是浅尝即止，不精通，只追求“看过”。算是温故知新吧，这段时间也整理了以前的项目笔记。</p><p>开始调整生物钟嘛，每天生活规律，从9点开始，晚上11点左右结束，没有周末。看书，看累了写会代码，写累了看会儿教程，接着再写会儿代码……晚餐后出门散步1小时，日间不定期被我爸妈骚扰，陪聊和看电视剧，这样都能完成我的计划，需要很强的定力，有木有。</p><p>前端圈真是个坑，瞬息万变，我真是out太多了，永远有学不完的东西，知道得越多，发现自己知道的越少。不过声明一下哈，我并不觉得新技术不断出现，我们就得见一个爱一个，学到新东西后恨不得武装到自己写的每一行代码里。不是这样的，保持热情拥抱新技术，工作中只用合适的，不盲目追求最新的，始终技术转化成什么才是我们最关心的。</p><p>现在我回想，这个2月的学习计划对面试有帮助么？有一点帮助，但不大，看的都没有被问到好吗？因为面试问题太随机了，每个面试官关注点都不一样，抓着简历和项目问，我懂的就懂，不懂的还是不懂，所以2月份对于我来说，不能说是面试准备，应该算是个仪式，生活要有仪式感嘛，是一个重新开始的仪式，仅此而已。</p><h2 id="开始面试的3月"><a href="#开始面试的3月" class="headerlink" title="开始面试的3月"></a>开始面试的3月</h2><p>下面不写面经哈，只谈感受。</p><p>一般来说，老板要什么样的人啊？技术靠谱、有团队精神、能扛事有责任感的……</p><p>不管条件是什么，嘘~ 我就是。况且我还是个相貌气质佳、有故事的女同学，简直了，哪个boss看到我的简历，打电话来聊几句人生，就应该直接发offer了。要不是裸辞去了gap year，我肯定早就被某家棒棒的公司收了，好不好？磨叽什么呢~ 赶紧把我收了才对嘛！</p><p>以上是我的幻想，现实却是很骨感。</p><p>想起来也是搞笑，@唐工（曾任职百度、现任职腾讯的测试大神）在职想跳槽的时候，一天安排几家公司，密密麻麻地面试，我现在是全职求职的，但是投出去的简历少之又少，一周或者两周只面一个团队，低频到没朋友，所以求职时间拖得很长。</p><p>我的想法是这样的。投简历之前，我想先了解对方是做什么的，自己感不感兴趣，顺便控制台调试一下对方的页面，代码咋样，用得是什么技术栈、构建工具，基本上能摸个差不多，喜欢了才给简历。</p><p>整个求职过程，我给3家公司投过简历（捂脸），A创业公司、杭州猪厂和阿里。</p><p>A创业公司，有一个我喜欢的百度大神，做直播的，一面谈了15分钟，聊新老技术升级的坑。</p><p>猪厂，喜欢他家用心做的产品（情怀），一面谈了40分钟，第一次遇到纯跟我聊基础知识的，HTML/CSS/JS一题一题问的女面试官。</p><p>两家公司的一面我都过了，但对方邀请我去上海、杭州进行二面的时候，我怂了，我发现当下最爱的始终是阿里，你们可以得到了我的简历，但得不到我的心。害怕对方真的发offer（我应该是自作多情了，哈哈，人家没说会发offer）。我想对这两家公司的面试官说声抱歉，浪费了他们的时间，因此后来我再也没有给其他团队投过简历。</p><p>这段时间，我大概跟10位阿里前辈聊过，每一次的感觉不太一样，但能感受到阿里面试官的平均水平相当高。</p><p>遇到过，第一轮就对我压力面，面了一个多小时，花式吊打我的简历，问到我说不知道为止，但我非常佩服这位面试官，他在那么短的时间内问的问题的覆盖面能够那么深那么广；</p><p>遇到过，上来就吐槽我的自我介绍毫无信息量的主管，我说了答不出的问题，对方还是一再追问并质疑我的专业背景和技术能力，这也是唯一一次我不知道怎么接话，因为我feel到对方在发脾气，没法继续聊；[其实觉得我不合适，默默打个叉，尽快结束面试就可以了]</p><p>遇到过，四轮技术面，其中一轮我还开视频直播写了一小时代码；[其实每轮内容都差不多，感觉没必要四面技术]</p><p>遇到过，我花了很长时间回答一道题目，面试官说答得很全面，你是不是专门准备过的；[我确实准备过，不是因为这是常见面试题，而是我觉得里面涵盖自己应该了解的知识点]</p><p>遇到过，一面技术摸底，二三面看人品、聊人生的。[这是最符合我想象的面试场景]</p><p>万万没想到，差不多每次都聊得那么开心，前3个部门还是拒了我，拿到offer的是我面的第4个部门。</p><p>凭着迷之自信，我几乎不会怀疑自己行不行，何况面试那么多轮，没有挂在压力技术面，说明并不是技术问题。但是换谁被拒3次也会不开心的，当我有点心灰意冷的时候，@猩爷给我发了这么一段话，摘自《巨婴国》：</p><blockquote><p>成熟的心智，需要基本的信心——我相信持续的投入会转化出我想要的东西，虽然这事不一定会发生，但我越投入，可能性就越大，并且在投入过程中，我的心得到了淬炼。</p></blockquote><p>3月份大概收到过二十多个阿里团队的邀约，我在面第4个部门时，还有另外3个阿里的团队在内推系统等我的简历释放。是啊，屡战屡败，屡败屡战，但我没想放弃治疗，打算一直面阿里，直到加入合适的团队为止。</p><p>说起这事，@唐工说看到我这样，她问过自己，有没有一家公司能让她屡败屡战，被拒3遍还要接着面？并没有。</p><p>我呢，为什么我要那么执着？为了“梦想本人”马老师，为了盛名在外的阿里前端大神，为了圆大学没有完成的淘宝梦，还是仅仅为了兑现一年前自己的承诺？为什么要来，我也分不清了，我只知道我要来阿里，做我觉得对的事情 —— 做出更好的东西帮助/影响到更多的人。</p><h2 id="等待的4、5月"><a href="#等待的4、5月" class="headerlink" title="等待的4、5月"></a>等待的4、5月</h2><p>gap year后的求职季，止于我现在的团队 —— CBU，让大家见笑了，我的title是<code>新零售技术事业群-此处省略一万字-前端开发工程师</code>。</p><p>有个非常有趣的插曲，口头offer我足足等了两周，由于部门架构调整，原本的HR去了别的地方，我的offer被遗忘了，后来接到新HR姐姐的电话，我的团队、title都变了，所以入职之前，我对新工作一无所知，只知道自己要去阿里B站（1688.com），用@清姐的话说，我现在是搞批发的，哈哈，以后我会告诉你们我在做的是什么。</p><p>说实话，我从来没想过自己会加入大市场前端，真是缘分，我遇到了一个很特别的老大和一群很nice的小伙伴们，挺好的。我相信，一切便是最好的安排，这里会因我而不同，我也会在这里变成一个更好的自己。</p><p>辛苦您终于看完了，谨以此图聊表谢意，晚安 ：）</p><p><img src="http://sinacloud.net/woodysblog/blog/begin-again-ali-night.jpg" alt=""></p><p>2017.05.31<br>写于杭州滨江区江南大道魔方公寓</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://sinacloud.net/woodysblog/blog/img-placeholder.jpg&quot; data-src=&quot;http://sinacloud.net/woodysblog/blog/begin-again-ali-day.jp
      
    
    </summary>
    
    
      <category term="life" scheme="http://wuyuying.com/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>2017年Web开发者的技能蓝图</title>
    <link href="http://wuyuying.com/archives/2017-roadmap/"/>
    <id>http://wuyuying.com/archives/2017-roadmap/</id>
    <published>2017-04-22T13:54:29.000Z</published>
    <updated>2018-05-25T10:34:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Medium看到一篇文章，分享了github网友<a href="https://github.com/kamranahmedse" target="_blank">@kamranahmedse</a>发布的<a href="https://github.com/kamranahmedse/developer-roadmap" target="_blank">developer-roadmap</a>。</p><p>非常有意思，自己记录一下，也顺便跟大家分享~</p><p>大致分为3个发展方向，前端、后端和运维。<br>2017年，作为一枚web开发人员，roadmap提到的技术，你都了解么 ：）</p><p><img src="http://sinacloud.net/woodysblog/2017-web-dev-roadmap/web-developer.png" alt="&quot;web developer&quot;"></p><hr><h2 id="front-end"><a href="#front-end" class="headerlink" title="front-end"></a>front-end</h2><p><img src="http://sinacloud.net/woodysblog/2017-web-dev-roadmap/front-end.png" alt="&quot;front-end developer roadmap in 2017&quot;"></p><hr><h2 id="back-end"><a href="#back-end" class="headerlink" title="back-end"></a>back-end</h2><p><img src="http://sinacloud.net/woodysblog/2017-web-dev-roadmap/back-end.png" alt="&quot;back-end developer roadmap in 2017&quot;"></p><hr><h2 id="devOps"><a href="#devOps" class="headerlink" title="devOps"></a>devOps</h2><p><img src="http://sinacloud.net/woodysblog/2017-web-dev-roadmap/devOps.png" alt="&quot;dev-ops developer roadmap in 2017&quot;"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Medium看到一篇文章，分享了github网友&lt;a href=&quot;https://github.com/kamranahmedse&quot; target=&quot;_blank&quot;&gt;@kamranahmedse&lt;/a&gt;发布的&lt;a href=&quot;https://github.com/kamr
      
    
    </summary>
    
    
      <category term="front-end" scheme="http://wuyuying.com/tags/front-end/"/>
    
      <category term="back-end" scheme="http://wuyuying.com/tags/back-end/"/>
    
      <category term="devops" scheme="http://wuyuying.com/tags/devops/"/>
    
      <category term="roadmap" scheme="http://wuyuying.com/tags/roadmap/"/>
    
  </entry>
  
  <entry>
    <title>悄悄发布一个hexo的npm模块</title>
    <link href="http://wuyuying.com/archives/npm-publish/"/>
    <id>http://wuyuying.com/archives/npm-publish/</id>
    <published>2017-04-03T03:52:02.000Z</published>
    <updated>2018-05-25T10:34:15.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>hexo-generator-index-plus</strong>，这是什么东东？其实就是hexo博客生成器的一个文章排序插件，基于默认插件fork的，添加按文章<strong>置顶</strong>和<strong>二次编辑的更新时间</strong>排序的功能。</p><p>沙发留给github和npmjs~</p><p>Github: <a href="https://github.com/YuyingWu/hexo-generator-index-plus" target="_blank" rel="noopener">YuyingWu/hexo-generator-index-plus</a><br>npm: <a href="https://www.npmjs.com/package/hexo-generator-index-plus" target="_blank" rel="noopener">hexo-generator-index-plus</a></p><p>最简单粗暴的Installation：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="keyword">install</span> hexo-generator-<span class="keyword">index</span>-plus <span class="comment">--save</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>当然要完全替换掉默认的index生成器还不止这一步啦，还要干掉默认的npm模块和更新hexo-cli里面assets的引用~具体还是看看<a href="https://www.npmjs.com/package/hexo-generator-index-plus#installation" target="_blank" rel="noopener">readMe</a>啰。</p><h2 id="怎么实现？"><a href="#怎么实现？" class="headerlink" title="怎么实现？"></a>怎么实现？</h2><p>基于默认的hexo-generator-index的fork~所以大致跟原生的一致，config不一样，内部实现不一样。</p><p>实现代码还是不聊了，原理是利用数组处理的sort函数来做升降序排列而已啦，献丑献丑。</p><p>而关键字的优先级是这么排的，让文章按照<code>top</code>（置顶） -&gt; <code>updateDate</code>（二次更新时间） -&gt; <code>date</code>的降序排列~ 为什么我们需要<code>top</code>或者<code>updateDate</code>呢？</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">title:</span> Blog Log</span><br><span class="line"><span class="symbol">date:</span> <span class="number">2015</span><span class="number">-04</span><span class="number">-23</span> <span class="number">00</span>:<span class="number">35</span>:<span class="number">45</span></span><br><span class="line"><span class="symbol">updateDate:</span> <span class="number">2017</span><span class="number">-04</span><span class="number">-02</span> <span class="number">15</span>:<span class="number">13</span>:<span class="number">00</span></span><br><span class="line"><span class="symbol">top:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="top【No-1-Priority】"><a href="#top【No-1-Priority】" class="headerlink" title="top【No.1 Priority】"></a>top【No.1 Priority】</h3><p>所谓的“置顶”，越大的数值排得越前，写了一篇棒棒的文章当然想让它永远在前排 ^0^</p><h3 id="updateDate【No-2-Priority】"><a href="#updateDate【No-2-Priority】" class="headerlink" title="updateDate【No.2 Priority】"></a>updateDate【No.2 Priority】</h3><p>默认按创建时间<code>date</code>排序，但达不到针对偶尔编辑的某篇文章，希望把它顶上来的需求（但不是置顶，还是按修改时间排序就好了）。</p><p>所以我添加了针对<strong>二次编辑更新时间</strong>的排序，添加了一个<code>updateDate</code>，跟原生的<code>updated</code>区分开。我看默认有个<code>updated</code>属性，但是貌似是系统记录文章编辑保存的时间，人肉编辑也没有效，所以还是自己加一个吧。</p><h3 id="date【Default】"><a href="#date【Default】" class="headerlink" title="date【Default】"></a>date【Default】</h3><p>原生generator支持的创建日期排序。</p><h3 id="more-to-do"><a href="#more-to-do" class="headerlink" title="more to do"></a>more to do</h3><ul><li>目前只按照各个关键属性的默认降序，后续会加一个order_by支持自定义升降序的配置。</li><li>完成代码测试</li></ul><h2 id="发布npm模块"><a href="#发布npm模块" class="headerlink" title="发布npm模块"></a>发布npm模块</h2><p>好惭愧，第一次在社区发布module，把这些步骤记录下来，方便以后给自己备忘，嘻嘻。</p><h3 id="事前准备"><a href="#事前准备" class="headerlink" title="事前准备"></a>事前准备</h3><ol><li>去<a href="https://www.npmjs.com" target="_blank" rel="noopener">npm社区</a>注册一个账号</li><li>github创建repository</li><li>初始化模块，执行<code>npm init</code>，系统会有很多提示的，不想输入一直按回车就可以，初始化成功后，会生成<code>package.json</code></li></ol><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>i. 设置npm用户</p><p>这个账号会被添加到npm本地的配置中，用来发布module用，成功后用户信息会被存到<code>~/.npmrc</code>。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ npm adduser</span><br><span class="line"></span><br><span class="line"><span class="symbol">Username:</span> your name</span><br><span class="line"><span class="symbol">Password:</span> your password</span><br><span class="line"><span class="symbol">Email:</span> your email address</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行下面命令可以查看当前用户</span></span><br><span class="line">$ npm whoami</span><br></pre></td></tr></table></figure><p>ii. 设定版本号</p><p><code>package.json</code>里有个字段<code>version</code>，设定模块版本号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm publish</span></span><br></pre></td></tr></table></figure><p>那么版本号规则一般是怎样的呢？npm社区有语义化版本的规则的~</p><p>版本格式：<strong>主版号.次版号.修订号</strong>，递增规则如下：</p><blockquote><p>主版号：当你做了不相容的 API 修改，<br>次版号：当你做了向下相容的功能性新增，<br>修订号：当你做了向下相容的问题修正。</p></blockquote><p>由于时间关系，在<code>npm publish</code>后，我们的模块就发布成功了，快到没朋友，到<a href="https://www.npmjs.com" target="_blank" rel="noopener">npm社区</a>自己的主页上就能看到啦~ </p><p>还蛮好玩的有木有，大家积极分享自己的模块吧 ：）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;hexo-generator-index-plus&lt;/strong&gt;，这是什么东东？其实就是hexo博客生成器的一个文章排序插件，基于默认插件fork的，添加按文章&lt;strong&gt;置顶&lt;/strong&gt;和&lt;strong&gt;二次编辑的更新时间&lt;/strong&gt;排序的功能。&lt;/p&gt;
&lt;p&gt;沙发留给github和npmjs~&lt;/p&gt;
&lt;p&gt;Github: &lt;a href=&quot;https://github.com/YuyingWu/hexo-generator-index-plus&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;YuyingWu/hexo-generator-index-plus&lt;/a&gt;&lt;br&gt;npm: &lt;a href=&quot;https://www.npmjs.com/package/hexo-generator-index-plus&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hexo-generator-index-plus&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最简单粗暴的Installation：&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ npm &lt;span class=&quot;keyword&quot;&gt;install&lt;/span&gt; hexo-generator-&lt;span class=&quot;keyword&quot;&gt;index&lt;/span&gt;-plus &lt;span class=&quot;comment&quot;&gt;--save&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="blog" scheme="http://wuyuying.com/tags/blog/"/>
    
      <category term="hexo-generator-index-plus" scheme="http://wuyuying.com/tags/hexo-generator-index-plus/"/>
    
      <category term="hexo-plugin" scheme="http://wuyuying.com/tags/hexo-plugin/"/>
    
      <category term="npm" scheme="http://wuyuying.com/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>谈谈怎么在不熟悉上下文的情况下debug</title>
    <link href="http://wuyuying.com/archives/debug-talk/"/>
    <id>http://wuyuying.com/archives/debug-talk/</id>
    <published>2017-02-27T13:56:02.000Z</published>
    <updated>2018-05-25T10:34:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>跟大家分享一个最近调bug的故事，在不熟悉架构、业务上下文、编程语言、调试环境等等的情况下，遇到问题时，我们可以怎么解决。简单的来说，路过一个你喜欢的站点，发现页面有bug，想帮忙修，怎么办？<br><a id="more"></a></p><hr><p>偶然访问了阿里<a href="https://ant.design/" target="_blank" rel="noopener">Ant Design</a>，默认是英文版本，我看右上角有个切换到中文的按钮，就过去一点，咦，跳到错误页了~</p><p><img src="http://cdn.sinacloud.net/woodysblog/articles/en-to-zh.png" alt=""></p><p>职业习惯，我在chrome和Safari都测了一下，稳定浮现，bug~<br>恰好这个站点是开源的，那就去github fork一下，把这个bug修了吧。</p><p>原href：<a href="https://ant.design/" target="_blank" rel="noopener">https://ant.design/</a><br>正确跳转href：<a href="https://ant.design/index-cn" target="_blank" rel="noopener">https://ant.design/index-cn</a><br>Chrome下跳转到：<a href="https://ant.design/index-cn/ant.design/" target="_blank" rel="noopener">https://ant.design/index-cn/ant.design/</a><br>Safari下跳转到：<a href="https://index-cn/ant.design/" target="_blank" rel="noopener">https://index-cn/ant.design/</a></p><h2 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h2><p>咋眼一看，我以为是程序猿或者PM在配置时写错了，于是我打开console，检查这个按钮的元素，看有什么关键字（url、data-属性、id、特别的classname等）</p><p><img src="http://cdn.sinacloud.net/woodysblog/articles/antd-button.png" alt=""></p><p>没有链接，看来是js控制的，那就去翻源码吧~问题来了，怎么翻呢？</p><p>从上图看，这个<code>button</code>没什么特色，不过，仔细一看，有个不太普通的类名，<code>ant-btn-ghost</code>，那我们就去模板那搜<code>ghost</code>吧！</p><p><img src="http://cdn.sinacloud.net/woodysblog/articles/antd-folder.png" alt=""></p><p>从目录可以看出来，整个源是非常庞大的，除了官网页面、文档，还有Ant Design UI库的源码。凭”直觉“，到<code>site</code>文件夹搜<code>ghost</code>，因为那么多文件夹，就site比较像是放官网的。</p><p>Bingo!!!</p><p><img src="http://cdn.sinacloud.net/woodysblog/articles/antd-search.png" alt=""></p><h3 id="button"><a href="#button" class="headerlink" title="button"></a>button</h3><p>看看<code>button</code>相关的代码，虽然我不太懂React.js，但不难看出来，<code>button</code>的<code>click</code>事件处理函数<code>handleLangChange</code>就是我们要找的逻辑~</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">className</span>=<span class="string">"lang"</span> <span class="attr">type</span>=<span class="string">"ghost"</span> <span class="attr">size</span>=<span class="string">"small"</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleLangChange&#125;</span> <span class="attr">key</span>=<span class="string">"lang"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FormattedMessage</span> <span class="attr">id</span>=<span class="string">"app.header.lang"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="handleLangChange"><a href="#handleLangChange" class="headerlink" title="handleLangChange"></a>handleLangChange</h3><p>接下来去看<code>handleLangChange</code>函数，幸好代码不是很多，简单扫一眼~</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">handleLangChange</span> = <span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  const pathname = <span class="keyword">this</span>.props.location.pathname;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (utils.isLocalStorageNameSupported()) &#123;</span><br><span class="line">    localStorage.setItem(<span class="string">'locale'</span>, utils.isZhCN(pathname) ? <span class="string">'en-US'</span> : <span class="string">'zh-CN'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  location.href = location.href.replace(</span><br><span class="line">    location.pathname,</span><br><span class="line">    utils.getLocalizedPathname(pathname, !utils.isZhCN(pathname)),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一句，变量声明，忽略；<br>第二段，localstorage，忽略；<br>第三段，replace，参数1是当前地址，参数2那段的<code>utils.getLocalizedPathname</code>是什么意思呢？</p><h3 id="getLocalizedPathname"><a href="#getLocalizedPathname" class="headerlink" title="getLocalizedPathname"></a>getLocalizedPathname</h3><p>在<code>site</code>文件夹再搜搜<code>getLocalizedPathname</code>，在<code>utils.jsx</code>找到了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getLocalizedPathname</span>(<span class="params">path, zhCN</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> pathname = path.startsWith(<span class="string">'/'</span>) ? path : <span class="string">`/<span class="subst">$&#123;path&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!zhCN) &#123; <span class="comment">// to enUS</span></span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/\/?index-cn/</span>.test(pathname) ? <span class="string">'/'</span> : pathname.replace(<span class="string">'-cn'</span>, <span class="string">''</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pathname === <span class="string">'/'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'/index-cn'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pathname.endsWith(<span class="string">'/'</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> pathname.replace(<span class="regexp">/\/$/</span>, <span class="string">'-cn/'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;pathname&#125;</span>-cn`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再轻轻扫一眼，可以发现函数<code>getLocalizedPathname</code>的作用是根据当前路径<code>path</code>与是否中文版本<code>zhCN</code>，返回对应path值。</p><p>经过上面的排查，我们基本定位切换中文的功能，涉及3个函数：</p><ul><li>handleLangChange</li><li>utils.isZhCN</li><li>utils.getLocalizedPathname</li></ul><p>上面只是跟大家分享<strong>问题定位</strong>的思路，当然不是看看就可以”盲调“啦，哪有辣么厉害，运行调试才是正解！下面开聊<strong>怎么调试和修bug</strong>。</p><h2 id="怎么调试和修bug"><a href="#怎么调试和修bug" class="headerlink" title="怎么调试和修bug"></a>怎么调试和修bug</h2><p>我在Github上看到有个<a href="https://github.com/ant-design/ant-design/wiki/Development" target="_blank" rel="noopener">开发指导</a>文档，上面写着这样可以预览调试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Fork and git clone.</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm start</span></span><br></pre></td></tr></table></figure><p>我clone到本地，执行<code>npm start</code>后，提示有个npm组件报错，导致编译失败~没办法在线预览和调试。</p><p>在这里我遇到两个问题：</p><ol><li>.jsx文件编译</li><li>运行环境不能在线调试 </li></ol><p>遇到事，咱不怕事，见招拆招就okay啦~</p><ol><li>把jsx编译成js（或者用babel，具体问题具体分析）</li><li>写好demo后，随便用fis或者webpack在线调试就好了</li></ol><p><strong>针对上面的问题，我的处理方法是，直接把涉及的几个函数串起来，写成demo，想怎么调就怎么调噜~</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="comment">// 判断当前是否中文版本</span></span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">isZhCN</span><span class="params">(pathname)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> (<span class="regexp">/-cn\/?$/</span>.test(pathname));</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="comment">// 根据当前pathname和isZhCN()返回该跳转的相对路径</span></span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">getLocalizedPathname</span><span class="params">(path, zhCN)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> pathname = path.startsWith(<span class="string">'/'</span>) ? path : <span class="string">'/'</span> + path;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">if</span> (!zhCN) &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// to enUS</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> (<span class="regexp">/\/?index-cn/</span>.test(pathname) ? <span class="string">'/'</span> : pathname.replace(<span class="string">'-cn'</span>, <span class="string">''</span>)</span></span><br><span class="line"><span class="undefined">    );</span></span><br><span class="line"><span class="actionscript">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pathname === <span class="string">'/'</span>) &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> <span class="string">'/index-cn'</span>;</span></span><br><span class="line"><span class="actionscript">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pathname.endsWith(<span class="string">'/'</span>)) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> pathname.replace(<span class="regexp">/\/$/</span>, <span class="string">'-cn/'</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> pathname + <span class="string">'-cn'</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="comment">// handleLangChange 的简写</span></span></span><br><span class="line"><span class="actionscript"><span class="comment">// 由于当前环境不在https://ant.design域下，我是直接访问demo.html</span></span></span><br><span class="line"><span class="actionscript"><span class="comment">// 原文中的location.pathname，这里使用硬编码替代</span></span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> pathname = <span class="string">'/index-cn'</span>;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> result = location.href.replace(</span></span><br><span class="line"><span class="undefined">    location.pathname,</span></span><br><span class="line"><span class="undefined">    getLocalizedPathname(pathname, isZhCN(pathname))</span></span><br><span class="line"><span class="undefined">);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="comment">// 输出测试结果</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(result);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其实这样也属于盲调，纯本地调试，修bug的原理没错，但是没有实时调试，加上我不了解业务逻辑（我以为只有首页有中英版本切换，没考虑到其他入口也有），导致我提交的第一个版本会丢失hash和query，后续我再PR了一版，修复的详细这里就不详述了。</p><p><a href="https://github.com/ant-design/ant-design/pull/5050" target="_blank" rel="noopener">第一版</a> <a href="https://github.com/YuyingWu/ant-design/commit/9c9c164617ec35d9c30e5518f94661601bcd736b" target="_blank" rel="noopener">第二版</a></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>不懂业务、不了解系统的架构和实现、不懂编程语言、没法实时调试，这些可能会变成我们在问题定位和修复时的拦路虎~但是，不要方，见招拆招，用自己的思路和方式解决 ：）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;跟大家分享一个最近调bug的故事，在不熟悉架构、业务上下文、编程语言、调试环境等等的情况下，遇到问题时，我们可以怎么解决。简单的来说，路过一个你喜欢的站点，发现页面有bug，想帮忙修，怎么办？&lt;br&gt;
    
    </summary>
    
    
      <category term="tech" scheme="http://wuyuying.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记 - CSS网站布局实录</title>
    <link href="http://wuyuying.com/archives/css-layout/"/>
    <id>http://wuyuying.com/archives/css-layout/</id>
    <published>2017-02-07T04:42:07.000Z</published>
    <updated>2018-05-25T10:34:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>有些书籍，就算内容赶不上潮流，经典始终是经典，无论什么时候看，总会觉得有些新的感受新的收获。</p><p><a href="https://book.douban.com/subject/2175995/" target="_blank" rel="noopener">《CSS网站布局实录》</a>，这本书不厚，关于布局、文件流、盒模型等等的基础知识，却讲得非常清晰明白。<br><a id="more"></a></p><h2 id="一、那些CSS布局的事儿"><a href="#一、那些CSS布局的事儿" class="headerlink" title="一、那些CSS布局的事儿"></a>一、那些CSS布局的事儿</h2><h3 id="一列固定宽度"><a href="#一列固定宽度" class="headerlink" title="一列固定宽度"></a>一列固定宽度</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box-1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一列宽度自适应"><a href="#一列宽度自适应" class="headerlink" title="一列宽度自适应"></a>一列宽度自适应</h3><p>宽度随着视窗宽度而改变</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box-1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">80%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一列固定宽度居中"><a href="#一列固定宽度居中" class="headerlink" title="一列固定宽度居中"></a>一列固定宽度居中</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box-1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两列固定宽度"><a href="#两列固定宽度" class="headerlink" title="两列固定宽度"></a>两列固定宽度</h3><p>使用浮动，使文件流下两个块级元素流到同一行</p><blockquote><p>文件流：body下的任意元素，根据其前后顺序和元素类型（块级、行内），组成一个个上下关系</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box-1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-2</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两列宽度自适应"><a href="#两列宽度自适应" class="headerlink" title="两列宽度自适应"></a>两列宽度自适应</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box-1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">30%</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-2</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">60%</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意不要打满100%，会有两列之间的margin、padding、border等宽度影响</p><h3 id="两列右列宽度自适应"><a href="#两列右列宽度自适应" class="headerlink" title="两列右列宽度自适应"></a>两列右列宽度自适应</h3><p>左列宽度自适应同理。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.<span class="built_in">box</span><span class="number">-1</span>&#123;</span><br><span class="line">    <span class="built_in">width</span>: <span class="number">100</span>px;</span><br><span class="line">    <span class="built_in">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="built_in">box</span><span class="number">-2</span>&#123;</span><br><span class="line">    <span class="comment">// 自适应：不设宽度，不设定浮动属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两列固定宽度居中"><a href="#两列固定宽度居中" class="headerlink" title="两列固定宽度居中"></a>两列固定宽度居中</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"layout"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box-1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box-2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.layout</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: width1 + width2 (+ margin/borderWidth)</span><br><span class="line">    margin: <span class="number">0</span> auto;</span><br><span class="line">    &amp;:after&#123;</span><br><span class="line">        <span class="attribute">clear</span>: both; <span class="comment">// 清除浮动，不影响后面的文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: width1;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-2</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: width2;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三列中间列宽度自适应"><a href="#三列中间列宽度自适应" class="headerlink" title="三列中间列宽度自适应"></a>三列中间列宽度自适应</h3><p><strong>左右列</strong>使用绝对定位，脱离文件流；<br><strong>中间列</strong>默认宽度100%，使用左右的margin来缩进左列和右列的宽度，达到自适应的效果。</p><p>如果定位不是针对整个视窗，父容器也用绝对定位，保证左右列绝对定位的参照元素是父元素。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box-left</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>; <span class="comment">// 左对齐</span></span><br><span class="line">    <span class="attribute">width</span>: width1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-right</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>; <span class="comment">// 右对齐</span></span><br><span class="line">    <span class="attribute">width</span>: width2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-middle</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> width2 <span class="number">0</span> width1; <span class="comment">// margin: 上 右 下 左</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高度自适应"><a href="#高度自适应" class="headerlink" title="高度自适应"></a>高度自适应</h3><p>单独设置某个元素的<code>height: 100%;</code>有时候会无效。原来，根据浏览器解析规则，<strong>子元素的高度是否能按百分比显示，取决于父元素的高度</strong>。</p><p>假设我们要实现一个自适应视窗高度的效果：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IE下，html元素默认高100%，但body不是</span></span><br><span class="line"><span class="comment">// Firefox下，html没有默认高100%</span></span><br><span class="line"><span class="selector-tag">html</span>, <span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.target</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、一些经典问题"><a href="#二、一些经典问题" class="headerlink" title="二、一些经典问题"></a>二、一些经典问题</h2><h3 id="1-上下margin叠加问题"><a href="#1-上下margin叠加问题" class="headerlink" title="1. 上下margin叠加问题"></a>1. 上下margin叠加问题</h3><p><strong>表现</strong><br>当上下对象均有<code>margin</code>属性时，外边距会出现叠加问题，取较大值。</p><p><strong>原因</strong><br>CSS原始设计问题。作者考虑到段落的样式控制，假如多个<code>p</code>之间形成段落，每个p都具有margin属性，为解决排版距离不一致问题，设计出外边距叠加规则。</p><p>例外情况，margin叠加只针对<strong>块级元素</strong>，对<code>inline</code>、<code>浮动</code>、<code>绝对定位</code>的元素无效。</p><h3 id="2-IE6下，float元素margin加倍"><a href="#2-IE6下，float元素margin加倍" class="headerlink" title="2. IE6下，float元素margin加倍"></a>2. IE6下，float元素margin加倍</h3><p>可通过设定目标元素的<code>display: inline;</code>解决。</p><h3 id="3-CSS效果：首字下沉"><a href="#3-CSS效果：首字下沉" class="headerlink" title="3. CSS效果：首字下沉"></a>3. CSS效果：首字下沉</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.first-character</span>&#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">    <span class="attribute">vertical-align</span>: top;</span><br><span class="line">    &amp;:first-letter&#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">2em</span>;</span><br><span class="line">        <span class="attribute">float</span>: left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-图像裁剪问题"><a href="#4-图像裁剪问题" class="headerlink" title="4. 图像裁剪问题"></a>4. 图像裁剪问题</h3><ol><li>CSS的clip属性（对象需使用绝对定位）</li><li>父元素定宽高，使用<code>overflow:hidden</code>，局部展示子元素的图片内容</li><li>computed，通过计算，使图片自动水平、垂直居中</li><li>flex布局</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有些书籍，就算内容赶不上潮流，经典始终是经典，无论什么时候看，总会觉得有些新的感受新的收获。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/2175995/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《CSS网站布局实录》&lt;/a&gt;，这本书不厚，关于布局、文件流、盒模型等等的基础知识，却讲得非常清晰明白。&lt;br&gt;
    
    </summary>
    
    
      <category term="reading" scheme="http://wuyuying.com/tags/reading/"/>
    
      <category term="css" scheme="http://wuyuying.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Hexo主题的置顶功能</title>
    <link href="http://wuyuying.com/archives/hexo-top/"/>
    <id>http://wuyuying.com/archives/hexo-top/</id>
    <published>2017-02-02T05:23:18.000Z</published>
    <updated>2018-05-25T10:34:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>忽然想要一个置顶功能，可惜原生的<code>hexo-generator-index</code>没有提供这样的方法，那只能自己搞一个了~</p><a id="more"></a><h2 id="一、hexo-generator-index修改"><a href="#一、hexo-generator-index修改" class="headerlink" title="一、hexo-generator-index修改"></a>一、hexo-generator-index修改</h2><p>Hexo排序编译组件，一般默认安装的，默认配置（按date排序）</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">index_generator:</span></span><br><span class="line"><span class="symbol">  per_page:</span> <span class="number">10</span></span><br><span class="line"><span class="symbol">  order_by:</span> -date</span><br></pre></td></tr></table></figure><p>如果没有安装的话，可执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-index --save</span><br></pre></td></tr></table></figure><p>在<code>node_modules/lib/generator.js</code>添加以下排序代码：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">posts.data = posts.data.sort(function(a, b) &#123;</span><br><span class="line">  !a.<span class="built_in">top</span> &amp;&amp; (a.<span class="built_in">top</span> = <span class="number">0</span>);</span><br><span class="line">  !b.<span class="built_in">top</span> &amp;&amp; (b.<span class="built_in">top</span> = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  // 若<span class="built_in">top</span>值一样则按照文章日期降序排，否则按照<span class="built_in">top</span>值降序排</span><br><span class="line">  <span class="keyword">if</span>(a.<span class="built_in">top</span> == b.<span class="built_in">top</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> b.date - a.date; // </span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b.<span class="built_in">top</span> - a.<span class="built_in">top</span>; // </span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="二、日志配置"><a href="#二、日志配置" class="headerlink" title="二、日志配置"></a>二、日志配置</h2><p>在Front-matter添加top属性</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">我的2016</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">总结</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2017</span><span class="bullet">-01</span><span class="bullet">-20</span> <span class="number">00</span><span class="string">:11:18</span></span><br><span class="line"><span class="attr">top:</span> <span class="number">1</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h2 id="三、置顶文案-样式设定"><a href="#三、置顶文案-样式设定" class="headerlink" title="三、置顶文案/样式设定"></a>三、置顶文案/样式设定</h2><p><img src="http://cdn.sinacloud.net/woodysblog/articles/top.png" alt=""></p><p>简单在日期边上加了个“置顶”的箭头~</p><p>添加一个模板<code>theme/landscape/layout/_partial/post/top.ejs</code>，判断当前日志是否有top属性（<code>post.top</code>）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">post.top</span>)&#123; %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-arrow-up article-top"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br></pre></td></tr></table></figure><p>然后在你想添加的位置，引用该模板组件</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">blah</span></span> blah ...</span><br><span class="line"></span><br><span class="line">&lt;%- partial(<span class="string">'post/top'</span>) %&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">blah</span></span> blah ...</span><br></pre></td></tr></table></figure><p>Reference:<br><a href="http://www.netcan666.com" target="_blank" rel="noopener">Netcan</a>的<a href="http://www.netcan666.com/2015/11/22/解决Hexo置顶问题/" target="_blank" rel="noopener">《解决hexo置顶问题》</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;忽然想要一个置顶功能，可惜原生的&lt;code&gt;hexo-generator-index&lt;/code&gt;没有提供这样的方法，那只能自己搞一个了~&lt;/p&gt;
    
    </summary>
    
    
      <category term="blog" scheme="http://wuyuying.com/tags/blog/"/>
    
      <category term="theme" scheme="http://wuyuying.com/tags/theme/"/>
    
  </entry>
  
  <entry>
    <title>git学习笔记</title>
    <link href="http://wuyuying.com/archives/git/"/>
    <id>http://wuyuying.com/archives/git/</id>
    <published>2017-01-23T10:35:51.000Z</published>
    <updated>2018-05-25T10:34:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近想要做博客的云端编码，在哪都能发日志，于是入了coding.net的坑，从svn转到git下~</p><p>以前工作中，因为没有什么使用git的需要，说要学吧，总有各种理由没时间。为了小博客真是操碎了心，看了廖老师的教程，发现其实git跟svn cli还是有很多的相同之处，也没有特别陌生，相信不用多久就能上手了 :)</p><p>本文是自己学习和记录用的，如果大家想看教程，还是推荐廖雪峰老师的<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">《Git教程》</a><br><a id="more"></a></p><h2 id="关于版本库、工作区和暂存区"><a href="#关于版本库、工作区和暂存区" class="headerlink" title="关于版本库、工作区和暂存区"></a>关于版本库、工作区和暂存区</h2><ul><li>版本库/Repository：Git版本库，会自动创建分支master，以及指向master的HEAD指针；</li><li>工作区/Working Directory：你在本地写代码的目录；</li><li>暂存区/Stage：<ul><li>当你使用<code>git add</code>时，是把本地代码提交到暂存区；</li><li>而使用<code>git commit</code>时，则把暂存区的代码提交到当前的分支；</li></ul></li></ul><p><img src="http://cdn.sinacloud.net/woodysblog/git/git.jpg" alt=""></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github<span class="selector-class">.com</span>:YuyingWu/blog<span class="selector-class">.git</span> <span class="comment">// 从远程库克隆</span></span><br><span class="line">git status <span class="comment">// 查看状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件处理</span></span><br><span class="line">git add &lt;file&gt; <span class="comment">// 添加文件到暂存区</span></span><br><span class="line">git rm &lt;file&gt; <span class="comment">// 从版本库删除文件</span></span><br><span class="line">git checkout -- &lt;file&gt; <span class="comment">// 撤销更改</span></span><br><span class="line">git reset HEAD &lt;file&gt; <span class="comment">// 撤销更改</span></span><br><span class="line">git diff HEAD -- &lt;file&gt; <span class="comment">// 比较diff</span></span><br><span class="line"></span><br><span class="line">git commit <span class="comment">// 把暂存区的所有内容提交到当前分支</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分支管理</span></span><br><span class="line">git branch <span class="comment">// 查看分支列表及当前分支，带参数-d代表删除某分支</span></span><br><span class="line">git checkout branch-n <span class="comment">// 切换到xx分支，带参数-b代表创建并切换</span></span><br><span class="line">git checkout -<span class="selector-tag">b</span> branch-n origin/branch-n <span class="comment">// 创建与远程库对应的本地分支</span></span><br><span class="line">git merge branch-n <span class="comment">// 合并branch-n的代码到当前分支</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分支推送</span></span><br><span class="line">git push origin master <span class="comment">// origin为远程库，master为当前分支</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分支抓取</span></span><br><span class="line">git pull <span class="comment">// pull = fetch + merge</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地分支push到远程仓库</span></span><br><span class="line">git init</span><br><span class="line">git remote add origin git@github<span class="selector-class">.com</span>:YuyingWu/blog.git</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"init"</span></span><br><span class="line">git push origin preact:preact</span><br></pre></td></tr></table></figure><h2 id="Git小贴士"><a href="#Git小贴士" class="headerlink" title="Git小贴士"></a>Git小贴士</h2><p><code>问</code>：怎么生成SSH key（SSH密钥）？<br><code>答</code>：命令行执行以下代码。Mac系统下，生成的id_rsa.pub和id_rsa在/Users/xxx/.ssh目录。<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -<span class="built_in">t</span> rsa -C “your email <span class="built_in">address</span>”</span><br></pre></td></tr></table></figure></p><p><img src="http://cdn.sinacloud.net/woodysblog/git/ssh.png" alt=""></p><p><code>问</code>：想把一份代码同步到多个git源，咋整？<br><code>答</code>：打开本地工作区的.git/config文件，给remote “origin”多添加几个url即可</p><p><img src="http://cdn.sinacloud.net/woodysblog/git/remote.png" alt=""></p><p><code>问</code>：RPC failed<br><code>答</code>：默认Git设置<code>http post</code>的缓存为1MB，改为500MB后成功提交</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Question</span><br><span class="line"><span class="keyword">error: </span>RPC failed; HTTP 411 curl 22 The requested URL returned error: 411 Length Required</span><br><span class="line">fatal: The remote end hung up unexpectedly</span><br><span class="line"></span><br><span class="line">// Solution</span><br><span class="line">git config http.postBuffer  524288000</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近想要做博客的云端编码，在哪都能发日志，于是入了coding.net的坑，从svn转到git下~&lt;/p&gt;
&lt;p&gt;以前工作中，因为没有什么使用git的需要，说要学吧，总有各种理由没时间。为了小博客真是操碎了心，看了廖老师的教程，发现其实git跟svn cli还是有很多的相同之处，也没有特别陌生，相信不用多久就能上手了 :)&lt;/p&gt;
&lt;p&gt;本文是自己学习和记录用的，如果大家想看教程，还是推荐廖雪峰老师的&lt;a href=&quot;http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Git教程》&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="tech" scheme="http://wuyuying.com/tags/tech/"/>
    
      <category term="git" scheme="http://wuyuying.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>我的2016</title>
    <link href="http://wuyuying.com/archives/year-2016/"/>
    <id>http://wuyuying.com/archives/year-2016/</id>
    <published>2017-01-19T16:11:18.000Z</published>
    <updated>2018-05-25T10:34:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>二零一六年，是对我来说非常不一样的一年。</p><a id="more"></a><p><img src="http://cdn.sinacloud.net/woodysblog/2016/me.JPG" alt="&quot;Cooks Beach&quot;"></p><h2 id="例行总结"><a href="#例行总结" class="headerlink" title="例行总结"></a>例行总结</h2><ul><li><del><i class="fa fa-square-o"></i> 读书，目标50</del>，41本，<strong>不达标</strong>；</li><li><del><i class="fa fa-square-o"></i> 理财，目标10%</del>，实盘-7.17%，大盘沪指-12.31%，跑赢大盘，<strong>不达标</strong>；（出国期间管都没管，要什么自行车）</li><li><i class="fa fa-check-square-o"></i> 2016年的技术规划，在我离职时把我能做的都做完了，<strong>get√</strong></li><li><i class="fa fa-check-square-o"></i> 新西兰环岛，<strong>get√</strong></li></ul><p>搞siao，啥都不达标，总结啥！？哦~</p><h2 id="此处开始-——-抒情随意总结"><a href="#此处开始-——-抒情随意总结" class="headerlink" title="此处开始 —— 抒情随意总结"></a>此处开始 —— 抒情随意总结</h2><p>2016年6月，结束了在大百度的工作，我贡献了3年多青春的”初恋”。上半年的故事，之前在<a href="/archives/resign-from-baidu/">《离职这件小事》</a>里已经说得差不多了，姑且当做上半年总结吧。</p><p>希望鸡神眷顾我找到靠谱的新工作~</p><p><img src="http://cdn.sinacloud.net/woodysblog/2016/chicken.JPG" alt=""></p><p>随后，说走就走，开展了为期6个月的新西兰打工旅行。换宿、<a href="/archives/work-whv/">打季节工</a>、半年换了3辆战车、以露营为主的自驾环南北岛……从来没有过那么颠沛流离、充满对未知的恐惧，当然也带着一丝对未来小刺激的期待，像我之前说的，每一天都需要勇气来生活。</p><p>2016年下半年的生活的可能性和丰富度，时间只有半年，却比我以往的26年都要多，刺激得不行不行的。于是我变成了一个有故事的女同学，哈哈，故事、人物和感受太多，一时之间，不知从何说起。（让你懒惰之前不写日志！！）</p><p><img src="http://cdn.sinacloud.net/woodysblog/2016/farm.JPG" alt="&quot;Kerikeri Nursery&quot;"></p><p><img src="http://cdn.sinacloud.net/woodysblog/2016/hitch-hike.JPG" alt="&quot;Hitch hike in Paihia&quot;"></p><p><img src="http://cdn.sinacloud.net/woodysblog/2016/fishing.JPG" alt="&quot;Fishing&quot;"></p><p><img src="http://cdn.sinacloud.net/woodysblog/2016/Tongariro.JPG" alt="&quot;Tongariro National Park&quot;"></p><p><img src="http://cdn.sinacloud.net/woodysblog/2016/camp.JPG" alt="&quot;camping&quot;"></p><p>原本有占据2页的篇幅（写于奥克兰机场），记录一个我精心挑选的年度最佳的故事，但是在跟我爸妈聊天后，我决定删掉。出来行走江湖，谁没有几个悲伤的故事，不用时刻拿出来卖惨，我重新认识一个<strong>坚强和强悍抗压的自己</strong>已经够了，哈哈，成长的代价。</p><p><img src="http://cdn.sinacloud.net/woodysblog/2016/deleted-post.JPG" alt=""></p><p>很好奇发生了什么是不是？我就不说~ 简而言之，就是发生了一个（或者几个）小插曲，让我变得一无所有，差点没有办法回国，我崩溃了一小下，不过很快收拾好心情妥善处理好一切。这些我当时没有跟任何人说，几个小伙伴知道都是我事后说的，不想家人或者朋友干担心瞎着急。</p><p>前几天，我跟爸妈说起我在新西兰经历的各种，也包括那些小插曲，并没有收到爸妈的安慰，那个瞬间我真怀疑自己到底是不是亲生的，哈哈。我遇到的“大麻烦”，在阅历丰富的爸妈眼里，不值一提。</p><p><img src="http://cdn.sinacloud.net/woodysblog/2016/car.JPG" alt=""></p><p>爸妈说：</p><blockquote><p>你以为自己有多大损失、多委屈，比起你能安全回国，根本不算事儿。你出发之前，我们劝你不要停留那么久，在那边玩2、3个礼拜就算了。但是你坚持要留那么久，我们也只能支持你。</p><p>发生这样的事情，完全在我们意料之中，这就是为什么你出国前我们联系到奥克兰的阿姨，让你有事去找她帮忙。你在国外时，我们每天都在担心。你会不会开车冲下山？会不会撞到别人？会不会遇到坏人？会不会失联，从此人间蒸发？</p></blockquote><p>惊奇地发现，在我出发前后，他们说的话是一样的，但作为听众的我，感受却大不相同。真倒霉起来，老天爷要耍我的话，他们担心的事情是真会变成现实的，最坏情况是客死异乡，而我在途中真实遇到的若干次意外，跟死神擦身而过。细思极恐，他们的担心不无道理，真苦了他们天天为我担惊受怕。</p><p><strong>感谢爸妈</strong>，在那么担心的情况下，没有干预我的决定，尊重我的选择。<br><strong>感谢老天</strong>，我顺利安全回国了。</p><p><img src="http://cdn.sinacloud.net/woodysblog/2016/airport.JPG" alt="&quot;Auckland Airport&quot;"></p><h2 id="神秘的旅伴-——-猩爷"><a href="#神秘的旅伴-——-猩爷" class="headerlink" title="神秘的旅伴 —— 猩爷"></a>神秘的旅伴 —— 猩爷</h2><p>嗯，虽然我自认为找工作、沟通和抗压的技能指数爆表（了不起！）但是这一路走下来，我特别想<strong>感谢我的旅伴 —— 猩爷</strong></p><p><img src="http://cdn.sinacloud.net/woodysblog/2016/b-1.JPG" alt="&quot;猩爷的沙滩写真&quot;"></p><p>旅行是最能看清楚一个人的时候，因为大家会遇到各种难题各种令人崩溃的事情，变态、极端到你这辈子可能都不会再有机会遇到。我崩溃的时候，还是她把我拉回来的，真真了不起！</p><ul><li>吃苦耐劳</li><li>一身洪荒之力无处释放</li><li>做得一桌好菜</li><li>搭得一顶好帐篷</li><li>开得一手好车（自称“青秀山车神”）</li><li>夕阳红爬山队的教练和打杂</li></ul><p><img src="http://cdn.sinacloud.net/woodysblog/2016/b-2.JPG" alt="&quot;悬崖边上的猩爷&quot;"></p><p>在那么艰苦的荒野求生中，我还是长胖了，真的要好好感谢她（咬牙切齿）</p><p>（上述各种都是猩爷做，你做了什么？）噢~ 我一般什么都不做，在旁边做<strong>鼓励师</strong>和<strong>卖萌机器人</strong>，衬托能干的她，哈哈哈！</p><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h2><p><code>问</code> 澳洲的WHV签证还申请吗？<br><code>答</code> 不要。这半年我感觉够够的，后悔得要死，跟我想的完全不一样。短期内也不想旅行了，哈哈。</p><p><code>问</code> 如果时光倒流，可以再选一次，还要去新西兰吗？<br><code>答</code> 去啊，说走还走！不去永远不知道，喜欢或者不喜欢，开心抑或不开心，总得经历过才知道，美不在天堂，而在前往天堂的路上，也许这就是成长的代价吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二零一六年，是对我来说非常不一样的一年。&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="http://wuyuying.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>fis3安装时遇到的node版本问题</title>
    <link href="http://wuyuying.com/archives/fis3-node/"/>
    <id>http://wuyuying.com/archives/fis3-node/</id>
    <published>2017-01-17T16:18:45.000Z</published>
    <updated>2018-05-25T10:34:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天在调试demo，执行编译命令时，</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fis3 <span class="built_in">release</span></span><br></pre></td></tr></table></figure><p>报了一大堆错误，一时懵逼~<br><a id="more"></a><br><img src="http://cdn.sinacloud.net/woodysblog/fis3-node/error.png" alt=""></p><p>关键行：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Fatal error <span class="keyword">in</span> ..<span class="regexp">/deps/</span>v8<span class="regexp">/src/</span>api.cc, line <span class="number">1051</span></span><br><span class="line"></span><br><span class="line">blah blah</span><br><span class="line"></span><br><span class="line">Illegal <span class="string">instruction:</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>运行环境是：</p><ul><li>node，v 7.4.0</li><li>fis3，v 3.4.31</li></ul><p>这都啥呀，于是搜了下，可能是因为<strong>node的v8内核不稳定或者跟涉及的插件不合适</strong>~遇到类似的问题，可以尝试安装稳定版本的node。</p><p>后来发现，还是不okay，就去fis官网看<a href="http://fis.baidu.com/fis3/docs/beginning/install.html" target="_blank" rel="noopener">安装指南</a>，发现fis只支持以下的node版本：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0<span class="selector-class">.8</span><span class="selector-class">.x</span>，0<span class="selector-class">.10</span><span class="selector-class">.x</span>, 0<span class="selector-class">.12</span><span class="selector-class">.x</span>，4<span class="selector-class">.x</span>，6<span class="selector-class">.x</span></span><br></pre></td></tr></table></figure><p>最后我装了node的0.12.0版本，bingo！</p><p>由于node版本的变更，一些模块可能需要重装，根据提示rebuild就好了 :)</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm rebuild <span class="keyword">node</span><span class="title">-sass</span></span><br></pre></td></tr></table></figure><hr><h2 id="node版本管理模块-——-n"><a href="#node版本管理模块-——-n" class="headerlink" title="node版本管理模块 —— n"></a>node版本管理模块 —— n</h2><p>顺便安利一个npm的模块 —— n，专门管理node版本的模块，功能多多，可以查询node最新、最稳定的版本，又或者安装指定版本……</p><p><strong>一、全局安装</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g n</span><br></pre></td></tr></table></figure><p><strong>二、n的常用功能</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n stable <span class="comment">// 安装最稳定版本</span></span><br><span class="line">n ls <span class="comment">// 查看node版本列表</span></span><br><span class="line">n <span class="number">0.12</span><span class="number">.0</span> <span class="comment">// 安装指定版本</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在调试demo，执行编译命令时，&lt;/p&gt;
&lt;figure class=&quot;highlight arduino&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;fis3 &lt;span class=&quot;built_in&quot;&gt;release&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;报了一大堆错误，一时懵逼~&lt;br&gt;
    
    </summary>
    
    
      <category term="tech" scheme="http://wuyuying.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>Kindle从5.6.1到5.4.4的降级+ 刷多看（Paperwhite 1代）</title>
    <link href="http://wuyuying.com/archives/kindle-duokan/"/>
    <id>http://wuyuying.com/archives/kindle-duokan/</id>
    <published>2017-01-15T07:00:20.000Z</published>
    <updated>2018-05-25T10:34:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>Kindle自动升级到5.6.1.1后，多看阅读就没办法装了，貌似是2年前就说在研发，但一直没有下文……最近多看出了本《S.》的电子本，特别想看，于是上网搜了下，咦，终于降级成功，在这简单分享一下吧。</p><a id="more"></a><h2 id="准备材料："><a href="#准备材料：" class="headerlink" title="准备材料："></a>准备材料：</h2><ul><li>Kindle 一台</li><li>Kindle 5.4.4 <a href="https://pan.baidu.com/s/1c2by8cK" target="_blank" rel="noopener">降级包</a></li><li>多看阅读 for kindle <a href="http://www.miui.com/thread-2558456-1-1.html" target="_blank" rel="noopener">安装包</a>（下载对应版本）</li></ul><h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><ol><li>Kindle连接电脑；</li><li>降级包（不要更改文件名）放到Kindle的根目录，即与document同级；</li><li><strong>千万不要弹出Kindle（不要拔usb线）</strong>，长按电源键，按到Kindle在电脑显示弹出状态为止。</li></ol><p>降级就那么轻松愉快地结束了！</p><h2 id="给Kindle刷多看阅读"><a href="#给Kindle刷多看阅读" class="headerlink" title="给Kindle刷多看阅读"></a>给Kindle刷多看阅读</h2><ol><li>Kindle连接电脑；</li><li>安装包的文件（DK_System、update_kindle_巴拉巴拉）放在Kindle的根目录；</li><li>拷贝完成后，弹出Kindle（拔线）</li><li>Kindle回到主目录，菜单/menu -&gt; 设置/setting -&gt; 更新你的Kindle/update your Kindle</li></ol><p>于是你的Kindle就开始自己玩，闪呀闪，重启呀重启，然后多看就这样在重启中装好了 ：）</p><h2 id="防止Kindle自动更新"><a href="#防止Kindle自动更新" class="headerlink" title="防止Kindle自动更新"></a>防止Kindle自动更新</h2><p>如果Kindle不小心连上了WiFi，又不小心自动升级到最新版的系统，那降级和多看都白刷了~所以我们想要把自动升级这个进程堵住。</p><p>新建一个名叫<strong>update.bin.tmp.partial</strong>的文件，放在Kindle的根目录，这是半下载状态的升级包名字，打断系统自动下载新的升级包~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kindle自动升级到5.6.1.1后，多看阅读就没办法装了，貌似是2年前就说在研发，但一直没有下文……最近多看出了本《S.》的电子本，特别想看，于是上网搜了下，咦，终于降级成功，在这简单分享一下吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="tech" scheme="http://wuyuying.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>怎么把Moves数据（.gpx）导入到Google Map</title>
    <link href="http://wuyuying.com/archives/gpx/"/>
    <id>http://wuyuying.com/archives/gpx/</id>
    <published>2016-11-19T12:06:18.000Z</published>
    <updated>2018-05-25T10:34:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>装逼我们是认真的，论怎样高逼格的暴露自己的行踪~</p><a id="more"></a><p>所以本文的目标，说到底只是想暴露一下我的第一次9小时的雪山穿越~</p><p><img src="http://cdn.sinacloud.net/woodysblog/gpx/8show.jpg" alt="&quot;Tongariro Alpine Crossing in Tongariro Nation Park&quot;"></p><p>不打算介绍高逼格、记录行踪神器<a href="https://www.moves-app.com/" target="_blank" rel="noopener">Moves</a>和<a href="https://www.google.co.nz/maps/" target="_blank" rel="noopener">Google Map</a>了~所以本文只适合已经知道这些的盆友们。</p><h2 id="从Moves导出定位数据-——-gpx文件"><a href="#从Moves导出定位数据-——-gpx文件" class="headerlink" title="从Moves导出定位数据 —— gpx文件"></a>从Moves导出定位数据 —— gpx文件</h2><ol><li>进入Moves相关应用 —— Moves Export的页面</li><li>点击”GET STARTED”获取Moves授权的PIN码</li><li>PIN码页面上有授权提示啦，其实就是在手机上的Moves输入PIN码完成授权过程</li><li>页面自动跳转，在Moves Export的菜单栏，选择”Your Storylines“，看到某天某个时间段的行踪了吧~</li><li>选好日期，在右侧一堆按钮里选择绿色”GPX”，把GPX文件保存到本地。</li></ol><p><img src="http://cdn.sinacloud.net/woodysblog/gpx/1getGpx.jpg" alt=""></p><h2 id="在Google-Map创建自己的地图"><a href="#在Google-Map创建自己的地图" class="headerlink" title="在Google Map创建自己的地图"></a>在Google Map创建自己的地图</h2><p>菜单 -&gt; 您的地点 -&gt; 地图 -&gt; 创建地图 -&gt; 导入GPX文件</p><p><img src="http://cdn.sinacloud.net/woodysblog/gpx/2createMap.jpg" alt="&quot;创建地图&quot;"></p><p><img src="http://cdn.sinacloud.net/woodysblog/gpx/3import.jpg" alt="&quot;导入gpx数据&quot;"></p><h2 id="地图编辑"><a href="#地图编辑" class="headerlink" title="地图编辑"></a>地图编辑</h2><p>1.新增标记、绘制线条、添加路线等</p><p><img src="http://cdn.sinacloud.net/woodysblog/gpx/4create.jpg" alt=""></p><p>2.图层数据编辑(重命名、编辑原始数据表、删除图层)</p><p><img src="http://cdn.sinacloud.net/woodysblog/gpx/5layer.jpg" alt=""></p><p>3.某个点的图标、定义编辑</p><p><img src="http://cdn.sinacloud.net/woodysblog/gpx/6pointEdit.jpg" alt=""></p><p>4.在编辑菜单拉到最下面的“基本地图”，是要选择你想怎样显示地图，包括默认视图、卫星、地形等等。本文例子的穿越高山主题，所以地图我选择了”地形”展示。</p><p><img src="http://cdn.sinacloud.net/woodysblog/gpx/6map.jpg" alt=""></p><h2 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h2><p>1.设置地图的访问权限：共享 - “私密” -&gt; “在网络公开”</p><p><img src="http://cdn.sinacloud.net/woodysblog/gpx/7share1.jpg" alt="&quot;共享&quot;"></p><p><img src="http://cdn.sinacloud.net/woodysblog/gpx/7share2.jpg" alt="&quot;私密&quot;"></p><p><img src="http://cdn.sinacloud.net/woodysblog/gpx/7share3.jpg" alt="&quot;公开&quot;"></p><p>2.分享</p><p><img src="http://cdn.sinacloud.net/woodysblog/gpx/7share4.jpg" alt=""></p><p><img src="http://cdn.sinacloud.net/woodysblog/gpx/7share5.jpg" alt=""></p><p>i. 图片（自行截图或打印）</p><p><img src="http://cdn.sinacloud.net/woodysblog/gpx/8show.jpg" alt=""></p><p>ii. 分享链接</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http<span class="variable">s:</span>//drive.google.<span class="keyword">com</span>/<span class="keyword">open</span>?id=<span class="number">1</span>O9TyJoQQ3lCV3lh9pAJkMoHYyiU&amp;usp=sharing</span><br></pre></td></tr></table></figure><p>iii.嵌入到网站(具体以官方代码为准哈，此处为适应博客主题，iframe样式有调整过)</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe <span class="attribute">src</span>=<span class="string">"https://www.google.com/maps/d/u/0/embed?mid=1O9TyJoQQ3lCV3lh9pAJkMoHYyiU"</span> <span class="attribute">width</span>=<span class="string">"640"</span> <span class="attribute">height</span>=<span class="string">"480"</span>&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><p>下面是Google Map的iframe~可能没有翻墙会看不到 T_T</p><iframe src="https://www.google.com/maps/d/u/0/embed?mid=1O9TyJoQQ3lCV3lh9pAJkMoHYyiU" width="100%" height="480"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;装逼我们是认真的，论怎样高逼格的暴露自己的行踪~&lt;/p&gt;
    
    </summary>
    
    
      <category term="Google Map" scheme="http://wuyuying.com/tags/Google-Map/"/>
    
      <category term="gpx" scheme="http://wuyuying.com/tags/gpx/"/>
    
  </entry>
  
  <entry>
    <title>Katikati找工记-伍酱在纽村</title>
    <link href="http://wuyuying.com/archives/job-hunting-whv/"/>
    <id>http://wuyuying.com/archives/job-hunting-whv/</id>
    <published>2016-10-26T06:22:00.000Z</published>
    <updated>2018-05-25T10:34:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>叫我找工小能手！</p><a id="more"></a><p>我们在Whitianga的Albert Number 6换宿，其实还挺爽了，每天工作1个钟左右，都是些轻松愉快的活儿，cleaning、bedmaking、room service等，之后的时间就自由噜，下午写写代码、看看书、去海边散散步，就这样过去2周。</p><p>直到有一天，我看到了Katikati的一个酒庄<a href="http://www.wineportfolio.co.nz/wineportfolio/" target="_blank" rel="noopener">wineportfolio</a>在招人，做wine bottling（生产线里把瓶子放到出酒口），那么轻松愉快又能近距离接触红酒生产的工作，我特别感兴趣，想在离开纽村前做一下，于是打电话过去问，确实要人，不过要本人去酒庄填表等消息。</p><p>就这么愉快的决定了要去Katikati找工作，然而Katikati也是个奇异果+牛油果小镇，不如顺便也看看有没有packhouse在招人啰~</p><p>无心插柳柳成荫，结果是酒庄没有要我们，但收获了2间packhouse的offer，未来3周我们就在Seeka开展了新一段赚钱之旅。</p><p>上述其实都是背景故事啦，本文主要想聊一下怎么有效地找工作。但是工作经历有限，只有两次packhouse经验，嘎嘎 ：）</p><h1 id="第一份工作"><a href="#第一份工作" class="headerlink" title="第一份工作"></a>第一份工作</h1><p>像我的第一份工作，kiwifruit repacking，在Opotiki的<a href="http://www.riverlock.co.nz" target="_blank" rel="noopener">Riverlock</a>，是怎么找到的呢？Walk in~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">直接到果园、工厂所在地，到前台找相关负责人问相关岗位是否还缺人。一般会当场得到答复，或者填表等待通知。</span><br></pre></td></tr></table></figure><p>我也是来了才知道的一种找工作方式，效果特别好，有时候打电话没用，亲自去前台问却会有满意答复。</p><p>一开始，我们去Opotiki是因为联系到一个中间人Jess，她帮我们联系的工头，做kiwifruit pruning，但工头不想跟做得不够快的人签合同，因为签合同意味着必须给最低工资，于是叫你一直试工（计件不计时），确定你能达到最低工资要求了，再签约。这不是坑吗？不做被剥削的人民！不干~</p><p>此时我看到微信群消息，Te puke的哪哪哪packhouse在招工。packhouse是什么？之前不知道有这个工种，都在找orchard的户外工作。Google一下，嗷，做包装的，特点是室内、工时稳定，订单多的时候工时还很长，存钱快。感觉做这个也挺好的，我在Google Map上一搜packhouse，咦，Opotiki也有很多家！走起~</p><p>Google Map的搜索技巧很重要，”opotiki packhouse”、”opotiki pack house”、”opotiki pack”我都试了下，得到以下结果：</p><p><img src="http://cdn.sinacloud.net/workingholiday/whv-job-hunting/opotikiPackhouse.png" alt="&quot;Opotiki pack results&quot;"></p><p>接下来就是看着地图，挨家去walk in了。</p><p>walk in Opotiki的三家packhouse（Eastpack、OPAC、Riverlock），反正最后捏，Riverlock的老大Audrey叫我们下周一去上班，我们开始了持续1个半月的kiwifruit repacking工作。具体过程不再详述了，因为在之前的一篇日志<a href="/nz/blog/archives/about-work/#关于“工作”这件小事">《当临时工1周，我买了辆车》</a>已经写过啦 ：）</p><h1 id="第二份工作"><a href="#第二份工作" class="headerlink" title="第二份工作"></a>第二份工作</h1><p>回到文章的一开头，来Katikati找酒庄工作，却拿到了2个packhouse的offer，都是因为在对的时间去了合适的地方，后来了解到不是长期招人，刚好有一批员工离开。Katikati周边的packhouse和orchard都很多，特别多工作机会~</p><p>故技重施，在Google Map上搜”Katikati packhouse”，结果超多：<br><img src="http://cdn.sinacloud.net/workingholiday/whv-job-hunting/katikatiPackhouse.png" alt="&quot;Katikati packhouse&quot;"></p><p>我们花了一个多小时walk in，几乎全问了一遍，加上我们有repacking的经验（在一个领域有经验，后面找工作真的容易很多），最后Seeka和HUME都说要人，明天来签合同~Bingo！</p><p><img src="http://cdn.sinacloud.net/workingholiday/whv-job-hunting/jobList.jpg" alt="&quot;找工记录&quot;"><br><img src="http://cdn.sinacloud.net/workingholiday/whv-job-hunting/seekaContract.jpg" alt="&quot;Seeka的合同&quot;">  </p><p>看看我们的工作时间公告牌和工作环境（内容）吧~<br><img src="http://cdn.sinacloud.net/workingholiday/whv-job-hunting/seekaWorktime.JPG" alt="&quot;公告牌&quot;"><br><img src="http://cdn.sinacloud.net/workingholiday/whv-job-hunting/seekaScene.JPG" alt="&quot;Seeka一角&quot;">  </p><h1 id="找工tips"><a href="#找工tips" class="headerlink" title="找工tips"></a>找工tips</h1><ul><li>留意各大working holiday群的工作消息，可以发现你原本不知道的工种；</li><li>通过本地人介绍/去i-Site问，可能会了解到地图上搜不到的工厂；</li><li>不做伸手党，自己Google和walk in；</li><li>在一个领域有了经验，下次再找类似工作会更有优势。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;叫我找工小能手！&lt;/p&gt;
    
    </summary>
    
    
      <category term="working holiday" scheme="http://wuyuying.com/tags/working-holiday/"/>
    
      <category term="whv" scheme="http://wuyuying.com/tags/whv/"/>
    
      <category term="New Zealand" scheme="http://wuyuying.com/tags/New-Zealand/"/>
    
  </entry>
  
</feed>
